/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.Coupon = (function() {

    /**
     * Properties of a Coupon.
     * @exports ICoupon
     * @interface ICoupon
     * @property {string|null} [hash] Coupon hash
     * @property {string|null} [code] Coupon code
     */

    /**
     * Constructs a new Coupon.
     * @exports Coupon
     * @classdesc Represents a Coupon.
     * @implements ICoupon
     * @constructor
     * @param {ICoupon=} [properties] Properties to set
     */
    function Coupon(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Coupon hash.
     * @member {string} hash
     * @memberof Coupon
     * @instance
     */
    Coupon.prototype.hash = "";

    /**
     * Coupon code.
     * @member {string} code
     * @memberof Coupon
     * @instance
     */
    Coupon.prototype.code = "";

    /**
     * Creates a new Coupon instance using the specified properties.
     * @function create
     * @memberof Coupon
     * @static
     * @param {ICoupon=} [properties] Properties to set
     * @returns {Coupon} Coupon instance
     */
    Coupon.create = function create(properties) {
        return new Coupon(properties);
    };

    /**
     * Encodes the specified Coupon message. Does not implicitly {@link Coupon.verify|verify} messages.
     * @function encode
     * @memberof Coupon
     * @static
     * @param {ICoupon} message Coupon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Coupon.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
        if (message.code != null && message.hasOwnProperty("code"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
        return writer;
    };

    /**
     * Encodes the specified Coupon message, length delimited. Does not implicitly {@link Coupon.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Coupon
     * @static
     * @param {ICoupon} message Coupon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Coupon.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Coupon message from the specified reader or buffer.
     * @function decode
     * @memberof Coupon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Coupon} Coupon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Coupon.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Coupon();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.hash = reader.string();
                break;
            case 2:
                message.code = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Coupon message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Coupon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Coupon} Coupon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Coupon.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Coupon message.
     * @function verify
     * @memberof Coupon
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Coupon.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.hash != null && message.hasOwnProperty("hash"))
            if (!$util.isString(message.hash))
                return "hash: string expected";
        if (message.code != null && message.hasOwnProperty("code"))
            if (!$util.isString(message.code))
                return "code: string expected";
        return null;
    };

    /**
     * Creates a Coupon message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Coupon
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Coupon} Coupon
     */
    Coupon.fromObject = function fromObject(object) {
        if (object instanceof $root.Coupon)
            return object;
        var message = new $root.Coupon();
        if (object.hash != null)
            message.hash = String(object.hash);
        if (object.code != null)
            message.code = String(object.code);
        return message;
    };

    /**
     * Creates a plain object from a Coupon message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Coupon
     * @static
     * @param {Coupon} message Coupon
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Coupon.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.hash = "";
            object.code = "";
        }
        if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = message.hash;
        if (message.code != null && message.hasOwnProperty("code"))
            object.code = message.code;
        return object;
    };

    /**
     * Converts this Coupon to JSON.
     * @function toJSON
     * @memberof Coupon
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Coupon.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Coupon;
})();

$root.OrderRespApi = (function() {

    /**
     * Properties of an OrderRespApi.
     * @exports IOrderRespApi
     * @interface IOrderRespApi
     * @property {IRicardianContract|null} [contract] OrderRespApi contract
     * @property {OrderState|null} [state] Order contract
     * @property {boolean|null} [read] State of the order
     * @property {boolean|null} [funded] Whether or not the order has been by the vendor
     * @property {number|Long|null} [unreadChatMessages] Whether the order is funded
     * @property {Array.<ITransactionRecord>|null} [paymentAddressTransactions] number of unread chat messages associated
     * @property {ITransactionRecord|null} [refundAddressTransaction] Payments funding the order
     */

    /**
     * Constructs a new OrderRespApi.
     * @exports OrderRespApi
     * @classdesc Represents an OrderRespApi.
     * @implements IOrderRespApi
     * @constructor
     * @param {IOrderRespApi=} [properties] Properties to set
     */
    function OrderRespApi(properties) {
        this.paymentAddressTransactions = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OrderRespApi contract.
     * @member {IRicardianContract|null|undefined} contract
     * @memberof OrderRespApi
     * @instance
     */
    OrderRespApi.prototype.contract = null;

    /**
     * Order contract
     * @member {OrderState} state
     * @memberof OrderRespApi
     * @instance
     */
    OrderRespApi.prototype.state = 0;

    /**
     * State of the order
     * @member {boolean} read
     * @memberof OrderRespApi
     * @instance
     */
    OrderRespApi.prototype.read = false;

    /**
     * Whether or not the order has been by the vendor
     * @member {boolean} funded
     * @memberof OrderRespApi
     * @instance
     */
    OrderRespApi.prototype.funded = false;

    /**
     * Whether the order is funded
     * @member {number|Long} unreadChatMessages
     * @memberof OrderRespApi
     * @instance
     */
    OrderRespApi.prototype.unreadChatMessages = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * number of unread chat messages associated
     * @member {Array.<ITransactionRecord>} paymentAddressTransactions
     * @memberof OrderRespApi
     * @instance
     */
    OrderRespApi.prototype.paymentAddressTransactions = $util.emptyArray;

    /**
     * Payments funding the order
     * @member {ITransactionRecord|null|undefined} refundAddressTransaction
     * @memberof OrderRespApi
     * @instance
     */
    OrderRespApi.prototype.refundAddressTransaction = null;

    /**
     * Creates a new OrderRespApi instance using the specified properties.
     * @function create
     * @memberof OrderRespApi
     * @static
     * @param {IOrderRespApi=} [properties] Properties to set
     * @returns {OrderRespApi} OrderRespApi instance
     */
    OrderRespApi.create = function create(properties) {
        return new OrderRespApi(properties);
    };

    /**
     * Encodes the specified OrderRespApi message. Does not implicitly {@link OrderRespApi.verify|verify} messages.
     * @function encode
     * @memberof OrderRespApi
     * @static
     * @param {IOrderRespApi} message OrderRespApi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderRespApi.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.contract != null && message.hasOwnProperty("contract"))
            $root.RicardianContract.encode(message.contract, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.state != null && message.hasOwnProperty("state"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
        if (message.read != null && message.hasOwnProperty("read"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.read);
        if (message.funded != null && message.hasOwnProperty("funded"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.funded);
        if (message.unreadChatMessages != null && message.hasOwnProperty("unreadChatMessages"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.unreadChatMessages);
        if (message.paymentAddressTransactions != null && message.paymentAddressTransactions.length)
            for (var i = 0; i < message.paymentAddressTransactions.length; ++i)
                $root.TransactionRecord.encode(message.paymentAddressTransactions[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.refundAddressTransaction != null && message.hasOwnProperty("refundAddressTransaction"))
            $root.TransactionRecord.encode(message.refundAddressTransaction, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OrderRespApi message, length delimited. Does not implicitly {@link OrderRespApi.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OrderRespApi
     * @static
     * @param {IOrderRespApi} message OrderRespApi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderRespApi.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OrderRespApi message from the specified reader or buffer.
     * @function decode
     * @memberof OrderRespApi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OrderRespApi} OrderRespApi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderRespApi.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderRespApi();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.contract = $root.RicardianContract.decode(reader, reader.uint32());
                break;
            case 2:
                message.state = reader.int32();
                break;
            case 3:
                message.read = reader.bool();
                break;
            case 4:
                message.funded = reader.bool();
                break;
            case 5:
                message.unreadChatMessages = reader.uint64();
                break;
            case 6:
                if (!(message.paymentAddressTransactions && message.paymentAddressTransactions.length))
                    message.paymentAddressTransactions = [];
                message.paymentAddressTransactions.push($root.TransactionRecord.decode(reader, reader.uint32()));
                break;
            case 7:
                message.refundAddressTransaction = $root.TransactionRecord.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OrderRespApi message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OrderRespApi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OrderRespApi} OrderRespApi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderRespApi.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OrderRespApi message.
     * @function verify
     * @memberof OrderRespApi
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OrderRespApi.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.contract != null && message.hasOwnProperty("contract")) {
            var error = $root.RicardianContract.verify(message.contract);
            if (error)
                return "contract." + error;
        }
        if (message.state != null && message.hasOwnProperty("state"))
            switch (message.state) {
            default:
                return "state: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
                break;
            }
        if (message.read != null && message.hasOwnProperty("read"))
            if (typeof message.read !== "boolean")
                return "read: boolean expected";
        if (message.funded != null && message.hasOwnProperty("funded"))
            if (typeof message.funded !== "boolean")
                return "funded: boolean expected";
        if (message.unreadChatMessages != null && message.hasOwnProperty("unreadChatMessages"))
            if (!$util.isInteger(message.unreadChatMessages) && !(message.unreadChatMessages && $util.isInteger(message.unreadChatMessages.low) && $util.isInteger(message.unreadChatMessages.high)))
                return "unreadChatMessages: integer|Long expected";
        if (message.paymentAddressTransactions != null && message.hasOwnProperty("paymentAddressTransactions")) {
            if (!Array.isArray(message.paymentAddressTransactions))
                return "paymentAddressTransactions: array expected";
            for (var i = 0; i < message.paymentAddressTransactions.length; ++i) {
                var error = $root.TransactionRecord.verify(message.paymentAddressTransactions[i]);
                if (error)
                    return "paymentAddressTransactions." + error;
            }
        }
        if (message.refundAddressTransaction != null && message.hasOwnProperty("refundAddressTransaction")) {
            var error = $root.TransactionRecord.verify(message.refundAddressTransaction);
            if (error)
                return "refundAddressTransaction." + error;
        }
        return null;
    };

    /**
     * Creates an OrderRespApi message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OrderRespApi
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OrderRespApi} OrderRespApi
     */
    OrderRespApi.fromObject = function fromObject(object) {
        if (object instanceof $root.OrderRespApi)
            return object;
        var message = new $root.OrderRespApi();
        if (object.contract != null) {
            if (typeof object.contract !== "object")
                throw TypeError(".OrderRespApi.contract: object expected");
            message.contract = $root.RicardianContract.fromObject(object.contract);
        }
        switch (object.state) {
        case "PENDING":
        case 0:
            message.state = 0;
            break;
        case "AWAITING_PAYMENT":
        case 1:
            message.state = 1;
            break;
        case "AWAITING_PICKUP":
        case 2:
            message.state = 2;
            break;
        case "AWAITING_FULFILLMENT":
        case 3:
            message.state = 3;
            break;
        case "PARTIALLY_FULFILLED":
        case 4:
            message.state = 4;
            break;
        case "FULFILLED":
        case 5:
            message.state = 5;
            break;
        case "COMPLETED":
        case 6:
            message.state = 6;
            break;
        case "CANCELED":
        case 7:
            message.state = 7;
            break;
        case "DECLINED":
        case 8:
            message.state = 8;
            break;
        case "REFUNDED":
        case 9:
            message.state = 9;
            break;
        case "DISPUTED":
        case 10:
            message.state = 10;
            break;
        case "DECIDED":
        case 11:
            message.state = 11;
            break;
        case "RESOLVED":
        case 12:
            message.state = 12;
            break;
        case "PAYMENT_FINALIZED":
        case 13:
            message.state = 13;
            break;
        case "PROCESSING_ERROR":
        case 14:
            message.state = 14;
            break;
        }
        if (object.read != null)
            message.read = Boolean(object.read);
        if (object.funded != null)
            message.funded = Boolean(object.funded);
        if (object.unreadChatMessages != null)
            if ($util.Long)
                (message.unreadChatMessages = $util.Long.fromValue(object.unreadChatMessages)).unsigned = true;
            else if (typeof object.unreadChatMessages === "string")
                message.unreadChatMessages = parseInt(object.unreadChatMessages, 10);
            else if (typeof object.unreadChatMessages === "number")
                message.unreadChatMessages = object.unreadChatMessages;
            else if (typeof object.unreadChatMessages === "object")
                message.unreadChatMessages = new $util.LongBits(object.unreadChatMessages.low >>> 0, object.unreadChatMessages.high >>> 0).toNumber(true);
        if (object.paymentAddressTransactions) {
            if (!Array.isArray(object.paymentAddressTransactions))
                throw TypeError(".OrderRespApi.paymentAddressTransactions: array expected");
            message.paymentAddressTransactions = [];
            for (var i = 0; i < object.paymentAddressTransactions.length; ++i) {
                if (typeof object.paymentAddressTransactions[i] !== "object")
                    throw TypeError(".OrderRespApi.paymentAddressTransactions: object expected");
                message.paymentAddressTransactions[i] = $root.TransactionRecord.fromObject(object.paymentAddressTransactions[i]);
            }
        }
        if (object.refundAddressTransaction != null) {
            if (typeof object.refundAddressTransaction !== "object")
                throw TypeError(".OrderRespApi.refundAddressTransaction: object expected");
            message.refundAddressTransaction = $root.TransactionRecord.fromObject(object.refundAddressTransaction);
        }
        return message;
    };

    /**
     * Creates a plain object from an OrderRespApi message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OrderRespApi
     * @static
     * @param {OrderRespApi} message OrderRespApi
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OrderRespApi.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.paymentAddressTransactions = [];
        if (options.defaults) {
            object.contract = null;
            object.state = options.enums === String ? "PENDING" : 0;
            object.read = false;
            object.funded = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.unreadChatMessages = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.unreadChatMessages = options.longs === String ? "0" : 0;
            object.refundAddressTransaction = null;
        }
        if (message.contract != null && message.hasOwnProperty("contract"))
            object.contract = $root.RicardianContract.toObject(message.contract, options);
        if (message.state != null && message.hasOwnProperty("state"))
            object.state = options.enums === String ? $root.OrderState[message.state] : message.state;
        if (message.read != null && message.hasOwnProperty("read"))
            object.read = message.read;
        if (message.funded != null && message.hasOwnProperty("funded"))
            object.funded = message.funded;
        if (message.unreadChatMessages != null && message.hasOwnProperty("unreadChatMessages"))
            if (typeof message.unreadChatMessages === "number")
                object.unreadChatMessages = options.longs === String ? String(message.unreadChatMessages) : message.unreadChatMessages;
            else
                object.unreadChatMessages = options.longs === String ? $util.Long.prototype.toString.call(message.unreadChatMessages) : options.longs === Number ? new $util.LongBits(message.unreadChatMessages.low >>> 0, message.unreadChatMessages.high >>> 0).toNumber(true) : message.unreadChatMessages;
        if (message.paymentAddressTransactions && message.paymentAddressTransactions.length) {
            object.paymentAddressTransactions = [];
            for (var j = 0; j < message.paymentAddressTransactions.length; ++j)
                object.paymentAddressTransactions[j] = $root.TransactionRecord.toObject(message.paymentAddressTransactions[j], options);
        }
        if (message.refundAddressTransaction != null && message.hasOwnProperty("refundAddressTransaction"))
            object.refundAddressTransaction = $root.TransactionRecord.toObject(message.refundAddressTransaction, options);
        return object;
    };

    /**
     * Converts this OrderRespApi to JSON.
     * @function toJSON
     * @memberof OrderRespApi
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OrderRespApi.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OrderRespApi;
})();

$root.CaseRespApi = (function() {

    /**
     * Properties of a CaseRespApi.
     * @exports ICaseRespApi
     * @interface ICaseRespApi
     * @property {google.protobuf.ITimestamp|null} [timestamp] CaseRespApi timestamp
     * @property {IRicardianContract|null} [buyerContract] CaseRespApi buyerContract
     * @property {IRicardianContract|null} [vendorContract] CaseRespApi vendorContract
     * @property {Array.<string>|null} [buyerContractValidationErrors] CaseRespApi buyerContractValidationErrors
     * @property {Array.<string>|null} [vendorContractValidationErrors] CaseRespApi vendorContractValidationErrors
     * @property {OrderState|null} [state] CaseRespApi state
     * @property {boolean|null} [read] CaseRespApi read
     * @property {boolean|null} [buyerOpened] Whether or not the message has been read
     * @property {string|null} [claim] CaseRespApi claim
     * @property {number|Long|null} [unreadChatMessages] CaseRespApi unreadChatMessages
     * @property {IDisputeResolution|null} [resolution] CaseRespApi resolution
     */

    /**
     * Constructs a new CaseRespApi.
     * @exports CaseRespApi
     * @classdesc Represents a CaseRespApi.
     * @implements ICaseRespApi
     * @constructor
     * @param {ICaseRespApi=} [properties] Properties to set
     */
    function CaseRespApi(properties) {
        this.buyerContractValidationErrors = [];
        this.vendorContractValidationErrors = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CaseRespApi timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.timestamp = null;

    /**
     * CaseRespApi buyerContract.
     * @member {IRicardianContract|null|undefined} buyerContract
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.buyerContract = null;

    /**
     * CaseRespApi vendorContract.
     * @member {IRicardianContract|null|undefined} vendorContract
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.vendorContract = null;

    /**
     * CaseRespApi buyerContractValidationErrors.
     * @member {Array.<string>} buyerContractValidationErrors
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.buyerContractValidationErrors = $util.emptyArray;

    /**
     * CaseRespApi vendorContractValidationErrors.
     * @member {Array.<string>} vendorContractValidationErrors
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.vendorContractValidationErrors = $util.emptyArray;

    /**
     * CaseRespApi state.
     * @member {OrderState} state
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.state = 0;

    /**
     * CaseRespApi read.
     * @member {boolean} read
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.read = false;

    /**
     * Whether or not the message has been read
     * @member {boolean} buyerOpened
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.buyerOpened = false;

    /**
     * CaseRespApi claim.
     * @member {string} claim
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.claim = "";

    /**
     * CaseRespApi unreadChatMessages.
     * @member {number|Long} unreadChatMessages
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.unreadChatMessages = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * CaseRespApi resolution.
     * @member {IDisputeResolution|null|undefined} resolution
     * @memberof CaseRespApi
     * @instance
     */
    CaseRespApi.prototype.resolution = null;

    /**
     * Creates a new CaseRespApi instance using the specified properties.
     * @function create
     * @memberof CaseRespApi
     * @static
     * @param {ICaseRespApi=} [properties] Properties to set
     * @returns {CaseRespApi} CaseRespApi instance
     */
    CaseRespApi.create = function create(properties) {
        return new CaseRespApi(properties);
    };

    /**
     * Encodes the specified CaseRespApi message. Does not implicitly {@link CaseRespApi.verify|verify} messages.
     * @function encode
     * @memberof CaseRespApi
     * @static
     * @param {ICaseRespApi} message CaseRespApi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CaseRespApi.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.buyerContract != null && message.hasOwnProperty("buyerContract"))
            $root.RicardianContract.encode(message.buyerContract, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.vendorContract != null && message.hasOwnProperty("vendorContract"))
            $root.RicardianContract.encode(message.vendorContract, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.buyerContractValidationErrors != null && message.buyerContractValidationErrors.length)
            for (var i = 0; i < message.buyerContractValidationErrors.length; ++i)
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.buyerContractValidationErrors[i]);
        if (message.vendorContractValidationErrors != null && message.vendorContractValidationErrors.length)
            for (var i = 0; i < message.vendorContractValidationErrors.length; ++i)
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.vendorContractValidationErrors[i]);
        if (message.state != null && message.hasOwnProperty("state"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.state);
        if (message.read != null && message.hasOwnProperty("read"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.read);
        if (message.buyerOpened != null && message.hasOwnProperty("buyerOpened"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.buyerOpened);
        if (message.claim != null && message.hasOwnProperty("claim"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.claim);
        if (message.unreadChatMessages != null && message.hasOwnProperty("unreadChatMessages"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.unreadChatMessages);
        if (message.resolution != null && message.hasOwnProperty("resolution"))
            $root.DisputeResolution.encode(message.resolution, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CaseRespApi message, length delimited. Does not implicitly {@link CaseRespApi.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CaseRespApi
     * @static
     * @param {ICaseRespApi} message CaseRespApi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CaseRespApi.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CaseRespApi message from the specified reader or buffer.
     * @function decode
     * @memberof CaseRespApi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CaseRespApi} CaseRespApi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CaseRespApi.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CaseRespApi();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 2:
                message.buyerContract = $root.RicardianContract.decode(reader, reader.uint32());
                break;
            case 3:
                message.vendorContract = $root.RicardianContract.decode(reader, reader.uint32());
                break;
            case 4:
                if (!(message.buyerContractValidationErrors && message.buyerContractValidationErrors.length))
                    message.buyerContractValidationErrors = [];
                message.buyerContractValidationErrors.push(reader.string());
                break;
            case 5:
                if (!(message.vendorContractValidationErrors && message.vendorContractValidationErrors.length))
                    message.vendorContractValidationErrors = [];
                message.vendorContractValidationErrors.push(reader.string());
                break;
            case 6:
                message.state = reader.int32();
                break;
            case 7:
                message.read = reader.bool();
                break;
            case 8:
                message.buyerOpened = reader.bool();
                break;
            case 9:
                message.claim = reader.string();
                break;
            case 10:
                message.unreadChatMessages = reader.uint64();
                break;
            case 11:
                message.resolution = $root.DisputeResolution.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CaseRespApi message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CaseRespApi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CaseRespApi} CaseRespApi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CaseRespApi.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CaseRespApi message.
     * @function verify
     * @memberof CaseRespApi
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CaseRespApi.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.buyerContract != null && message.hasOwnProperty("buyerContract")) {
            var error = $root.RicardianContract.verify(message.buyerContract);
            if (error)
                return "buyerContract." + error;
        }
        if (message.vendorContract != null && message.hasOwnProperty("vendorContract")) {
            var error = $root.RicardianContract.verify(message.vendorContract);
            if (error)
                return "vendorContract." + error;
        }
        if (message.buyerContractValidationErrors != null && message.hasOwnProperty("buyerContractValidationErrors")) {
            if (!Array.isArray(message.buyerContractValidationErrors))
                return "buyerContractValidationErrors: array expected";
            for (var i = 0; i < message.buyerContractValidationErrors.length; ++i)
                if (!$util.isString(message.buyerContractValidationErrors[i]))
                    return "buyerContractValidationErrors: string[] expected";
        }
        if (message.vendorContractValidationErrors != null && message.hasOwnProperty("vendorContractValidationErrors")) {
            if (!Array.isArray(message.vendorContractValidationErrors))
                return "vendorContractValidationErrors: array expected";
            for (var i = 0; i < message.vendorContractValidationErrors.length; ++i)
                if (!$util.isString(message.vendorContractValidationErrors[i]))
                    return "vendorContractValidationErrors: string[] expected";
        }
        if (message.state != null && message.hasOwnProperty("state"))
            switch (message.state) {
            default:
                return "state: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
                break;
            }
        if (message.read != null && message.hasOwnProperty("read"))
            if (typeof message.read !== "boolean")
                return "read: boolean expected";
        if (message.buyerOpened != null && message.hasOwnProperty("buyerOpened"))
            if (typeof message.buyerOpened !== "boolean")
                return "buyerOpened: boolean expected";
        if (message.claim != null && message.hasOwnProperty("claim"))
            if (!$util.isString(message.claim))
                return "claim: string expected";
        if (message.unreadChatMessages != null && message.hasOwnProperty("unreadChatMessages"))
            if (!$util.isInteger(message.unreadChatMessages) && !(message.unreadChatMessages && $util.isInteger(message.unreadChatMessages.low) && $util.isInteger(message.unreadChatMessages.high)))
                return "unreadChatMessages: integer|Long expected";
        if (message.resolution != null && message.hasOwnProperty("resolution")) {
            var error = $root.DisputeResolution.verify(message.resolution);
            if (error)
                return "resolution." + error;
        }
        return null;
    };

    /**
     * Creates a CaseRespApi message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CaseRespApi
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CaseRespApi} CaseRespApi
     */
    CaseRespApi.fromObject = function fromObject(object) {
        if (object instanceof $root.CaseRespApi)
            return object;
        var message = new $root.CaseRespApi();
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".CaseRespApi.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.buyerContract != null) {
            if (typeof object.buyerContract !== "object")
                throw TypeError(".CaseRespApi.buyerContract: object expected");
            message.buyerContract = $root.RicardianContract.fromObject(object.buyerContract);
        }
        if (object.vendorContract != null) {
            if (typeof object.vendorContract !== "object")
                throw TypeError(".CaseRespApi.vendorContract: object expected");
            message.vendorContract = $root.RicardianContract.fromObject(object.vendorContract);
        }
        if (object.buyerContractValidationErrors) {
            if (!Array.isArray(object.buyerContractValidationErrors))
                throw TypeError(".CaseRespApi.buyerContractValidationErrors: array expected");
            message.buyerContractValidationErrors = [];
            for (var i = 0; i < object.buyerContractValidationErrors.length; ++i)
                message.buyerContractValidationErrors[i] = String(object.buyerContractValidationErrors[i]);
        }
        if (object.vendorContractValidationErrors) {
            if (!Array.isArray(object.vendorContractValidationErrors))
                throw TypeError(".CaseRespApi.vendorContractValidationErrors: array expected");
            message.vendorContractValidationErrors = [];
            for (var i = 0; i < object.vendorContractValidationErrors.length; ++i)
                message.vendorContractValidationErrors[i] = String(object.vendorContractValidationErrors[i]);
        }
        switch (object.state) {
        case "PENDING":
        case 0:
            message.state = 0;
            break;
        case "AWAITING_PAYMENT":
        case 1:
            message.state = 1;
            break;
        case "AWAITING_PICKUP":
        case 2:
            message.state = 2;
            break;
        case "AWAITING_FULFILLMENT":
        case 3:
            message.state = 3;
            break;
        case "PARTIALLY_FULFILLED":
        case 4:
            message.state = 4;
            break;
        case "FULFILLED":
        case 5:
            message.state = 5;
            break;
        case "COMPLETED":
        case 6:
            message.state = 6;
            break;
        case "CANCELED":
        case 7:
            message.state = 7;
            break;
        case "DECLINED":
        case 8:
            message.state = 8;
            break;
        case "REFUNDED":
        case 9:
            message.state = 9;
            break;
        case "DISPUTED":
        case 10:
            message.state = 10;
            break;
        case "DECIDED":
        case 11:
            message.state = 11;
            break;
        case "RESOLVED":
        case 12:
            message.state = 12;
            break;
        case "PAYMENT_FINALIZED":
        case 13:
            message.state = 13;
            break;
        case "PROCESSING_ERROR":
        case 14:
            message.state = 14;
            break;
        }
        if (object.read != null)
            message.read = Boolean(object.read);
        if (object.buyerOpened != null)
            message.buyerOpened = Boolean(object.buyerOpened);
        if (object.claim != null)
            message.claim = String(object.claim);
        if (object.unreadChatMessages != null)
            if ($util.Long)
                (message.unreadChatMessages = $util.Long.fromValue(object.unreadChatMessages)).unsigned = true;
            else if (typeof object.unreadChatMessages === "string")
                message.unreadChatMessages = parseInt(object.unreadChatMessages, 10);
            else if (typeof object.unreadChatMessages === "number")
                message.unreadChatMessages = object.unreadChatMessages;
            else if (typeof object.unreadChatMessages === "object")
                message.unreadChatMessages = new $util.LongBits(object.unreadChatMessages.low >>> 0, object.unreadChatMessages.high >>> 0).toNumber(true);
        if (object.resolution != null) {
            if (typeof object.resolution !== "object")
                throw TypeError(".CaseRespApi.resolution: object expected");
            message.resolution = $root.DisputeResolution.fromObject(object.resolution);
        }
        return message;
    };

    /**
     * Creates a plain object from a CaseRespApi message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CaseRespApi
     * @static
     * @param {CaseRespApi} message CaseRespApi
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CaseRespApi.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.buyerContractValidationErrors = [];
            object.vendorContractValidationErrors = [];
        }
        if (options.defaults) {
            object.timestamp = null;
            object.buyerContract = null;
            object.vendorContract = null;
            object.state = options.enums === String ? "PENDING" : 0;
            object.read = false;
            object.buyerOpened = false;
            object.claim = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.unreadChatMessages = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.unreadChatMessages = options.longs === String ? "0" : 0;
            object.resolution = null;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.buyerContract != null && message.hasOwnProperty("buyerContract"))
            object.buyerContract = $root.RicardianContract.toObject(message.buyerContract, options);
        if (message.vendorContract != null && message.hasOwnProperty("vendorContract"))
            object.vendorContract = $root.RicardianContract.toObject(message.vendorContract, options);
        if (message.buyerContractValidationErrors && message.buyerContractValidationErrors.length) {
            object.buyerContractValidationErrors = [];
            for (var j = 0; j < message.buyerContractValidationErrors.length; ++j)
                object.buyerContractValidationErrors[j] = message.buyerContractValidationErrors[j];
        }
        if (message.vendorContractValidationErrors && message.vendorContractValidationErrors.length) {
            object.vendorContractValidationErrors = [];
            for (var j = 0; j < message.vendorContractValidationErrors.length; ++j)
                object.vendorContractValidationErrors[j] = message.vendorContractValidationErrors[j];
        }
        if (message.state != null && message.hasOwnProperty("state"))
            object.state = options.enums === String ? $root.OrderState[message.state] : message.state;
        if (message.read != null && message.hasOwnProperty("read"))
            object.read = message.read;
        if (message.buyerOpened != null && message.hasOwnProperty("buyerOpened"))
            object.buyerOpened = message.buyerOpened;
        if (message.claim != null && message.hasOwnProperty("claim"))
            object.claim = message.claim;
        if (message.unreadChatMessages != null && message.hasOwnProperty("unreadChatMessages"))
            if (typeof message.unreadChatMessages === "number")
                object.unreadChatMessages = options.longs === String ? String(message.unreadChatMessages) : message.unreadChatMessages;
            else
                object.unreadChatMessages = options.longs === String ? $util.Long.prototype.toString.call(message.unreadChatMessages) : options.longs === Number ? new $util.LongBits(message.unreadChatMessages.low >>> 0, message.unreadChatMessages.high >>> 0).toNumber(true) : message.unreadChatMessages;
        if (message.resolution != null && message.hasOwnProperty("resolution"))
            object.resolution = $root.DisputeResolution.toObject(message.resolution, options);
        return object;
    };

    /**
     * Converts this CaseRespApi to JSON.
     * @function toJSON
     * @memberof CaseRespApi
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CaseRespApi.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CaseRespApi;
})();

$root.TransactionRecord = (function() {

    /**
     * Properties of a TransactionRecord.
     * @exports ITransactionRecord
     * @interface ITransactionRecord
     * @property {string|null} [txid] TransactionRecord txid
     * @property {number|Long|null} [value] The unique transactionRecord ID.
     * @property {number|null} [confirmations] TransactionRecord confirmations
     * @property {number|null} [height] TransactionRecord height
     * @property {google.protobuf.ITimestamp|null} [timestamp] TransactionRecord timestamp
     */

    /**
     * Constructs a new TransactionRecord.
     * @exports TransactionRecord
     * @classdesc Represents a TransactionRecord.
     * @implements ITransactionRecord
     * @constructor
     * @param {ITransactionRecord=} [properties] Properties to set
     */
    function TransactionRecord(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TransactionRecord txid.
     * @member {string} txid
     * @memberof TransactionRecord
     * @instance
     */
    TransactionRecord.prototype.txid = "";

    /**
     * The unique transactionRecord ID.
     * @member {number|Long} value
     * @memberof TransactionRecord
     * @instance
     */
    TransactionRecord.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * TransactionRecord confirmations.
     * @member {number} confirmations
     * @memberof TransactionRecord
     * @instance
     */
    TransactionRecord.prototype.confirmations = 0;

    /**
     * TransactionRecord height.
     * @member {number} height
     * @memberof TransactionRecord
     * @instance
     */
    TransactionRecord.prototype.height = 0;

    /**
     * TransactionRecord timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof TransactionRecord
     * @instance
     */
    TransactionRecord.prototype.timestamp = null;

    /**
     * Creates a new TransactionRecord instance using the specified properties.
     * @function create
     * @memberof TransactionRecord
     * @static
     * @param {ITransactionRecord=} [properties] Properties to set
     * @returns {TransactionRecord} TransactionRecord instance
     */
    TransactionRecord.create = function create(properties) {
        return new TransactionRecord(properties);
    };

    /**
     * Encodes the specified TransactionRecord message. Does not implicitly {@link TransactionRecord.verify|verify} messages.
     * @function encode
     * @memberof TransactionRecord
     * @static
     * @param {ITransactionRecord} message TransactionRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TransactionRecord.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.txid != null && message.hasOwnProperty("txid"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
        if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value);
        if (message.confirmations != null && message.hasOwnProperty("confirmations"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.confirmations);
        if (message.height != null && message.hasOwnProperty("height"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.height);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified TransactionRecord message, length delimited. Does not implicitly {@link TransactionRecord.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TransactionRecord
     * @static
     * @param {ITransactionRecord} message TransactionRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TransactionRecord.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TransactionRecord message from the specified reader or buffer.
     * @function decode
     * @memberof TransactionRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TransactionRecord} TransactionRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TransactionRecord.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TransactionRecord();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.txid = reader.string();
                break;
            case 2:
                message.value = reader.int64();
                break;
            case 3:
                message.confirmations = reader.uint32();
                break;
            case 4:
                message.height = reader.uint32();
                break;
            case 5:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TransactionRecord message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TransactionRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TransactionRecord} TransactionRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TransactionRecord.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TransactionRecord message.
     * @function verify
     * @memberof TransactionRecord
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TransactionRecord.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.txid != null && message.hasOwnProperty("txid"))
            if (!$util.isString(message.txid))
                return "txid: string expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                return "value: integer|Long expected";
        if (message.confirmations != null && message.hasOwnProperty("confirmations"))
            if (!$util.isInteger(message.confirmations))
                return "confirmations: integer expected";
        if (message.height != null && message.hasOwnProperty("height"))
            if (!$util.isInteger(message.height))
                return "height: integer expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        return null;
    };

    /**
     * Creates a TransactionRecord message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TransactionRecord
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TransactionRecord} TransactionRecord
     */
    TransactionRecord.fromObject = function fromObject(object) {
        if (object instanceof $root.TransactionRecord)
            return object;
        var message = new $root.TransactionRecord();
        if (object.txid != null)
            message.txid = String(object.txid);
        if (object.value != null)
            if ($util.Long)
                (message.value = $util.Long.fromValue(object.value)).unsigned = false;
            else if (typeof object.value === "string")
                message.value = parseInt(object.value, 10);
            else if (typeof object.value === "number")
                message.value = object.value;
            else if (typeof object.value === "object")
                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
        if (object.confirmations != null)
            message.confirmations = object.confirmations >>> 0;
        if (object.height != null)
            message.height = object.height >>> 0;
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".TransactionRecord.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        return message;
    };

    /**
     * Creates a plain object from a TransactionRecord message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TransactionRecord
     * @static
     * @param {TransactionRecord} message TransactionRecord
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TransactionRecord.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.txid = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.value = options.longs === String ? "0" : 0;
            object.confirmations = 0;
            object.height = 0;
            object.timestamp = null;
        }
        if (message.txid != null && message.hasOwnProperty("txid"))
            object.txid = message.txid;
        if (message.value != null && message.hasOwnProperty("value"))
            if (typeof message.value === "number")
                object.value = options.longs === String ? String(message.value) : message.value;
            else
                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
        if (message.confirmations != null && message.hasOwnProperty("confirmations"))
            object.confirmations = message.confirmations;
        if (message.height != null && message.hasOwnProperty("height"))
            object.height = message.height;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        return object;
    };

    /**
     * Converts this TransactionRecord to JSON.
     * @function toJSON
     * @memberof TransactionRecord
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TransactionRecord.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TransactionRecord;
})();

$root.PeerAndProfile = (function() {

    /**
     * Properties of a PeerAndProfile.
     * @exports IPeerAndProfile
     * @interface IPeerAndProfile
     * @property {string|null} [peerId] PeerAndProfile peerId
     * @property {IProfile|null} [profile] The unique CIDv0 ipfs node identifer.
     */

    /**
     * Constructs a new PeerAndProfile.
     * @exports PeerAndProfile
     * @classdesc Represents a PeerAndProfile.
     * @implements IPeerAndProfile
     * @constructor
     * @param {IPeerAndProfile=} [properties] Properties to set
     */
    function PeerAndProfile(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PeerAndProfile peerId.
     * @member {string} peerId
     * @memberof PeerAndProfile
     * @instance
     */
    PeerAndProfile.prototype.peerId = "";

    /**
     * The unique CIDv0 ipfs node identifer.
     * @member {IProfile|null|undefined} profile
     * @memberof PeerAndProfile
     * @instance
     */
    PeerAndProfile.prototype.profile = null;

    /**
     * Creates a new PeerAndProfile instance using the specified properties.
     * @function create
     * @memberof PeerAndProfile
     * @static
     * @param {IPeerAndProfile=} [properties] Properties to set
     * @returns {PeerAndProfile} PeerAndProfile instance
     */
    PeerAndProfile.create = function create(properties) {
        return new PeerAndProfile(properties);
    };

    /**
     * Encodes the specified PeerAndProfile message. Does not implicitly {@link PeerAndProfile.verify|verify} messages.
     * @function encode
     * @memberof PeerAndProfile
     * @static
     * @param {IPeerAndProfile} message PeerAndProfile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerAndProfile.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerId);
        if (message.profile != null && message.hasOwnProperty("profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PeerAndProfile message, length delimited. Does not implicitly {@link PeerAndProfile.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PeerAndProfile
     * @static
     * @param {IPeerAndProfile} message PeerAndProfile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerAndProfile.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PeerAndProfile message from the specified reader or buffer.
     * @function decode
     * @memberof PeerAndProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PeerAndProfile} PeerAndProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerAndProfile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerAndProfile();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.peerId = reader.string();
                break;
            case 2:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PeerAndProfile message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PeerAndProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PeerAndProfile} PeerAndProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerAndProfile.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PeerAndProfile message.
     * @function verify
     * @memberof PeerAndProfile
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PeerAndProfile.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            if (!$util.isString(message.peerId))
                return "peerId: string expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            var error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a PeerAndProfile message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PeerAndProfile
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PeerAndProfile} PeerAndProfile
     */
    PeerAndProfile.fromObject = function fromObject(object) {
        if (object instanceof $root.PeerAndProfile)
            return object;
        var message = new $root.PeerAndProfile();
        if (object.peerId != null)
            message.peerId = String(object.peerId);
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".PeerAndProfile.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a PeerAndProfile message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PeerAndProfile
     * @static
     * @param {PeerAndProfile} message PeerAndProfile
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PeerAndProfile.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.peerId = "";
            object.profile = null;
        }
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            object.peerId = message.peerId;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this PeerAndProfile to JSON.
     * @function toJSON
     * @memberof PeerAndProfile
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PeerAndProfile.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PeerAndProfile;
})();

$root.PeerAndProfileWithID = (function() {

    /**
     * Properties of a PeerAndProfileWithID.
     * @exports IPeerAndProfileWithID
     * @interface IPeerAndProfileWithID
     * @property {string|null} [id] PeerAndProfileWithID id
     * @property {string|null} [peerId] The unique profile ID.
     * @property {IProfile|null} [profile] The unique CIDv0 ipfs node identifer.
     */

    /**
     * Constructs a new PeerAndProfileWithID.
     * @exports PeerAndProfileWithID
     * @classdesc Represents a PeerAndProfileWithID.
     * @implements IPeerAndProfileWithID
     * @constructor
     * @param {IPeerAndProfileWithID=} [properties] Properties to set
     */
    function PeerAndProfileWithID(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PeerAndProfileWithID id.
     * @member {string} id
     * @memberof PeerAndProfileWithID
     * @instance
     */
    PeerAndProfileWithID.prototype.id = "";

    /**
     * The unique profile ID.
     * @member {string} peerId
     * @memberof PeerAndProfileWithID
     * @instance
     */
    PeerAndProfileWithID.prototype.peerId = "";

    /**
     * The unique CIDv0 ipfs node identifer.
     * @member {IProfile|null|undefined} profile
     * @memberof PeerAndProfileWithID
     * @instance
     */
    PeerAndProfileWithID.prototype.profile = null;

    /**
     * Creates a new PeerAndProfileWithID instance using the specified properties.
     * @function create
     * @memberof PeerAndProfileWithID
     * @static
     * @param {IPeerAndProfileWithID=} [properties] Properties to set
     * @returns {PeerAndProfileWithID} PeerAndProfileWithID instance
     */
    PeerAndProfileWithID.create = function create(properties) {
        return new PeerAndProfileWithID(properties);
    };

    /**
     * Encodes the specified PeerAndProfileWithID message. Does not implicitly {@link PeerAndProfileWithID.verify|verify} messages.
     * @function encode
     * @memberof PeerAndProfileWithID
     * @static
     * @param {IPeerAndProfileWithID} message PeerAndProfileWithID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerAndProfileWithID.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.peerId);
        if (message.profile != null && message.hasOwnProperty("profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PeerAndProfileWithID message, length delimited. Does not implicitly {@link PeerAndProfileWithID.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PeerAndProfileWithID
     * @static
     * @param {IPeerAndProfileWithID} message PeerAndProfileWithID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerAndProfileWithID.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PeerAndProfileWithID message from the specified reader or buffer.
     * @function decode
     * @memberof PeerAndProfileWithID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PeerAndProfileWithID} PeerAndProfileWithID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerAndProfileWithID.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerAndProfileWithID();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.string();
                break;
            case 2:
                message.peerId = reader.string();
                break;
            case 3:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PeerAndProfileWithID message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PeerAndProfileWithID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PeerAndProfileWithID} PeerAndProfileWithID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerAndProfileWithID.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PeerAndProfileWithID message.
     * @function verify
     * @memberof PeerAndProfileWithID
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PeerAndProfileWithID.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            if (!$util.isString(message.peerId))
                return "peerId: string expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            var error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a PeerAndProfileWithID message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PeerAndProfileWithID
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PeerAndProfileWithID} PeerAndProfileWithID
     */
    PeerAndProfileWithID.fromObject = function fromObject(object) {
        if (object instanceof $root.PeerAndProfileWithID)
            return object;
        var message = new $root.PeerAndProfileWithID();
        if (object.id != null)
            message.id = String(object.id);
        if (object.peerId != null)
            message.peerId = String(object.peerId);
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".PeerAndProfileWithID.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a PeerAndProfileWithID message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PeerAndProfileWithID
     * @static
     * @param {PeerAndProfileWithID} message PeerAndProfileWithID
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PeerAndProfileWithID.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = "";
            object.peerId = "";
            object.profile = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            object.peerId = message.peerId;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this PeerAndProfileWithID to JSON.
     * @function toJSON
     * @memberof PeerAndProfileWithID
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PeerAndProfileWithID.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PeerAndProfileWithID;
})();

$root.RatingWithID = (function() {

    /**
     * Properties of a RatingWithID.
     * @exports IRatingWithID
     * @interface IRatingWithID
     * @property {string|null} [id] RatingWithID id
     * @property {string|null} [ratingId] The unique Rating ID.
     * @property {IRating|null} [rating] RatingWithID rating
     */

    /**
     * Constructs a new RatingWithID.
     * @exports RatingWithID
     * @classdesc Represents a RatingWithID.
     * @implements IRatingWithID
     * @constructor
     * @param {IRatingWithID=} [properties] Properties to set
     */
    function RatingWithID(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RatingWithID id.
     * @member {string} id
     * @memberof RatingWithID
     * @instance
     */
    RatingWithID.prototype.id = "";

    /**
     * The unique Rating ID.
     * @member {string} ratingId
     * @memberof RatingWithID
     * @instance
     */
    RatingWithID.prototype.ratingId = "";

    /**
     * RatingWithID rating.
     * @member {IRating|null|undefined} rating
     * @memberof RatingWithID
     * @instance
     */
    RatingWithID.prototype.rating = null;

    /**
     * Creates a new RatingWithID instance using the specified properties.
     * @function create
     * @memberof RatingWithID
     * @static
     * @param {IRatingWithID=} [properties] Properties to set
     * @returns {RatingWithID} RatingWithID instance
     */
    RatingWithID.create = function create(properties) {
        return new RatingWithID(properties);
    };

    /**
     * Encodes the specified RatingWithID message. Does not implicitly {@link RatingWithID.verify|verify} messages.
     * @function encode
     * @memberof RatingWithID
     * @static
     * @param {IRatingWithID} message RatingWithID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RatingWithID.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
        if (message.ratingId != null && message.hasOwnProperty("ratingId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.ratingId);
        if (message.rating != null && message.hasOwnProperty("rating"))
            $root.Rating.encode(message.rating, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RatingWithID message, length delimited. Does not implicitly {@link RatingWithID.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RatingWithID
     * @static
     * @param {IRatingWithID} message RatingWithID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RatingWithID.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RatingWithID message from the specified reader or buffer.
     * @function decode
     * @memberof RatingWithID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RatingWithID} RatingWithID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RatingWithID.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RatingWithID();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.string();
                break;
            case 2:
                message.ratingId = reader.string();
                break;
            case 3:
                message.rating = $root.Rating.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RatingWithID message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RatingWithID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RatingWithID} RatingWithID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RatingWithID.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RatingWithID message.
     * @function verify
     * @memberof RatingWithID
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RatingWithID.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        if (message.ratingId != null && message.hasOwnProperty("ratingId"))
            if (!$util.isString(message.ratingId))
                return "ratingId: string expected";
        if (message.rating != null && message.hasOwnProperty("rating")) {
            var error = $root.Rating.verify(message.rating);
            if (error)
                return "rating." + error;
        }
        return null;
    };

    /**
     * Creates a RatingWithID message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RatingWithID
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RatingWithID} RatingWithID
     */
    RatingWithID.fromObject = function fromObject(object) {
        if (object instanceof $root.RatingWithID)
            return object;
        var message = new $root.RatingWithID();
        if (object.id != null)
            message.id = String(object.id);
        if (object.ratingId != null)
            message.ratingId = String(object.ratingId);
        if (object.rating != null) {
            if (typeof object.rating !== "object")
                throw TypeError(".RatingWithID.rating: object expected");
            message.rating = $root.Rating.fromObject(object.rating);
        }
        return message;
    };

    /**
     * Creates a plain object from a RatingWithID message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RatingWithID
     * @static
     * @param {RatingWithID} message RatingWithID
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RatingWithID.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = "";
            object.ratingId = "";
            object.rating = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.ratingId != null && message.hasOwnProperty("ratingId"))
            object.ratingId = message.ratingId;
        if (message.rating != null && message.hasOwnProperty("rating"))
            object.rating = $root.Rating.toObject(message.rating, options);
        return object;
    };

    /**
     * Converts this RatingWithID to JSON.
     * @function toJSON
     * @memberof RatingWithID
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RatingWithID.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RatingWithID;
})();

$root.OrderService = (function() {

    /**
     * Constructs a new OrderService service.
     * @exports OrderService
     * @classdesc Represents an OrderService
     * @extends $protobuf.rpc.Service
     * @constructor
     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
     */
    function OrderService(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
    }

    (OrderService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = OrderService;

    /**
     * Creates new OrderService service using the specified rpc implementation.
     * @function create
     * @memberof OrderService
     * @static
     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
     * @returns {OrderService} RPC service. Useful where requests and/or responses are streamed.
     */
    OrderService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
        return new this(rpcImpl, requestDelimited, responseDelimited);
    };

    /**
     * Callback as used by {@link OrderService#listCases}.
     * @memberof OrderService
     * @typedef ListCasesCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {Order} [response] Order
     */

    /**
     * Returns a list of all moderation cases that the node was involved in.
     * @function listCases
     * @memberof OrderService
     * @instance
     * @param {IPageRequestType} request PageRequestType message or plain object
     * @param {OrderService.ListCasesCallback} callback Node-style callback called with the error, if any, and Order
     * @returns {undefined}
     * @variation 1
     */
    OrderService.prototype.listCases = function listCases(request, callback) {
        return this.rpcCall(listCases, $root.PageRequestType, $root.Order, request, callback);
    };

    /**
     * Returns a list of all moderation cases that the node was involved in.
     * @function listCases
     * @memberof OrderService
     * @instance
     * @param {IPageRequestType} request PageRequestType message or plain object
     * @returns {Promise<Order>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link OrderService#listSales}.
     * @memberof OrderService
     * @typedef ListSalesCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {Order} [response] Order
     */

    /**
     * Returns a list of all sales that the node has made.
     * @function listSales
     * @memberof OrderService
     * @instance
     * @param {IPageRequestType} request PageRequestType message or plain object
     * @param {OrderService.ListSalesCallback} callback Node-style callback called with the error, if any, and Order
     * @returns {undefined}
     * @variation 1
     */
    OrderService.prototype.listSales = function listSales(request, callback) {
        return this.rpcCall(listSales, $root.PageRequestType, $root.Order, request, callback);
    };

    /**
     * Returns a list of all sales that the node has made.
     * @function listSales
     * @memberof OrderService
     * @instance
     * @param {IPageRequestType} request PageRequestType message or plain object
     * @returns {Promise<Order>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link OrderService#listPurchases}.
     * @memberof OrderService
     * @typedef ListPurchasesCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {Order} [response] Order
     */

    /**
     * Returns a list of all purchases that the node has made.
     * @function listPurchases
     * @memberof OrderService
     * @instance
     * @param {IPageRequestType} request PageRequestType message or plain object
     * @param {OrderService.ListPurchasesCallback} callback Node-style callback called with the error, if any, and Order
     * @returns {undefined}
     * @variation 1
     */
    OrderService.prototype.listPurchases = function listPurchases(request, callback) {
        return this.rpcCall(listPurchases, $root.PageRequestType, $root.Order, request, callback);
    };

    /**
     * Returns a list of all purchases that the node has made.
     * @function listPurchases
     * @memberof OrderService
     * @instance
     * @param {IPageRequestType} request PageRequestType message or plain object
     * @returns {Promise<Order>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link OrderService#getQuote}.
     * @memberof OrderService
     * @typedef GetQuoteCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {OrderResponseType} [response] OrderResponseType
     */

    /**
     * Get an order by ID
     * @function getQuote
     * @memberof OrderService
     * @instance
     * @param {IOrderRequestType} request OrderRequestType message or plain object
     * @param {OrderService.GetQuoteCallback} callback Node-style callback called with the error, if any, and OrderResponseType
     * @returns {undefined}
     * @variation 1
     */
    OrderService.prototype.getQuote = function getQuote(request, callback) {
        return this.rpcCall(getQuote, $root.OrderRequestType, $root.OrderResponseType, request, callback);
    };

    /**
     * Get an order by ID
     * @function getQuote
     * @memberof OrderService
     * @instance
     * @param {IOrderRequestType} request OrderRequestType message or plain object
     * @returns {Promise<OrderResponseType>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link OrderService#purchase}.
     * @memberof OrderService
     * @typedef PurchaseCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {OrderResponseType} [response] OrderResponseType
     */

    /**
     * The purchase call can be made to a reachable or a unreachable vendor
     * (offline or not able to receive incoming messages).
     * An order will be created in the AWAITING_PAYMENT state after this call.
     * If the total of the purchase is not more than 4X the current transaction fee, the purchase will be rejected
     * (ie: if the fee is 0.0001, the total purchase must be more than 0.0004).
     * @function purchase
     * @memberof OrderService
     * @instance
     * @param {IOrderRequestType} request OrderRequestType message or plain object
     * @param {OrderService.PurchaseCallback} callback Node-style callback called with the error, if any, and OrderResponseType
     * @returns {undefined}
     * @variation 1
     */
    OrderService.prototype.purchase = function purchase(request, callback) {
        return this.rpcCall(purchase, $root.OrderRequestType, $root.OrderResponseType, request, callback);
    };

    /**
     * The purchase call can be made to a reachable or a unreachable vendor
     * (offline or not able to receive incoming messages).
     * An order will be created in the AWAITING_PAYMENT state after this call.
     * If the total of the purchase is not more than 4X the current transaction fee, the purchase will be rejected
     * (ie: if the fee is 0.0001, the total purchase must be more than 0.0004).
     * @function purchase
     * @memberof OrderService
     * @instance
     * @param {IOrderRequestType} request OrderRequestType message or plain object
     * @returns {Promise<OrderResponseType>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link OrderService#confirm}.
     * @memberof OrderService
     * @typedef ConfirmCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {OrderResponseType} [response] OrderResponseType
     */

    /**
     * Online orders are confirmed instantly. This API call is to confirm an order sent to the vendor
     * while he was offline.
     * @function confirm
     * @memberof OrderService
     * @instance
     * @param {IOrderCompleteRequestType} request OrderCompleteRequestType message or plain object
     * @param {OrderService.ConfirmCallback} callback Node-style callback called with the error, if any, and OrderResponseType
     * @returns {undefined}
     * @variation 1
     */
    OrderService.prototype.confirm = function confirm(request, callback) {
        return this.rpcCall(confirm, $root.OrderCompleteRequestType, $root.OrderResponseType, request, callback);
    };

    /**
     * Online orders are confirmed instantly. This API call is to confirm an order sent to the vendor
     * while he was offline.
     * @function confirm
     * @memberof OrderService
     * @instance
     * @param {IOrderCompleteRequestType} request OrderCompleteRequestType message or plain object
     * @returns {Promise<OrderResponseType>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link OrderService#complete}.
     * @memberof OrderService
     * @typedef CompleteCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {OrderResponseType} [response] OrderResponseType
     */

    /**
     * Send the order complete message (including the rating) to the vendor. If this is a moderated order, it will
     * sign and release the funds to the vendor.
     * @function complete
     * @memberof OrderService
     * @instance
     * @param {IOrderCompleteRequestType} request OrderCompleteRequestType message or plain object
     * @param {OrderService.CompleteCallback} callback Node-style callback called with the error, if any, and OrderResponseType
     * @returns {undefined}
     * @variation 1
     */
    OrderService.prototype.complete = function complete(request, callback) {
        return this.rpcCall(complete, $root.OrderCompleteRequestType, $root.OrderResponseType, request, callback);
    };

    /**
     * Send the order complete message (including the rating) to the vendor. If this is a moderated order, it will
     * sign and release the funds to the vendor.
     * @function complete
     * @memberof OrderService
     * @instance
     * @param {IOrderCompleteRequestType} request OrderCompleteRequestType message or plain object
     * @returns {Promise<OrderResponseType>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link OrderService#refundOrder}.
     * @memberof OrderService
     * @typedef RefundOrderCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {OrderResponseType} [response] OrderResponseType
     */

    /**
     * Refund the order. If it's a moderated order, it will release the funds back to the buyer.
     * If it's direct it will send the coins from your wallet.
     * @function refundOrder
     * @memberof OrderService
     * @instance
     * @param {IOrderRequestType} request OrderRequestType message or plain object
     * @param {OrderService.RefundOrderCallback} callback Node-style callback called with the error, if any, and OrderResponseType
     * @returns {undefined}
     * @variation 1
     */
    OrderService.prototype.refundOrder = function refundOrder(request, callback) {
        return this.rpcCall(refundOrder, $root.OrderRequestType, $root.OrderResponseType, request, callback);
    };

    /**
     * Refund the order. If it's a moderated order, it will release the funds back to the buyer.
     * If it's direct it will send the coins from your wallet.
     * @function refundOrder
     * @memberof OrderService
     * @instance
     * @param {IOrderRequestType} request OrderRequestType message or plain object
     * @returns {Promise<OrderResponseType>} Promise
     * @variation 2
     */

    /**
     * Callback as used by {@link OrderService#cancelOrder}.
     * @memberof OrderService
     * @typedef CancelOrderCallback
     * @type {function}
     * @param {Error|null} error Error, if any
     * @param {OrderResponseType} [response] OrderResponseType
     */

    /**
     * Cancel an outstanding offline order. It will move the bitcoins back into your wallet.
     * @function cancelOrder
     * @memberof OrderService
     * @instance
     * @param {IOrderRequestType} request OrderRequestType message or plain object
     * @param {OrderService.CancelOrderCallback} callback Node-style callback called with the error, if any, and OrderResponseType
     * @returns {undefined}
     * @variation 1
     */
    OrderService.prototype.cancelOrder = function cancelOrder(request, callback) {
        return this.rpcCall(cancelOrder, $root.OrderRequestType, $root.OrderResponseType, request, callback);
    };

    /**
     * Cancel an outstanding offline order. It will move the bitcoins back into your wallet.
     * @function cancelOrder
     * @memberof OrderService
     * @instance
     * @param {IOrderRequestType} request OrderRequestType message or plain object
     * @returns {Promise<OrderResponseType>} Promise
     * @variation 2
     */

    return OrderService;
})();

$root.OrderResponseType = (function() {

    /**
     * Properties of an OrderResponseType.
     * @exports IOrderResponseType
     * @interface IOrderResponseType
     * @property {IOrder|null} [order] OrderResponseType order
     */

    /**
     * Constructs a new OrderResponseType.
     * @exports OrderResponseType
     * @classdesc Represents an OrderResponseType.
     * @implements IOrderResponseType
     * @constructor
     * @param {IOrderResponseType=} [properties] Properties to set
     */
    function OrderResponseType(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OrderResponseType order.
     * @member {IOrder|null|undefined} order
     * @memberof OrderResponseType
     * @instance
     */
    OrderResponseType.prototype.order = null;

    /**
     * Creates a new OrderResponseType instance using the specified properties.
     * @function create
     * @memberof OrderResponseType
     * @static
     * @param {IOrderResponseType=} [properties] Properties to set
     * @returns {OrderResponseType} OrderResponseType instance
     */
    OrderResponseType.create = function create(properties) {
        return new OrderResponseType(properties);
    };

    /**
     * Encodes the specified OrderResponseType message. Does not implicitly {@link OrderResponseType.verify|verify} messages.
     * @function encode
     * @memberof OrderResponseType
     * @static
     * @param {IOrderResponseType} message OrderResponseType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderResponseType.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.order != null && message.hasOwnProperty("order"))
            $root.Order.encode(message.order, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OrderResponseType message, length delimited. Does not implicitly {@link OrderResponseType.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OrderResponseType
     * @static
     * @param {IOrderResponseType} message OrderResponseType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderResponseType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OrderResponseType message from the specified reader or buffer.
     * @function decode
     * @memberof OrderResponseType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OrderResponseType} OrderResponseType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderResponseType.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderResponseType();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.order = $root.Order.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OrderResponseType message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OrderResponseType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OrderResponseType} OrderResponseType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderResponseType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OrderResponseType message.
     * @function verify
     * @memberof OrderResponseType
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OrderResponseType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.order != null && message.hasOwnProperty("order")) {
            var error = $root.Order.verify(message.order);
            if (error)
                return "order." + error;
        }
        return null;
    };

    /**
     * Creates an OrderResponseType message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OrderResponseType
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OrderResponseType} OrderResponseType
     */
    OrderResponseType.fromObject = function fromObject(object) {
        if (object instanceof $root.OrderResponseType)
            return object;
        var message = new $root.OrderResponseType();
        if (object.order != null) {
            if (typeof object.order !== "object")
                throw TypeError(".OrderResponseType.order: object expected");
            message.order = $root.Order.fromObject(object.order);
        }
        return message;
    };

    /**
     * Creates a plain object from an OrderResponseType message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OrderResponseType
     * @static
     * @param {OrderResponseType} message OrderResponseType
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OrderResponseType.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.order = null;
        if (message.order != null && message.hasOwnProperty("order"))
            object.order = $root.Order.toObject(message.order, options);
        return object;
    };

    /**
     * Converts this OrderResponseType to JSON.
     * @function toJSON
     * @memberof OrderResponseType
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OrderResponseType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OrderResponseType;
})();

$root.RatingStub = (function() {

    /**
     * Properties of a RatingStub.
     * @exports IRatingStub
     * @interface IRatingStub
     * @property {string|null} [slug] RatingStub slug
     * @property {number|null} [overall] RatingStub overall
     * @property {number|null} [quality] RatingStub quality
     * @property {number|null} [description] RatingStub description
     * @property {number|null} [deliverySpeed] RatingStub deliverySpeed
     * @property {number|null} [customerService] RatingStub customerService
     * @property {string|null} [review] RatingStub review
     * @property {boolean|null} [anonymous] RatingStub anonymous
     */

    /**
     * Constructs a new RatingStub.
     * @exports RatingStub
     * @classdesc Represents a RatingStub.
     * @implements IRatingStub
     * @constructor
     * @param {IRatingStub=} [properties] Properties to set
     */
    function RatingStub(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RatingStub slug.
     * @member {string} slug
     * @memberof RatingStub
     * @instance
     */
    RatingStub.prototype.slug = "";

    /**
     * RatingStub overall.
     * @member {number} overall
     * @memberof RatingStub
     * @instance
     */
    RatingStub.prototype.overall = 0;

    /**
     * RatingStub quality.
     * @member {number} quality
     * @memberof RatingStub
     * @instance
     */
    RatingStub.prototype.quality = 0;

    /**
     * RatingStub description.
     * @member {number} description
     * @memberof RatingStub
     * @instance
     */
    RatingStub.prototype.description = 0;

    /**
     * RatingStub deliverySpeed.
     * @member {number} deliverySpeed
     * @memberof RatingStub
     * @instance
     */
    RatingStub.prototype.deliverySpeed = 0;

    /**
     * RatingStub customerService.
     * @member {number} customerService
     * @memberof RatingStub
     * @instance
     */
    RatingStub.prototype.customerService = 0;

    /**
     * RatingStub review.
     * @member {string} review
     * @memberof RatingStub
     * @instance
     */
    RatingStub.prototype.review = "";

    /**
     * RatingStub anonymous.
     * @member {boolean} anonymous
     * @memberof RatingStub
     * @instance
     */
    RatingStub.prototype.anonymous = false;

    /**
     * Creates a new RatingStub instance using the specified properties.
     * @function create
     * @memberof RatingStub
     * @static
     * @param {IRatingStub=} [properties] Properties to set
     * @returns {RatingStub} RatingStub instance
     */
    RatingStub.create = function create(properties) {
        return new RatingStub(properties);
    };

    /**
     * Encodes the specified RatingStub message. Does not implicitly {@link RatingStub.verify|verify} messages.
     * @function encode
     * @memberof RatingStub
     * @static
     * @param {IRatingStub} message RatingStub message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RatingStub.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.slug != null && message.hasOwnProperty("slug"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.slug);
        if (message.overall != null && message.hasOwnProperty("overall"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.overall);
        if (message.quality != null && message.hasOwnProperty("quality"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.quality);
        if (message.description != null && message.hasOwnProperty("description"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.description);
        if (message.deliverySpeed != null && message.hasOwnProperty("deliverySpeed"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.deliverySpeed);
        if (message.customerService != null && message.hasOwnProperty("customerService"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.customerService);
        if (message.review != null && message.hasOwnProperty("review"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.review);
        if (message.anonymous != null && message.hasOwnProperty("anonymous"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.anonymous);
        return writer;
    };

    /**
     * Encodes the specified RatingStub message, length delimited. Does not implicitly {@link RatingStub.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RatingStub
     * @static
     * @param {IRatingStub} message RatingStub message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RatingStub.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RatingStub message from the specified reader or buffer.
     * @function decode
     * @memberof RatingStub
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RatingStub} RatingStub
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RatingStub.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RatingStub();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.slug = reader.string();
                break;
            case 2:
                message.overall = reader.uint32();
                break;
            case 3:
                message.quality = reader.uint32();
                break;
            case 4:
                message.description = reader.uint32();
                break;
            case 5:
                message.deliverySpeed = reader.uint32();
                break;
            case 6:
                message.customerService = reader.uint32();
                break;
            case 7:
                message.review = reader.string();
                break;
            case 8:
                message.anonymous = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RatingStub message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RatingStub
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RatingStub} RatingStub
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RatingStub.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RatingStub message.
     * @function verify
     * @memberof RatingStub
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RatingStub.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.slug != null && message.hasOwnProperty("slug"))
            if (!$util.isString(message.slug))
                return "slug: string expected";
        if (message.overall != null && message.hasOwnProperty("overall"))
            if (!$util.isInteger(message.overall))
                return "overall: integer expected";
        if (message.quality != null && message.hasOwnProperty("quality"))
            if (!$util.isInteger(message.quality))
                return "quality: integer expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isInteger(message.description))
                return "description: integer expected";
        if (message.deliverySpeed != null && message.hasOwnProperty("deliverySpeed"))
            if (!$util.isInteger(message.deliverySpeed))
                return "deliverySpeed: integer expected";
        if (message.customerService != null && message.hasOwnProperty("customerService"))
            if (!$util.isInteger(message.customerService))
                return "customerService: integer expected";
        if (message.review != null && message.hasOwnProperty("review"))
            if (!$util.isString(message.review))
                return "review: string expected";
        if (message.anonymous != null && message.hasOwnProperty("anonymous"))
            if (typeof message.anonymous !== "boolean")
                return "anonymous: boolean expected";
        return null;
    };

    /**
     * Creates a RatingStub message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RatingStub
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RatingStub} RatingStub
     */
    RatingStub.fromObject = function fromObject(object) {
        if (object instanceof $root.RatingStub)
            return object;
        var message = new $root.RatingStub();
        if (object.slug != null)
            message.slug = String(object.slug);
        if (object.overall != null)
            message.overall = object.overall >>> 0;
        if (object.quality != null)
            message.quality = object.quality >>> 0;
        if (object.description != null)
            message.description = object.description >>> 0;
        if (object.deliverySpeed != null)
            message.deliverySpeed = object.deliverySpeed >>> 0;
        if (object.customerService != null)
            message.customerService = object.customerService >>> 0;
        if (object.review != null)
            message.review = String(object.review);
        if (object.anonymous != null)
            message.anonymous = Boolean(object.anonymous);
        return message;
    };

    /**
     * Creates a plain object from a RatingStub message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RatingStub
     * @static
     * @param {RatingStub} message RatingStub
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RatingStub.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.slug = "";
            object.overall = 0;
            object.quality = 0;
            object.description = 0;
            object.deliverySpeed = 0;
            object.customerService = 0;
            object.review = "";
            object.anonymous = false;
        }
        if (message.slug != null && message.hasOwnProperty("slug"))
            object.slug = message.slug;
        if (message.overall != null && message.hasOwnProperty("overall"))
            object.overall = message.overall;
        if (message.quality != null && message.hasOwnProperty("quality"))
            object.quality = message.quality;
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.deliverySpeed != null && message.hasOwnProperty("deliverySpeed"))
            object.deliverySpeed = message.deliverySpeed;
        if (message.customerService != null && message.hasOwnProperty("customerService"))
            object.customerService = message.customerService;
        if (message.review != null && message.hasOwnProperty("review"))
            object.review = message.review;
        if (message.anonymous != null && message.hasOwnProperty("anonymous"))
            object.anonymous = message.anonymous;
        return object;
    };

    /**
     * Converts this RatingStub to JSON.
     * @function toJSON
     * @memberof RatingStub
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RatingStub.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RatingStub;
})();

$root.OrderCompleteRequestType = (function() {

    /**
     * Properties of an OrderCompleteRequestType.
     * @exports IOrderCompleteRequestType
     * @interface IOrderCompleteRequestType
     * @property {string|null} [orderId] OrderCompleteRequestType orderId
     * @property {Array.<IRatingStub>|null} [ratings] OrderCompleteRequestType ratings
     */

    /**
     * Constructs a new OrderCompleteRequestType.
     * @exports OrderCompleteRequestType
     * @classdesc Represents an OrderCompleteRequestType.
     * @implements IOrderCompleteRequestType
     * @constructor
     * @param {IOrderCompleteRequestType=} [properties] Properties to set
     */
    function OrderCompleteRequestType(properties) {
        this.ratings = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OrderCompleteRequestType orderId.
     * @member {string} orderId
     * @memberof OrderCompleteRequestType
     * @instance
     */
    OrderCompleteRequestType.prototype.orderId = "";

    /**
     * OrderCompleteRequestType ratings.
     * @member {Array.<IRatingStub>} ratings
     * @memberof OrderCompleteRequestType
     * @instance
     */
    OrderCompleteRequestType.prototype.ratings = $util.emptyArray;

    /**
     * Creates a new OrderCompleteRequestType instance using the specified properties.
     * @function create
     * @memberof OrderCompleteRequestType
     * @static
     * @param {IOrderCompleteRequestType=} [properties] Properties to set
     * @returns {OrderCompleteRequestType} OrderCompleteRequestType instance
     */
    OrderCompleteRequestType.create = function create(properties) {
        return new OrderCompleteRequestType(properties);
    };

    /**
     * Encodes the specified OrderCompleteRequestType message. Does not implicitly {@link OrderCompleteRequestType.verify|verify} messages.
     * @function encode
     * @memberof OrderCompleteRequestType
     * @static
     * @param {IOrderCompleteRequestType} message OrderCompleteRequestType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderCompleteRequestType.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderId);
        if (message.ratings != null && message.ratings.length)
            for (var i = 0; i < message.ratings.length; ++i)
                $root.RatingStub.encode(message.ratings[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OrderCompleteRequestType message, length delimited. Does not implicitly {@link OrderCompleteRequestType.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OrderCompleteRequestType
     * @static
     * @param {IOrderCompleteRequestType} message OrderCompleteRequestType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderCompleteRequestType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OrderCompleteRequestType message from the specified reader or buffer.
     * @function decode
     * @memberof OrderCompleteRequestType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OrderCompleteRequestType} OrderCompleteRequestType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderCompleteRequestType.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderCompleteRequestType();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.orderId = reader.string();
                break;
            case 2:
                if (!(message.ratings && message.ratings.length))
                    message.ratings = [];
                message.ratings.push($root.RatingStub.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OrderCompleteRequestType message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OrderCompleteRequestType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OrderCompleteRequestType} OrderCompleteRequestType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderCompleteRequestType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OrderCompleteRequestType message.
     * @function verify
     * @memberof OrderCompleteRequestType
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OrderCompleteRequestType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            if (!$util.isString(message.orderId))
                return "orderId: string expected";
        if (message.ratings != null && message.hasOwnProperty("ratings")) {
            if (!Array.isArray(message.ratings))
                return "ratings: array expected";
            for (var i = 0; i < message.ratings.length; ++i) {
                var error = $root.RatingStub.verify(message.ratings[i]);
                if (error)
                    return "ratings." + error;
            }
        }
        return null;
    };

    /**
     * Creates an OrderCompleteRequestType message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OrderCompleteRequestType
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OrderCompleteRequestType} OrderCompleteRequestType
     */
    OrderCompleteRequestType.fromObject = function fromObject(object) {
        if (object instanceof $root.OrderCompleteRequestType)
            return object;
        var message = new $root.OrderCompleteRequestType();
        if (object.orderId != null)
            message.orderId = String(object.orderId);
        if (object.ratings) {
            if (!Array.isArray(object.ratings))
                throw TypeError(".OrderCompleteRequestType.ratings: array expected");
            message.ratings = [];
            for (var i = 0; i < object.ratings.length; ++i) {
                if (typeof object.ratings[i] !== "object")
                    throw TypeError(".OrderCompleteRequestType.ratings: object expected");
                message.ratings[i] = $root.RatingStub.fromObject(object.ratings[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an OrderCompleteRequestType message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OrderCompleteRequestType
     * @static
     * @param {OrderCompleteRequestType} message OrderCompleteRequestType
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OrderCompleteRequestType.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.ratings = [];
        if (options.defaults)
            object.orderId = "";
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            object.orderId = message.orderId;
        if (message.ratings && message.ratings.length) {
            object.ratings = [];
            for (var j = 0; j < message.ratings.length; ++j)
                object.ratings[j] = $root.RatingStub.toObject(message.ratings[j], options);
        }
        return object;
    };

    /**
     * Converts this OrderCompleteRequestType to JSON.
     * @function toJSON
     * @memberof OrderCompleteRequestType
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OrderCompleteRequestType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OrderCompleteRequestType;
})();

$root.OrderRequestType = (function() {

    /**
     * Properties of an OrderRequestType.
     * @exports IOrderRequestType
     * @interface IOrderRequestType
     * @property {string|null} [orderId] OrderRequestType orderId
     */

    /**
     * Constructs a new OrderRequestType.
     * @exports OrderRequestType
     * @classdesc Represents an OrderRequestType.
     * @implements IOrderRequestType
     * @constructor
     * @param {IOrderRequestType=} [properties] Properties to set
     */
    function OrderRequestType(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OrderRequestType orderId.
     * @member {string} orderId
     * @memberof OrderRequestType
     * @instance
     */
    OrderRequestType.prototype.orderId = "";

    /**
     * Creates a new OrderRequestType instance using the specified properties.
     * @function create
     * @memberof OrderRequestType
     * @static
     * @param {IOrderRequestType=} [properties] Properties to set
     * @returns {OrderRequestType} OrderRequestType instance
     */
    OrderRequestType.create = function create(properties) {
        return new OrderRequestType(properties);
    };

    /**
     * Encodes the specified OrderRequestType message. Does not implicitly {@link OrderRequestType.verify|verify} messages.
     * @function encode
     * @memberof OrderRequestType
     * @static
     * @param {IOrderRequestType} message OrderRequestType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderRequestType.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderId);
        return writer;
    };

    /**
     * Encodes the specified OrderRequestType message, length delimited. Does not implicitly {@link OrderRequestType.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OrderRequestType
     * @static
     * @param {IOrderRequestType} message OrderRequestType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderRequestType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OrderRequestType message from the specified reader or buffer.
     * @function decode
     * @memberof OrderRequestType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OrderRequestType} OrderRequestType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderRequestType.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderRequestType();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.orderId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OrderRequestType message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OrderRequestType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OrderRequestType} OrderRequestType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderRequestType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OrderRequestType message.
     * @function verify
     * @memberof OrderRequestType
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OrderRequestType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            if (!$util.isString(message.orderId))
                return "orderId: string expected";
        return null;
    };

    /**
     * Creates an OrderRequestType message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OrderRequestType
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OrderRequestType} OrderRequestType
     */
    OrderRequestType.fromObject = function fromObject(object) {
        if (object instanceof $root.OrderRequestType)
            return object;
        var message = new $root.OrderRequestType();
        if (object.orderId != null)
            message.orderId = String(object.orderId);
        return message;
    };

    /**
     * Creates a plain object from an OrderRequestType message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OrderRequestType
     * @static
     * @param {OrderRequestType} message OrderRequestType
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OrderRequestType.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.orderId = "";
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            object.orderId = message.orderId;
        return object;
    };

    /**
     * Converts this OrderRequestType to JSON.
     * @function toJSON
     * @memberof OrderRequestType
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OrderRequestType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OrderRequestType;
})();

$root.OrderConfirmRequestType = (function() {

    /**
     * Properties of an OrderConfirmRequestType.
     * @exports IOrderConfirmRequestType
     * @interface IOrderConfirmRequestType
     * @property {string|null} [orderId] OrderConfirmRequestType orderId
     * @property {boolean|null} [reject] OrderConfirmRequestType reject
     */

    /**
     * Constructs a new OrderConfirmRequestType.
     * @exports OrderConfirmRequestType
     * @classdesc Represents an OrderConfirmRequestType.
     * @implements IOrderConfirmRequestType
     * @constructor
     * @param {IOrderConfirmRequestType=} [properties] Properties to set
     */
    function OrderConfirmRequestType(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OrderConfirmRequestType orderId.
     * @member {string} orderId
     * @memberof OrderConfirmRequestType
     * @instance
     */
    OrderConfirmRequestType.prototype.orderId = "";

    /**
     * OrderConfirmRequestType reject.
     * @member {boolean} reject
     * @memberof OrderConfirmRequestType
     * @instance
     */
    OrderConfirmRequestType.prototype.reject = false;

    /**
     * Creates a new OrderConfirmRequestType instance using the specified properties.
     * @function create
     * @memberof OrderConfirmRequestType
     * @static
     * @param {IOrderConfirmRequestType=} [properties] Properties to set
     * @returns {OrderConfirmRequestType} OrderConfirmRequestType instance
     */
    OrderConfirmRequestType.create = function create(properties) {
        return new OrderConfirmRequestType(properties);
    };

    /**
     * Encodes the specified OrderConfirmRequestType message. Does not implicitly {@link OrderConfirmRequestType.verify|verify} messages.
     * @function encode
     * @memberof OrderConfirmRequestType
     * @static
     * @param {IOrderConfirmRequestType} message OrderConfirmRequestType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderConfirmRequestType.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderId);
        if (message.reject != null && message.hasOwnProperty("reject"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.reject);
        return writer;
    };

    /**
     * Encodes the specified OrderConfirmRequestType message, length delimited. Does not implicitly {@link OrderConfirmRequestType.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OrderConfirmRequestType
     * @static
     * @param {IOrderConfirmRequestType} message OrderConfirmRequestType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderConfirmRequestType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OrderConfirmRequestType message from the specified reader or buffer.
     * @function decode
     * @memberof OrderConfirmRequestType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OrderConfirmRequestType} OrderConfirmRequestType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderConfirmRequestType.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderConfirmRequestType();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.orderId = reader.string();
                break;
            case 2:
                message.reject = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OrderConfirmRequestType message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OrderConfirmRequestType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OrderConfirmRequestType} OrderConfirmRequestType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderConfirmRequestType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OrderConfirmRequestType message.
     * @function verify
     * @memberof OrderConfirmRequestType
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OrderConfirmRequestType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            if (!$util.isString(message.orderId))
                return "orderId: string expected";
        if (message.reject != null && message.hasOwnProperty("reject"))
            if (typeof message.reject !== "boolean")
                return "reject: boolean expected";
        return null;
    };

    /**
     * Creates an OrderConfirmRequestType message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OrderConfirmRequestType
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OrderConfirmRequestType} OrderConfirmRequestType
     */
    OrderConfirmRequestType.fromObject = function fromObject(object) {
        if (object instanceof $root.OrderConfirmRequestType)
            return object;
        var message = new $root.OrderConfirmRequestType();
        if (object.orderId != null)
            message.orderId = String(object.orderId);
        if (object.reject != null)
            message.reject = Boolean(object.reject);
        return message;
    };

    /**
     * Creates a plain object from an OrderConfirmRequestType message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OrderConfirmRequestType
     * @static
     * @param {OrderConfirmRequestType} message OrderConfirmRequestType
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OrderConfirmRequestType.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.orderId = "";
            object.reject = false;
        }
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            object.orderId = message.orderId;
        if (message.reject != null && message.hasOwnProperty("reject"))
            object.reject = message.reject;
        return object;
    };

    /**
     * Converts this OrderConfirmRequestType to JSON.
     * @function toJSON
     * @memberof OrderConfirmRequestType
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OrderConfirmRequestType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OrderConfirmRequestType;
})();

$root.PageRequestType = (function() {

    /**
     * Properties of a PageRequestType.
     * @exports IPageRequestType
     * @interface IPageRequestType
     * @property {number|null} [limit] PageRequestType limit
     * @property {number|null} [offset] PageRequestType offset
     */

    /**
     * Constructs a new PageRequestType.
     * @exports PageRequestType
     * @classdesc Represents a PageRequestType.
     * @implements IPageRequestType
     * @constructor
     * @param {IPageRequestType=} [properties] Properties to set
     */
    function PageRequestType(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PageRequestType limit.
     * @member {number} limit
     * @memberof PageRequestType
     * @instance
     */
    PageRequestType.prototype.limit = 0;

    /**
     * PageRequestType offset.
     * @member {number} offset
     * @memberof PageRequestType
     * @instance
     */
    PageRequestType.prototype.offset = 0;

    /**
     * Creates a new PageRequestType instance using the specified properties.
     * @function create
     * @memberof PageRequestType
     * @static
     * @param {IPageRequestType=} [properties] Properties to set
     * @returns {PageRequestType} PageRequestType instance
     */
    PageRequestType.create = function create(properties) {
        return new PageRequestType(properties);
    };

    /**
     * Encodes the specified PageRequestType message. Does not implicitly {@link PageRequestType.verify|verify} messages.
     * @function encode
     * @memberof PageRequestType
     * @static
     * @param {IPageRequestType} message PageRequestType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PageRequestType.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.limit != null && message.hasOwnProperty("limit"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.limit);
        if (message.offset != null && message.hasOwnProperty("offset"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.offset);
        return writer;
    };

    /**
     * Encodes the specified PageRequestType message, length delimited. Does not implicitly {@link PageRequestType.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PageRequestType
     * @static
     * @param {IPageRequestType} message PageRequestType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PageRequestType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PageRequestType message from the specified reader or buffer.
     * @function decode
     * @memberof PageRequestType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PageRequestType} PageRequestType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PageRequestType.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PageRequestType();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.limit = reader.int32();
                break;
            case 2:
                message.offset = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PageRequestType message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PageRequestType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PageRequestType} PageRequestType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PageRequestType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PageRequestType message.
     * @function verify
     * @memberof PageRequestType
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PageRequestType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.limit != null && message.hasOwnProperty("limit"))
            if (!$util.isInteger(message.limit))
                return "limit: integer expected";
        if (message.offset != null && message.hasOwnProperty("offset"))
            if (!$util.isInteger(message.offset))
                return "offset: integer expected";
        return null;
    };

    /**
     * Creates a PageRequestType message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PageRequestType
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PageRequestType} PageRequestType
     */
    PageRequestType.fromObject = function fromObject(object) {
        if (object instanceof $root.PageRequestType)
            return object;
        var message = new $root.PageRequestType();
        if (object.limit != null)
            message.limit = object.limit | 0;
        if (object.offset != null)
            message.offset = object.offset | 0;
        return message;
    };

    /**
     * Creates a plain object from a PageRequestType message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PageRequestType
     * @static
     * @param {PageRequestType} message PageRequestType
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PageRequestType.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.limit = 0;
            object.offset = 0;
        }
        if (message.limit != null && message.hasOwnProperty("limit"))
            object.limit = message.limit;
        if (message.offset != null && message.hasOwnProperty("offset"))
            object.offset = message.offset;
        return object;
    };

    /**
     * Converts this PageRequestType to JSON.
     * @function toJSON
     * @memberof PageRequestType
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PageRequestType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PageRequestType;
})();

$root.RicardianContract = (function() {

    /**
     * Properties of a RicardianContract.
     * @exports IRicardianContract
     * @interface IRicardianContract
     * @property {Array.<IListing>|null} [vendorListings] RicardianContract vendorListings
     * @property {IOrder|null} [buyerOrder] RicardianContract buyerOrder
     * @property {IOrderConfirmation|null} [vendorOrderConfirmation] RicardianContract vendorOrderConfirmation
     * @property {Array.<IOrderFulfillment>|null} [vendorOrderFulfillment] RicardianContract vendorOrderFulfillment
     * @property {IOrderCompletion|null} [buyerOrderCompletion] RicardianContract buyerOrderCompletion
     * @property {IDispute|null} [dispute] RicardianContract dispute
     * @property {IDisputeResolution|null} [disputeResolution] RicardianContract disputeResolution
     * @property {IDisputeAcceptance|null} [disputeAcceptance] RicardianContract disputeAcceptance
     * @property {IRefund|null} [refund] RicardianContract refund
     * @property {Array.<ISignature>|null} [signatures] RicardianContract signatures
     * @property {Array.<string>|null} [errors] RicardianContract errors
     */

    /**
     * Constructs a new RicardianContract.
     * @exports RicardianContract
     * @classdesc Represents a RicardianContract.
     * @implements IRicardianContract
     * @constructor
     * @param {IRicardianContract=} [properties] Properties to set
     */
    function RicardianContract(properties) {
        this.vendorListings = [];
        this.vendorOrderFulfillment = [];
        this.signatures = [];
        this.errors = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RicardianContract vendorListings.
     * @member {Array.<IListing>} vendorListings
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.vendorListings = $util.emptyArray;

    /**
     * RicardianContract buyerOrder.
     * @member {IOrder|null|undefined} buyerOrder
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.buyerOrder = null;

    /**
     * RicardianContract vendorOrderConfirmation.
     * @member {IOrderConfirmation|null|undefined} vendorOrderConfirmation
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.vendorOrderConfirmation = null;

    /**
     * RicardianContract vendorOrderFulfillment.
     * @member {Array.<IOrderFulfillment>} vendorOrderFulfillment
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.vendorOrderFulfillment = $util.emptyArray;

    /**
     * RicardianContract buyerOrderCompletion.
     * @member {IOrderCompletion|null|undefined} buyerOrderCompletion
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.buyerOrderCompletion = null;

    /**
     * RicardianContract dispute.
     * @member {IDispute|null|undefined} dispute
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.dispute = null;

    /**
     * RicardianContract disputeResolution.
     * @member {IDisputeResolution|null|undefined} disputeResolution
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.disputeResolution = null;

    /**
     * RicardianContract disputeAcceptance.
     * @member {IDisputeAcceptance|null|undefined} disputeAcceptance
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.disputeAcceptance = null;

    /**
     * RicardianContract refund.
     * @member {IRefund|null|undefined} refund
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.refund = null;

    /**
     * RicardianContract signatures.
     * @member {Array.<ISignature>} signatures
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.signatures = $util.emptyArray;

    /**
     * RicardianContract errors.
     * @member {Array.<string>} errors
     * @memberof RicardianContract
     * @instance
     */
    RicardianContract.prototype.errors = $util.emptyArray;

    /**
     * Creates a new RicardianContract instance using the specified properties.
     * @function create
     * @memberof RicardianContract
     * @static
     * @param {IRicardianContract=} [properties] Properties to set
     * @returns {RicardianContract} RicardianContract instance
     */
    RicardianContract.create = function create(properties) {
        return new RicardianContract(properties);
    };

    /**
     * Encodes the specified RicardianContract message. Does not implicitly {@link RicardianContract.verify|verify} messages.
     * @function encode
     * @memberof RicardianContract
     * @static
     * @param {IRicardianContract} message RicardianContract message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RicardianContract.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.vendorListings != null && message.vendorListings.length)
            for (var i = 0; i < message.vendorListings.length; ++i)
                $root.Listing.encode(message.vendorListings[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.buyerOrder != null && message.hasOwnProperty("buyerOrder"))
            $root.Order.encode(message.buyerOrder, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.vendorOrderConfirmation != null && message.hasOwnProperty("vendorOrderConfirmation"))
            $root.OrderConfirmation.encode(message.vendorOrderConfirmation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.vendorOrderFulfillment != null && message.vendorOrderFulfillment.length)
            for (var i = 0; i < message.vendorOrderFulfillment.length; ++i)
                $root.OrderFulfillment.encode(message.vendorOrderFulfillment[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.buyerOrderCompletion != null && message.hasOwnProperty("buyerOrderCompletion"))
            $root.OrderCompletion.encode(message.buyerOrderCompletion, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.dispute != null && message.hasOwnProperty("dispute"))
            $root.Dispute.encode(message.dispute, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.disputeResolution != null && message.hasOwnProperty("disputeResolution"))
            $root.DisputeResolution.encode(message.disputeResolution, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.disputeAcceptance != null && message.hasOwnProperty("disputeAcceptance"))
            $root.DisputeAcceptance.encode(message.disputeAcceptance, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.refund != null && message.hasOwnProperty("refund"))
            $root.Refund.encode(message.refund, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.signatures != null && message.signatures.length)
            for (var i = 0; i < message.signatures.length; ++i)
                $root.Signature.encode(message.signatures[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.errors != null && message.errors.length)
            for (var i = 0; i < message.errors.length; ++i)
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.errors[i]);
        return writer;
    };

    /**
     * Encodes the specified RicardianContract message, length delimited. Does not implicitly {@link RicardianContract.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RicardianContract
     * @static
     * @param {IRicardianContract} message RicardianContract message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RicardianContract.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RicardianContract message from the specified reader or buffer.
     * @function decode
     * @memberof RicardianContract
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RicardianContract} RicardianContract
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RicardianContract.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RicardianContract();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.vendorListings && message.vendorListings.length))
                    message.vendorListings = [];
                message.vendorListings.push($root.Listing.decode(reader, reader.uint32()));
                break;
            case 2:
                message.buyerOrder = $root.Order.decode(reader, reader.uint32());
                break;
            case 3:
                message.vendorOrderConfirmation = $root.OrderConfirmation.decode(reader, reader.uint32());
                break;
            case 4:
                if (!(message.vendorOrderFulfillment && message.vendorOrderFulfillment.length))
                    message.vendorOrderFulfillment = [];
                message.vendorOrderFulfillment.push($root.OrderFulfillment.decode(reader, reader.uint32()));
                break;
            case 5:
                message.buyerOrderCompletion = $root.OrderCompletion.decode(reader, reader.uint32());
                break;
            case 6:
                message.dispute = $root.Dispute.decode(reader, reader.uint32());
                break;
            case 7:
                message.disputeResolution = $root.DisputeResolution.decode(reader, reader.uint32());
                break;
            case 8:
                message.disputeAcceptance = $root.DisputeAcceptance.decode(reader, reader.uint32());
                break;
            case 9:
                message.refund = $root.Refund.decode(reader, reader.uint32());
                break;
            case 10:
                if (!(message.signatures && message.signatures.length))
                    message.signatures = [];
                message.signatures.push($root.Signature.decode(reader, reader.uint32()));
                break;
            case 11:
                if (!(message.errors && message.errors.length))
                    message.errors = [];
                message.errors.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RicardianContract message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RicardianContract
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RicardianContract} RicardianContract
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RicardianContract.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RicardianContract message.
     * @function verify
     * @memberof RicardianContract
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RicardianContract.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.vendorListings != null && message.hasOwnProperty("vendorListings")) {
            if (!Array.isArray(message.vendorListings))
                return "vendorListings: array expected";
            for (var i = 0; i < message.vendorListings.length; ++i) {
                var error = $root.Listing.verify(message.vendorListings[i]);
                if (error)
                    return "vendorListings." + error;
            }
        }
        if (message.buyerOrder != null && message.hasOwnProperty("buyerOrder")) {
            var error = $root.Order.verify(message.buyerOrder);
            if (error)
                return "buyerOrder." + error;
        }
        if (message.vendorOrderConfirmation != null && message.hasOwnProperty("vendorOrderConfirmation")) {
            var error = $root.OrderConfirmation.verify(message.vendorOrderConfirmation);
            if (error)
                return "vendorOrderConfirmation." + error;
        }
        if (message.vendorOrderFulfillment != null && message.hasOwnProperty("vendorOrderFulfillment")) {
            if (!Array.isArray(message.vendorOrderFulfillment))
                return "vendorOrderFulfillment: array expected";
            for (var i = 0; i < message.vendorOrderFulfillment.length; ++i) {
                var error = $root.OrderFulfillment.verify(message.vendorOrderFulfillment[i]);
                if (error)
                    return "vendorOrderFulfillment." + error;
            }
        }
        if (message.buyerOrderCompletion != null && message.hasOwnProperty("buyerOrderCompletion")) {
            var error = $root.OrderCompletion.verify(message.buyerOrderCompletion);
            if (error)
                return "buyerOrderCompletion." + error;
        }
        if (message.dispute != null && message.hasOwnProperty("dispute")) {
            var error = $root.Dispute.verify(message.dispute);
            if (error)
                return "dispute." + error;
        }
        if (message.disputeResolution != null && message.hasOwnProperty("disputeResolution")) {
            var error = $root.DisputeResolution.verify(message.disputeResolution);
            if (error)
                return "disputeResolution." + error;
        }
        if (message.disputeAcceptance != null && message.hasOwnProperty("disputeAcceptance")) {
            var error = $root.DisputeAcceptance.verify(message.disputeAcceptance);
            if (error)
                return "disputeAcceptance." + error;
        }
        if (message.refund != null && message.hasOwnProperty("refund")) {
            var error = $root.Refund.verify(message.refund);
            if (error)
                return "refund." + error;
        }
        if (message.signatures != null && message.hasOwnProperty("signatures")) {
            if (!Array.isArray(message.signatures))
                return "signatures: array expected";
            for (var i = 0; i < message.signatures.length; ++i) {
                var error = $root.Signature.verify(message.signatures[i]);
                if (error)
                    return "signatures." + error;
            }
        }
        if (message.errors != null && message.hasOwnProperty("errors")) {
            if (!Array.isArray(message.errors))
                return "errors: array expected";
            for (var i = 0; i < message.errors.length; ++i)
                if (!$util.isString(message.errors[i]))
                    return "errors: string[] expected";
        }
        return null;
    };

    /**
     * Creates a RicardianContract message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RicardianContract
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RicardianContract} RicardianContract
     */
    RicardianContract.fromObject = function fromObject(object) {
        if (object instanceof $root.RicardianContract)
            return object;
        var message = new $root.RicardianContract();
        if (object.vendorListings) {
            if (!Array.isArray(object.vendorListings))
                throw TypeError(".RicardianContract.vendorListings: array expected");
            message.vendorListings = [];
            for (var i = 0; i < object.vendorListings.length; ++i) {
                if (typeof object.vendorListings[i] !== "object")
                    throw TypeError(".RicardianContract.vendorListings: object expected");
                message.vendorListings[i] = $root.Listing.fromObject(object.vendorListings[i]);
            }
        }
        if (object.buyerOrder != null) {
            if (typeof object.buyerOrder !== "object")
                throw TypeError(".RicardianContract.buyerOrder: object expected");
            message.buyerOrder = $root.Order.fromObject(object.buyerOrder);
        }
        if (object.vendorOrderConfirmation != null) {
            if (typeof object.vendorOrderConfirmation !== "object")
                throw TypeError(".RicardianContract.vendorOrderConfirmation: object expected");
            message.vendorOrderConfirmation = $root.OrderConfirmation.fromObject(object.vendorOrderConfirmation);
        }
        if (object.vendorOrderFulfillment) {
            if (!Array.isArray(object.vendorOrderFulfillment))
                throw TypeError(".RicardianContract.vendorOrderFulfillment: array expected");
            message.vendorOrderFulfillment = [];
            for (var i = 0; i < object.vendorOrderFulfillment.length; ++i) {
                if (typeof object.vendorOrderFulfillment[i] !== "object")
                    throw TypeError(".RicardianContract.vendorOrderFulfillment: object expected");
                message.vendorOrderFulfillment[i] = $root.OrderFulfillment.fromObject(object.vendorOrderFulfillment[i]);
            }
        }
        if (object.buyerOrderCompletion != null) {
            if (typeof object.buyerOrderCompletion !== "object")
                throw TypeError(".RicardianContract.buyerOrderCompletion: object expected");
            message.buyerOrderCompletion = $root.OrderCompletion.fromObject(object.buyerOrderCompletion);
        }
        if (object.dispute != null) {
            if (typeof object.dispute !== "object")
                throw TypeError(".RicardianContract.dispute: object expected");
            message.dispute = $root.Dispute.fromObject(object.dispute);
        }
        if (object.disputeResolution != null) {
            if (typeof object.disputeResolution !== "object")
                throw TypeError(".RicardianContract.disputeResolution: object expected");
            message.disputeResolution = $root.DisputeResolution.fromObject(object.disputeResolution);
        }
        if (object.disputeAcceptance != null) {
            if (typeof object.disputeAcceptance !== "object")
                throw TypeError(".RicardianContract.disputeAcceptance: object expected");
            message.disputeAcceptance = $root.DisputeAcceptance.fromObject(object.disputeAcceptance);
        }
        if (object.refund != null) {
            if (typeof object.refund !== "object")
                throw TypeError(".RicardianContract.refund: object expected");
            message.refund = $root.Refund.fromObject(object.refund);
        }
        if (object.signatures) {
            if (!Array.isArray(object.signatures))
                throw TypeError(".RicardianContract.signatures: array expected");
            message.signatures = [];
            for (var i = 0; i < object.signatures.length; ++i) {
                if (typeof object.signatures[i] !== "object")
                    throw TypeError(".RicardianContract.signatures: object expected");
                message.signatures[i] = $root.Signature.fromObject(object.signatures[i]);
            }
        }
        if (object.errors) {
            if (!Array.isArray(object.errors))
                throw TypeError(".RicardianContract.errors: array expected");
            message.errors = [];
            for (var i = 0; i < object.errors.length; ++i)
                message.errors[i] = String(object.errors[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a RicardianContract message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RicardianContract
     * @static
     * @param {RicardianContract} message RicardianContract
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RicardianContract.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.vendorListings = [];
            object.vendorOrderFulfillment = [];
            object.signatures = [];
            object.errors = [];
        }
        if (options.defaults) {
            object.buyerOrder = null;
            object.vendorOrderConfirmation = null;
            object.buyerOrderCompletion = null;
            object.dispute = null;
            object.disputeResolution = null;
            object.disputeAcceptance = null;
            object.refund = null;
        }
        if (message.vendorListings && message.vendorListings.length) {
            object.vendorListings = [];
            for (var j = 0; j < message.vendorListings.length; ++j)
                object.vendorListings[j] = $root.Listing.toObject(message.vendorListings[j], options);
        }
        if (message.buyerOrder != null && message.hasOwnProperty("buyerOrder"))
            object.buyerOrder = $root.Order.toObject(message.buyerOrder, options);
        if (message.vendorOrderConfirmation != null && message.hasOwnProperty("vendorOrderConfirmation"))
            object.vendorOrderConfirmation = $root.OrderConfirmation.toObject(message.vendorOrderConfirmation, options);
        if (message.vendorOrderFulfillment && message.vendorOrderFulfillment.length) {
            object.vendorOrderFulfillment = [];
            for (var j = 0; j < message.vendorOrderFulfillment.length; ++j)
                object.vendorOrderFulfillment[j] = $root.OrderFulfillment.toObject(message.vendorOrderFulfillment[j], options);
        }
        if (message.buyerOrderCompletion != null && message.hasOwnProperty("buyerOrderCompletion"))
            object.buyerOrderCompletion = $root.OrderCompletion.toObject(message.buyerOrderCompletion, options);
        if (message.dispute != null && message.hasOwnProperty("dispute"))
            object.dispute = $root.Dispute.toObject(message.dispute, options);
        if (message.disputeResolution != null && message.hasOwnProperty("disputeResolution"))
            object.disputeResolution = $root.DisputeResolution.toObject(message.disputeResolution, options);
        if (message.disputeAcceptance != null && message.hasOwnProperty("disputeAcceptance"))
            object.disputeAcceptance = $root.DisputeAcceptance.toObject(message.disputeAcceptance, options);
        if (message.refund != null && message.hasOwnProperty("refund"))
            object.refund = $root.Refund.toObject(message.refund, options);
        if (message.signatures && message.signatures.length) {
            object.signatures = [];
            for (var j = 0; j < message.signatures.length; ++j)
                object.signatures[j] = $root.Signature.toObject(message.signatures[j], options);
        }
        if (message.errors && message.errors.length) {
            object.errors = [];
            for (var j = 0; j < message.errors.length; ++j)
                object.errors[j] = message.errors[j];
        }
        return object;
    };

    /**
     * Converts this RicardianContract to JSON.
     * @function toJSON
     * @memberof RicardianContract
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RicardianContract.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RicardianContract;
})();

$root.Listing = (function() {

    /**
     * Properties of a Listing.
     * @exports IListing
     * @interface IListing
     * @property {string|null} [slug] Listing slug
     * @property {IID|null} [vendorID] Listing vendorID
     * @property {Listing.IMetadata|null} [metadata] Listing metadata
     * @property {Listing.IItem|null} [item] Listing item
     * @property {Array.<Listing.IShippingOption>|null} [shippingOptions] Listing shippingOptions
     * @property {Array.<Listing.ITax>|null} [taxes] Listing taxes
     * @property {Array.<Listing.ICoupon>|null} [coupons] Listing coupons
     * @property {Array.<string>|null} [moderators] Listing moderators
     * @property {string|null} [termsAndConditions] Listing termsAndConditions
     * @property {string|null} [refundPolicy] Listing refundPolicy
     */

    /**
     * Constructs a new Listing.
     * @exports Listing
     * @classdesc Represents a Listing.
     * @implements IListing
     * @constructor
     * @param {IListing=} [properties] Properties to set
     */
    function Listing(properties) {
        this.shippingOptions = [];
        this.taxes = [];
        this.coupons = [];
        this.moderators = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Listing slug.
     * @member {string} slug
     * @memberof Listing
     * @instance
     */
    Listing.prototype.slug = "";

    /**
     * Listing vendorID.
     * @member {IID|null|undefined} vendorID
     * @memberof Listing
     * @instance
     */
    Listing.prototype.vendorID = null;

    /**
     * Listing metadata.
     * @member {Listing.IMetadata|null|undefined} metadata
     * @memberof Listing
     * @instance
     */
    Listing.prototype.metadata = null;

    /**
     * Listing item.
     * @member {Listing.IItem|null|undefined} item
     * @memberof Listing
     * @instance
     */
    Listing.prototype.item = null;

    /**
     * Listing shippingOptions.
     * @member {Array.<Listing.IShippingOption>} shippingOptions
     * @memberof Listing
     * @instance
     */
    Listing.prototype.shippingOptions = $util.emptyArray;

    /**
     * Listing taxes.
     * @member {Array.<Listing.ITax>} taxes
     * @memberof Listing
     * @instance
     */
    Listing.prototype.taxes = $util.emptyArray;

    /**
     * Listing coupons.
     * @member {Array.<Listing.ICoupon>} coupons
     * @memberof Listing
     * @instance
     */
    Listing.prototype.coupons = $util.emptyArray;

    /**
     * Listing moderators.
     * @member {Array.<string>} moderators
     * @memberof Listing
     * @instance
     */
    Listing.prototype.moderators = $util.emptyArray;

    /**
     * Listing termsAndConditions.
     * @member {string} termsAndConditions
     * @memberof Listing
     * @instance
     */
    Listing.prototype.termsAndConditions = "";

    /**
     * Listing refundPolicy.
     * @member {string} refundPolicy
     * @memberof Listing
     * @instance
     */
    Listing.prototype.refundPolicy = "";

    /**
     * Creates a new Listing instance using the specified properties.
     * @function create
     * @memberof Listing
     * @static
     * @param {IListing=} [properties] Properties to set
     * @returns {Listing} Listing instance
     */
    Listing.create = function create(properties) {
        return new Listing(properties);
    };

    /**
     * Encodes the specified Listing message. Does not implicitly {@link Listing.verify|verify} messages.
     * @function encode
     * @memberof Listing
     * @static
     * @param {IListing} message Listing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Listing.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.slug != null && message.hasOwnProperty("slug"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.slug);
        if (message.vendorID != null && message.hasOwnProperty("vendorID"))
            $root.ID.encode(message.vendorID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            $root.Listing.Metadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.item != null && message.hasOwnProperty("item"))
            $root.Listing.Item.encode(message.item, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.shippingOptions != null && message.shippingOptions.length)
            for (var i = 0; i < message.shippingOptions.length; ++i)
                $root.Listing.ShippingOption.encode(message.shippingOptions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.taxes != null && message.taxes.length)
            for (var i = 0; i < message.taxes.length; ++i)
                $root.Listing.Tax.encode(message.taxes[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.coupons != null && message.coupons.length)
            for (var i = 0; i < message.coupons.length; ++i)
                $root.Listing.Coupon.encode(message.coupons[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.moderators != null && message.moderators.length)
            for (var i = 0; i < message.moderators.length; ++i)
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.moderators[i]);
        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.termsAndConditions);
        if (message.refundPolicy != null && message.hasOwnProperty("refundPolicy"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.refundPolicy);
        return writer;
    };

    /**
     * Encodes the specified Listing message, length delimited. Does not implicitly {@link Listing.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Listing
     * @static
     * @param {IListing} message Listing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Listing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Listing message from the specified reader or buffer.
     * @function decode
     * @memberof Listing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Listing} Listing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Listing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.slug = reader.string();
                break;
            case 2:
                message.vendorID = $root.ID.decode(reader, reader.uint32());
                break;
            case 3:
                message.metadata = $root.Listing.Metadata.decode(reader, reader.uint32());
                break;
            case 4:
                message.item = $root.Listing.Item.decode(reader, reader.uint32());
                break;
            case 5:
                if (!(message.shippingOptions && message.shippingOptions.length))
                    message.shippingOptions = [];
                message.shippingOptions.push($root.Listing.ShippingOption.decode(reader, reader.uint32()));
                break;
            case 6:
                if (!(message.taxes && message.taxes.length))
                    message.taxes = [];
                message.taxes.push($root.Listing.Tax.decode(reader, reader.uint32()));
                break;
            case 7:
                if (!(message.coupons && message.coupons.length))
                    message.coupons = [];
                message.coupons.push($root.Listing.Coupon.decode(reader, reader.uint32()));
                break;
            case 8:
                if (!(message.moderators && message.moderators.length))
                    message.moderators = [];
                message.moderators.push(reader.string());
                break;
            case 9:
                message.termsAndConditions = reader.string();
                break;
            case 10:
                message.refundPolicy = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Listing message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Listing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Listing} Listing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Listing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Listing message.
     * @function verify
     * @memberof Listing
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Listing.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.slug != null && message.hasOwnProperty("slug"))
            if (!$util.isString(message.slug))
                return "slug: string expected";
        if (message.vendorID != null && message.hasOwnProperty("vendorID")) {
            var error = $root.ID.verify(message.vendorID);
            if (error)
                return "vendorID." + error;
        }
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            var error = $root.Listing.Metadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        if (message.item != null && message.hasOwnProperty("item")) {
            var error = $root.Listing.Item.verify(message.item);
            if (error)
                return "item." + error;
        }
        if (message.shippingOptions != null && message.hasOwnProperty("shippingOptions")) {
            if (!Array.isArray(message.shippingOptions))
                return "shippingOptions: array expected";
            for (var i = 0; i < message.shippingOptions.length; ++i) {
                var error = $root.Listing.ShippingOption.verify(message.shippingOptions[i]);
                if (error)
                    return "shippingOptions." + error;
            }
        }
        if (message.taxes != null && message.hasOwnProperty("taxes")) {
            if (!Array.isArray(message.taxes))
                return "taxes: array expected";
            for (var i = 0; i < message.taxes.length; ++i) {
                var error = $root.Listing.Tax.verify(message.taxes[i]);
                if (error)
                    return "taxes." + error;
            }
        }
        if (message.coupons != null && message.hasOwnProperty("coupons")) {
            if (!Array.isArray(message.coupons))
                return "coupons: array expected";
            for (var i = 0; i < message.coupons.length; ++i) {
                var error = $root.Listing.Coupon.verify(message.coupons[i]);
                if (error)
                    return "coupons." + error;
            }
        }
        if (message.moderators != null && message.hasOwnProperty("moderators")) {
            if (!Array.isArray(message.moderators))
                return "moderators: array expected";
            for (var i = 0; i < message.moderators.length; ++i)
                if (!$util.isString(message.moderators[i]))
                    return "moderators: string[] expected";
        }
        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
            if (!$util.isString(message.termsAndConditions))
                return "termsAndConditions: string expected";
        if (message.refundPolicy != null && message.hasOwnProperty("refundPolicy"))
            if (!$util.isString(message.refundPolicy))
                return "refundPolicy: string expected";
        return null;
    };

    /**
     * Creates a Listing message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Listing
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Listing} Listing
     */
    Listing.fromObject = function fromObject(object) {
        if (object instanceof $root.Listing)
            return object;
        var message = new $root.Listing();
        if (object.slug != null)
            message.slug = String(object.slug);
        if (object.vendorID != null) {
            if (typeof object.vendorID !== "object")
                throw TypeError(".Listing.vendorID: object expected");
            message.vendorID = $root.ID.fromObject(object.vendorID);
        }
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".Listing.metadata: object expected");
            message.metadata = $root.Listing.Metadata.fromObject(object.metadata);
        }
        if (object.item != null) {
            if (typeof object.item !== "object")
                throw TypeError(".Listing.item: object expected");
            message.item = $root.Listing.Item.fromObject(object.item);
        }
        if (object.shippingOptions) {
            if (!Array.isArray(object.shippingOptions))
                throw TypeError(".Listing.shippingOptions: array expected");
            message.shippingOptions = [];
            for (var i = 0; i < object.shippingOptions.length; ++i) {
                if (typeof object.shippingOptions[i] !== "object")
                    throw TypeError(".Listing.shippingOptions: object expected");
                message.shippingOptions[i] = $root.Listing.ShippingOption.fromObject(object.shippingOptions[i]);
            }
        }
        if (object.taxes) {
            if (!Array.isArray(object.taxes))
                throw TypeError(".Listing.taxes: array expected");
            message.taxes = [];
            for (var i = 0; i < object.taxes.length; ++i) {
                if (typeof object.taxes[i] !== "object")
                    throw TypeError(".Listing.taxes: object expected");
                message.taxes[i] = $root.Listing.Tax.fromObject(object.taxes[i]);
            }
        }
        if (object.coupons) {
            if (!Array.isArray(object.coupons))
                throw TypeError(".Listing.coupons: array expected");
            message.coupons = [];
            for (var i = 0; i < object.coupons.length; ++i) {
                if (typeof object.coupons[i] !== "object")
                    throw TypeError(".Listing.coupons: object expected");
                message.coupons[i] = $root.Listing.Coupon.fromObject(object.coupons[i]);
            }
        }
        if (object.moderators) {
            if (!Array.isArray(object.moderators))
                throw TypeError(".Listing.moderators: array expected");
            message.moderators = [];
            for (var i = 0; i < object.moderators.length; ++i)
                message.moderators[i] = String(object.moderators[i]);
        }
        if (object.termsAndConditions != null)
            message.termsAndConditions = String(object.termsAndConditions);
        if (object.refundPolicy != null)
            message.refundPolicy = String(object.refundPolicy);
        return message;
    };

    /**
     * Creates a plain object from a Listing message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Listing
     * @static
     * @param {Listing} message Listing
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Listing.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.shippingOptions = [];
            object.taxes = [];
            object.coupons = [];
            object.moderators = [];
        }
        if (options.defaults) {
            object.slug = "";
            object.vendorID = null;
            object.metadata = null;
            object.item = null;
            object.termsAndConditions = "";
            object.refundPolicy = "";
        }
        if (message.slug != null && message.hasOwnProperty("slug"))
            object.slug = message.slug;
        if (message.vendorID != null && message.hasOwnProperty("vendorID"))
            object.vendorID = $root.ID.toObject(message.vendorID, options);
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.Listing.Metadata.toObject(message.metadata, options);
        if (message.item != null && message.hasOwnProperty("item"))
            object.item = $root.Listing.Item.toObject(message.item, options);
        if (message.shippingOptions && message.shippingOptions.length) {
            object.shippingOptions = [];
            for (var j = 0; j < message.shippingOptions.length; ++j)
                object.shippingOptions[j] = $root.Listing.ShippingOption.toObject(message.shippingOptions[j], options);
        }
        if (message.taxes && message.taxes.length) {
            object.taxes = [];
            for (var j = 0; j < message.taxes.length; ++j)
                object.taxes[j] = $root.Listing.Tax.toObject(message.taxes[j], options);
        }
        if (message.coupons && message.coupons.length) {
            object.coupons = [];
            for (var j = 0; j < message.coupons.length; ++j)
                object.coupons[j] = $root.Listing.Coupon.toObject(message.coupons[j], options);
        }
        if (message.moderators && message.moderators.length) {
            object.moderators = [];
            for (var j = 0; j < message.moderators.length; ++j)
                object.moderators[j] = message.moderators[j];
        }
        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
            object.termsAndConditions = message.termsAndConditions;
        if (message.refundPolicy != null && message.hasOwnProperty("refundPolicy"))
            object.refundPolicy = message.refundPolicy;
        return object;
    };

    /**
     * Converts this Listing to JSON.
     * @function toJSON
     * @memberof Listing
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Listing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Listing.Metadata = (function() {

        /**
         * Properties of a Metadata.
         * @memberof Listing
         * @interface IMetadata
         * @property {number|null} [version] Metadata version
         * @property {Listing.Metadata.ContractType|null} [contractType] Metadata contractType
         * @property {Listing.Metadata.Format|null} [format] Metadata format
         * @property {google.protobuf.ITimestamp|null} [expiry] Metadata expiry
         * @property {Array.<string>|null} [acceptedCurrencies] Metadata acceptedCurrencies
         * @property {string|null} [pricingCurrency] Metadata pricingCurrency
         * @property {string|null} [language] Metadata language
         * @property {number|null} [escrowTimeoutHours] Metadata escrowTimeoutHours
         * @property {string|null} [coinType] Metadata coinType
         * @property {number|null} [coinDivisibility] Metadata coinDivisibility
         */

        /**
         * Constructs a new Metadata.
         * @memberof Listing
         * @classdesc Represents a Metadata.
         * @implements IMetadata
         * @constructor
         * @param {Listing.IMetadata=} [properties] Properties to set
         */
        function Metadata(properties) {
            this.acceptedCurrencies = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Metadata version.
         * @member {number} version
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.version = 0;

        /**
         * Metadata contractType.
         * @member {Listing.Metadata.ContractType} contractType
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.contractType = 0;

        /**
         * Metadata format.
         * @member {Listing.Metadata.Format} format
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.format = 0;

        /**
         * Metadata expiry.
         * @member {google.protobuf.ITimestamp|null|undefined} expiry
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.expiry = null;

        /**
         * Metadata acceptedCurrencies.
         * @member {Array.<string>} acceptedCurrencies
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.acceptedCurrencies = $util.emptyArray;

        /**
         * Metadata pricingCurrency.
         * @member {string} pricingCurrency
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.pricingCurrency = "";

        /**
         * Metadata language.
         * @member {string} language
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.language = "";

        /**
         * Metadata escrowTimeoutHours.
         * @member {number} escrowTimeoutHours
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.escrowTimeoutHours = 0;

        /**
         * Metadata coinType.
         * @member {string} coinType
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.coinType = "";

        /**
         * Metadata coinDivisibility.
         * @member {number} coinDivisibility
         * @memberof Listing.Metadata
         * @instance
         */
        Metadata.prototype.coinDivisibility = 0;

        /**
         * Creates a new Metadata instance using the specified properties.
         * @function create
         * @memberof Listing.Metadata
         * @static
         * @param {Listing.IMetadata=} [properties] Properties to set
         * @returns {Listing.Metadata} Metadata instance
         */
        Metadata.create = function create(properties) {
            return new Metadata(properties);
        };

        /**
         * Encodes the specified Metadata message. Does not implicitly {@link Listing.Metadata.verify|verify} messages.
         * @function encode
         * @memberof Listing.Metadata
         * @static
         * @param {Listing.IMetadata} message Metadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
            if (message.contractType != null && message.hasOwnProperty("contractType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.contractType);
            if (message.format != null && message.hasOwnProperty("format"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.format);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.acceptedCurrencies != null && message.acceptedCurrencies.length)
                for (var i = 0; i < message.acceptedCurrencies.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.acceptedCurrencies[i]);
            if (message.pricingCurrency != null && message.hasOwnProperty("pricingCurrency"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.pricingCurrency);
            if (message.language != null && message.hasOwnProperty("language"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.language);
            if (message.escrowTimeoutHours != null && message.hasOwnProperty("escrowTimeoutHours"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.escrowTimeoutHours);
            if (message.coinType != null && message.hasOwnProperty("coinType"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.coinType);
            if (message.coinDivisibility != null && message.hasOwnProperty("coinDivisibility"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.coinDivisibility);
            return writer;
        };

        /**
         * Encodes the specified Metadata message, length delimited. Does not implicitly {@link Listing.Metadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Listing.Metadata
         * @static
         * @param {Listing.IMetadata} message Metadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Metadata message from the specified reader or buffer.
         * @function decode
         * @memberof Listing.Metadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Listing.Metadata} Metadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing.Metadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.contractType = reader.int32();
                    break;
                case 3:
                    message.format = reader.int32();
                    break;
                case 4:
                    message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.acceptedCurrencies && message.acceptedCurrencies.length))
                        message.acceptedCurrencies = [];
                    message.acceptedCurrencies.push(reader.string());
                    break;
                case 6:
                    message.pricingCurrency = reader.string();
                    break;
                case 7:
                    message.language = reader.string();
                    break;
                case 8:
                    message.escrowTimeoutHours = reader.uint32();
                    break;
                case 9:
                    message.coinType = reader.string();
                    break;
                case 10:
                    message.coinDivisibility = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Metadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Listing.Metadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Listing.Metadata} Metadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Metadata message.
         * @function verify
         * @memberof Listing.Metadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Metadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.contractType != null && message.hasOwnProperty("contractType"))
                switch (message.contractType) {
                default:
                    return "contractType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.format != null && message.hasOwnProperty("format"))
                switch (message.format) {
                default:
                    return "format: enum value expected";
                case 0:
                case 2:
                    break;
                }
            if (message.expiry != null && message.hasOwnProperty("expiry")) {
                var error = $root.google.protobuf.Timestamp.verify(message.expiry);
                if (error)
                    return "expiry." + error;
            }
            if (message.acceptedCurrencies != null && message.hasOwnProperty("acceptedCurrencies")) {
                if (!Array.isArray(message.acceptedCurrencies))
                    return "acceptedCurrencies: array expected";
                for (var i = 0; i < message.acceptedCurrencies.length; ++i)
                    if (!$util.isString(message.acceptedCurrencies[i]))
                        return "acceptedCurrencies: string[] expected";
            }
            if (message.pricingCurrency != null && message.hasOwnProperty("pricingCurrency"))
                if (!$util.isString(message.pricingCurrency))
                    return "pricingCurrency: string expected";
            if (message.language != null && message.hasOwnProperty("language"))
                if (!$util.isString(message.language))
                    return "language: string expected";
            if (message.escrowTimeoutHours != null && message.hasOwnProperty("escrowTimeoutHours"))
                if (!$util.isInteger(message.escrowTimeoutHours))
                    return "escrowTimeoutHours: integer expected";
            if (message.coinType != null && message.hasOwnProperty("coinType"))
                if (!$util.isString(message.coinType))
                    return "coinType: string expected";
            if (message.coinDivisibility != null && message.hasOwnProperty("coinDivisibility"))
                if (!$util.isInteger(message.coinDivisibility))
                    return "coinDivisibility: integer expected";
            return null;
        };

        /**
         * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Listing.Metadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Listing.Metadata} Metadata
         */
        Metadata.fromObject = function fromObject(object) {
            if (object instanceof $root.Listing.Metadata)
                return object;
            var message = new $root.Listing.Metadata();
            if (object.version != null)
                message.version = object.version >>> 0;
            switch (object.contractType) {
            case "PHYSICAL_GOOD":
            case 0:
                message.contractType = 0;
                break;
            case "DIGITAL_GOOD":
            case 1:
                message.contractType = 1;
                break;
            case "SERVICE":
            case 2:
                message.contractType = 2;
                break;
            case "CROWD_FUND":
            case 3:
                message.contractType = 3;
                break;
            case "CRYPTOCURRENCY":
            case 4:
                message.contractType = 4;
                break;
            }
            switch (object.format) {
            case "FIXED_PRICE":
            case 0:
                message.format = 0;
                break;
            case "MARKET_PRICE":
            case 2:
                message.format = 2;
                break;
            }
            if (object.expiry != null) {
                if (typeof object.expiry !== "object")
                    throw TypeError(".Listing.Metadata.expiry: object expected");
                message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
            }
            if (object.acceptedCurrencies) {
                if (!Array.isArray(object.acceptedCurrencies))
                    throw TypeError(".Listing.Metadata.acceptedCurrencies: array expected");
                message.acceptedCurrencies = [];
                for (var i = 0; i < object.acceptedCurrencies.length; ++i)
                    message.acceptedCurrencies[i] = String(object.acceptedCurrencies[i]);
            }
            if (object.pricingCurrency != null)
                message.pricingCurrency = String(object.pricingCurrency);
            if (object.language != null)
                message.language = String(object.language);
            if (object.escrowTimeoutHours != null)
                message.escrowTimeoutHours = object.escrowTimeoutHours >>> 0;
            if (object.coinType != null)
                message.coinType = String(object.coinType);
            if (object.coinDivisibility != null)
                message.coinDivisibility = object.coinDivisibility >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Metadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Listing.Metadata
         * @static
         * @param {Listing.Metadata} message Metadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Metadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.acceptedCurrencies = [];
            if (options.defaults) {
                object.version = 0;
                object.contractType = options.enums === String ? "PHYSICAL_GOOD" : 0;
                object.format = options.enums === String ? "FIXED_PRICE" : 0;
                object.expiry = null;
                object.pricingCurrency = "";
                object.language = "";
                object.escrowTimeoutHours = 0;
                object.coinType = "";
                object.coinDivisibility = 0;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.contractType != null && message.hasOwnProperty("contractType"))
                object.contractType = options.enums === String ? $root.Listing.Metadata.ContractType[message.contractType] : message.contractType;
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = options.enums === String ? $root.Listing.Metadata.Format[message.format] : message.format;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
            if (message.acceptedCurrencies && message.acceptedCurrencies.length) {
                object.acceptedCurrencies = [];
                for (var j = 0; j < message.acceptedCurrencies.length; ++j)
                    object.acceptedCurrencies[j] = message.acceptedCurrencies[j];
            }
            if (message.pricingCurrency != null && message.hasOwnProperty("pricingCurrency"))
                object.pricingCurrency = message.pricingCurrency;
            if (message.language != null && message.hasOwnProperty("language"))
                object.language = message.language;
            if (message.escrowTimeoutHours != null && message.hasOwnProperty("escrowTimeoutHours"))
                object.escrowTimeoutHours = message.escrowTimeoutHours;
            if (message.coinType != null && message.hasOwnProperty("coinType"))
                object.coinType = message.coinType;
            if (message.coinDivisibility != null && message.hasOwnProperty("coinDivisibility"))
                object.coinDivisibility = message.coinDivisibility;
            return object;
        };

        /**
         * Converts this Metadata to JSON.
         * @function toJSON
         * @memberof Listing.Metadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Metadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ContractType enum.
         * @name Listing.Metadata.ContractType
         * @enum {string}
         * @property {number} PHYSICAL_GOOD=0 PHYSICAL_GOOD value
         * @property {number} DIGITAL_GOOD=1 DIGITAL_GOOD value
         * @property {number} SERVICE=2 SERVICE value
         * @property {number} CROWD_FUND=3 CROWD_FUND value
         * @property {number} CRYPTOCURRENCY=4 CRYPTOCURRENCY value
         */
        Metadata.ContractType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PHYSICAL_GOOD"] = 0;
            values[valuesById[1] = "DIGITAL_GOOD"] = 1;
            values[valuesById[2] = "SERVICE"] = 2;
            values[valuesById[3] = "CROWD_FUND"] = 3;
            values[valuesById[4] = "CRYPTOCURRENCY"] = 4;
            return values;
        })();

        /**
         * Format enum.
         * @name Listing.Metadata.Format
         * @enum {string}
         * @property {number} FIXED_PRICE=0 FIXED_PRICE value
         * @property {number} MARKET_PRICE=2 MARKET_PRICE value
         */
        Metadata.Format = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FIXED_PRICE"] = 0;
            values[valuesById[2] = "MARKET_PRICE"] = 2;
            return values;
        })();

        return Metadata;
    })();

    Listing.Item = (function() {

        /**
         * Properties of an Item.
         * @memberof Listing
         * @interface IItem
         * @property {string|null} [title] Item title
         * @property {string|null} [description] Item description
         * @property {string|null} [processingTime] Item processingTime
         * @property {number|Long|null} [price] Item price
         * @property {boolean|null} [nsfw] The price in ..... tk
         * @property {Array.<string>|null} [tags] Whether the listing contains mature or adult content.
         * @property {Array.<IImage>|null} [images] A list of tags
         * @property {Array.<string>|null} [categories] A list of images for the item. (tiny: 90x90)
         * @property {number|null} [grams] A list of categories to organize listings within store
         * @property {string|null} [condition] Item condition
         * @property {Array.<Listing.Item.IOption>|null} [options] Item options
         * @property {Array.<Listing.Item.ISku>|null} [skus] Item skus
         */

        /**
         * Constructs a new Item.
         * @memberof Listing
         * @classdesc Represents an Item.
         * @implements IItem
         * @constructor
         * @param {Listing.IItem=} [properties] Properties to set
         */
        function Item(properties) {
            this.tags = [];
            this.images = [];
            this.categories = [];
            this.options = [];
            this.skus = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Item title.
         * @member {string} title
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.title = "";

        /**
         * Item description.
         * @member {string} description
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.description = "";

        /**
         * Item processingTime.
         * @member {string} processingTime
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.processingTime = "";

        /**
         * Item price.
         * @member {number|Long} price
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.price = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The price in ..... tk
         * @member {boolean} nsfw
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.nsfw = false;

        /**
         * Whether the listing contains mature or adult content.
         * @member {Array.<string>} tags
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.tags = $util.emptyArray;

        /**
         * A list of tags
         * @member {Array.<IImage>} images
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.images = $util.emptyArray;

        /**
         * A list of images for the item. (tiny: 90x90)
         * @member {Array.<string>} categories
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.categories = $util.emptyArray;

        /**
         * A list of categories to organize listings within store
         * @member {number} grams
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.grams = 0;

        /**
         * Item condition.
         * @member {string} condition
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.condition = "";

        /**
         * Item options.
         * @member {Array.<Listing.Item.IOption>} options
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.options = $util.emptyArray;

        /**
         * Item skus.
         * @member {Array.<Listing.Item.ISku>} skus
         * @memberof Listing.Item
         * @instance
         */
        Item.prototype.skus = $util.emptyArray;

        /**
         * Creates a new Item instance using the specified properties.
         * @function create
         * @memberof Listing.Item
         * @static
         * @param {Listing.IItem=} [properties] Properties to set
         * @returns {Listing.Item} Item instance
         */
        Item.create = function create(properties) {
            return new Item(properties);
        };

        /**
         * Encodes the specified Item message. Does not implicitly {@link Listing.Item.verify|verify} messages.
         * @function encode
         * @memberof Listing.Item
         * @static
         * @param {Listing.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
            if (message.processingTime != null && message.hasOwnProperty("processingTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.processingTime);
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.price);
            if (message.nsfw != null && message.hasOwnProperty("nsfw"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.nsfw);
            if (message.tags != null && message.tags.length)
                for (var i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
            if (message.images != null && message.images.length)
                for (var i = 0; i < message.images.length; ++i)
                    $root.Image.encode(message.images[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.categories != null && message.categories.length)
                for (var i = 0; i < message.categories.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.categories[i]);
            if (message.grams != null && message.hasOwnProperty("grams"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.grams);
            if (message.condition != null && message.hasOwnProperty("condition"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.condition);
            if (message.options != null && message.options.length)
                for (var i = 0; i < message.options.length; ++i)
                    $root.Listing.Item.Option.encode(message.options[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.skus != null && message.skus.length)
                for (var i = 0; i < message.skus.length; ++i)
                    $root.Listing.Item.Sku.encode(message.skus[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Item message, length delimited. Does not implicitly {@link Listing.Item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Listing.Item
         * @static
         * @param {Listing.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Item message from the specified reader or buffer.
         * @function decode
         * @memberof Listing.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Listing.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing.Item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.processingTime = reader.string();
                    break;
                case 4:
                    message.price = reader.uint64();
                    break;
                case 5:
                    message.nsfw = reader.bool();
                    break;
                case 6:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 7:
                    if (!(message.images && message.images.length))
                        message.images = [];
                    message.images.push($root.Image.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.categories && message.categories.length))
                        message.categories = [];
                    message.categories.push(reader.string());
                    break;
                case 9:
                    message.grams = reader.float();
                    break;
                case 10:
                    message.condition = reader.string();
                    break;
                case 11:
                    if (!(message.options && message.options.length))
                        message.options = [];
                    message.options.push($root.Listing.Item.Option.decode(reader, reader.uint32()));
                    break;
                case 12:
                    if (!(message.skus && message.skus.length))
                        message.skus = [];
                    message.skus.push($root.Listing.Item.Sku.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Listing.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Listing.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Item message.
         * @function verify
         * @memberof Listing.Item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.processingTime != null && message.hasOwnProperty("processingTime"))
                if (!$util.isString(message.processingTime))
                    return "processingTime: string expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (!$util.isInteger(message.price) && !(message.price && $util.isInteger(message.price.low) && $util.isInteger(message.price.high)))
                    return "price: integer|Long expected";
            if (message.nsfw != null && message.hasOwnProperty("nsfw"))
                if (typeof message.nsfw !== "boolean")
                    return "nsfw: boolean expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (var i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.images != null && message.hasOwnProperty("images")) {
                if (!Array.isArray(message.images))
                    return "images: array expected";
                for (var i = 0; i < message.images.length; ++i) {
                    var error = $root.Image.verify(message.images[i]);
                    if (error)
                        return "images." + error;
                }
            }
            if (message.categories != null && message.hasOwnProperty("categories")) {
                if (!Array.isArray(message.categories))
                    return "categories: array expected";
                for (var i = 0; i < message.categories.length; ++i)
                    if (!$util.isString(message.categories[i]))
                        return "categories: string[] expected";
            }
            if (message.grams != null && message.hasOwnProperty("grams"))
                if (typeof message.grams !== "number")
                    return "grams: number expected";
            if (message.condition != null && message.hasOwnProperty("condition"))
                if (!$util.isString(message.condition))
                    return "condition: string expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!Array.isArray(message.options))
                    return "options: array expected";
                for (var i = 0; i < message.options.length; ++i) {
                    var error = $root.Listing.Item.Option.verify(message.options[i]);
                    if (error)
                        return "options." + error;
                }
            }
            if (message.skus != null && message.hasOwnProperty("skus")) {
                if (!Array.isArray(message.skus))
                    return "skus: array expected";
                for (var i = 0; i < message.skus.length; ++i) {
                    var error = $root.Listing.Item.Sku.verify(message.skus[i]);
                    if (error)
                        return "skus." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Listing.Item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Listing.Item} Item
         */
        Item.fromObject = function fromObject(object) {
            if (object instanceof $root.Listing.Item)
                return object;
            var message = new $root.Listing.Item();
            if (object.title != null)
                message.title = String(object.title);
            if (object.description != null)
                message.description = String(object.description);
            if (object.processingTime != null)
                message.processingTime = String(object.processingTime);
            if (object.price != null)
                if ($util.Long)
                    (message.price = $util.Long.fromValue(object.price)).unsigned = true;
                else if (typeof object.price === "string")
                    message.price = parseInt(object.price, 10);
                else if (typeof object.price === "number")
                    message.price = object.price;
                else if (typeof object.price === "object")
                    message.price = new $util.LongBits(object.price.low >>> 0, object.price.high >>> 0).toNumber(true);
            if (object.nsfw != null)
                message.nsfw = Boolean(object.nsfw);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".Listing.Item.tags: array expected");
                message.tags = [];
                for (var i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.images) {
                if (!Array.isArray(object.images))
                    throw TypeError(".Listing.Item.images: array expected");
                message.images = [];
                for (var i = 0; i < object.images.length; ++i) {
                    if (typeof object.images[i] !== "object")
                        throw TypeError(".Listing.Item.images: object expected");
                    message.images[i] = $root.Image.fromObject(object.images[i]);
                }
            }
            if (object.categories) {
                if (!Array.isArray(object.categories))
                    throw TypeError(".Listing.Item.categories: array expected");
                message.categories = [];
                for (var i = 0; i < object.categories.length; ++i)
                    message.categories[i] = String(object.categories[i]);
            }
            if (object.grams != null)
                message.grams = Number(object.grams);
            if (object.condition != null)
                message.condition = String(object.condition);
            if (object.options) {
                if (!Array.isArray(object.options))
                    throw TypeError(".Listing.Item.options: array expected");
                message.options = [];
                for (var i = 0; i < object.options.length; ++i) {
                    if (typeof object.options[i] !== "object")
                        throw TypeError(".Listing.Item.options: object expected");
                    message.options[i] = $root.Listing.Item.Option.fromObject(object.options[i]);
                }
            }
            if (object.skus) {
                if (!Array.isArray(object.skus))
                    throw TypeError(".Listing.Item.skus: array expected");
                message.skus = [];
                for (var i = 0; i < object.skus.length; ++i) {
                    if (typeof object.skus[i] !== "object")
                        throw TypeError(".Listing.Item.skus: object expected");
                    message.skus[i] = $root.Listing.Item.Sku.fromObject(object.skus[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Listing.Item
         * @static
         * @param {Listing.Item} message Item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.tags = [];
                object.images = [];
                object.categories = [];
                object.options = [];
                object.skus = [];
            }
            if (options.defaults) {
                object.title = "";
                object.description = "";
                object.processingTime = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.price = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.price = options.longs === String ? "0" : 0;
                object.nsfw = false;
                object.grams = 0;
                object.condition = "";
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.processingTime != null && message.hasOwnProperty("processingTime"))
                object.processingTime = message.processingTime;
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price === "number")
                    object.price = options.longs === String ? String(message.price) : message.price;
                else
                    object.price = options.longs === String ? $util.Long.prototype.toString.call(message.price) : options.longs === Number ? new $util.LongBits(message.price.low >>> 0, message.price.high >>> 0).toNumber(true) : message.price;
            if (message.nsfw != null && message.hasOwnProperty("nsfw"))
                object.nsfw = message.nsfw;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (var j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.images && message.images.length) {
                object.images = [];
                for (var j = 0; j < message.images.length; ++j)
                    object.images[j] = $root.Image.toObject(message.images[j], options);
            }
            if (message.categories && message.categories.length) {
                object.categories = [];
                for (var j = 0; j < message.categories.length; ++j)
                    object.categories[j] = message.categories[j];
            }
            if (message.grams != null && message.hasOwnProperty("grams"))
                object.grams = options.json && !isFinite(message.grams) ? String(message.grams) : message.grams;
            if (message.condition != null && message.hasOwnProperty("condition"))
                object.condition = message.condition;
            if (message.options && message.options.length) {
                object.options = [];
                for (var j = 0; j < message.options.length; ++j)
                    object.options[j] = $root.Listing.Item.Option.toObject(message.options[j], options);
            }
            if (message.skus && message.skus.length) {
                object.skus = [];
                for (var j = 0; j < message.skus.length; ++j)
                    object.skus[j] = $root.Listing.Item.Sku.toObject(message.skus[j], options);
            }
            return object;
        };

        /**
         * Converts this Item to JSON.
         * @function toJSON
         * @memberof Listing.Item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Item.Option = (function() {

            /**
             * Properties of an Option.
             * @memberof Listing.Item
             * @interface IOption
             * @property {string|null} [name] Option name
             * @property {string|null} [description] Option description
             * @property {Array.<Listing.Item.Option.IVariant>|null} [variants] Option variants
             */

            /**
             * Constructs a new Option.
             * @memberof Listing.Item
             * @classdesc Represents an Option.
             * @implements IOption
             * @constructor
             * @param {Listing.Item.IOption=} [properties] Properties to set
             */
            function Option(properties) {
                this.variants = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Option name.
             * @member {string} name
             * @memberof Listing.Item.Option
             * @instance
             */
            Option.prototype.name = "";

            /**
             * Option description.
             * @member {string} description
             * @memberof Listing.Item.Option
             * @instance
             */
            Option.prototype.description = "";

            /**
             * Option variants.
             * @member {Array.<Listing.Item.Option.IVariant>} variants
             * @memberof Listing.Item.Option
             * @instance
             */
            Option.prototype.variants = $util.emptyArray;

            /**
             * Creates a new Option instance using the specified properties.
             * @function create
             * @memberof Listing.Item.Option
             * @static
             * @param {Listing.Item.IOption=} [properties] Properties to set
             * @returns {Listing.Item.Option} Option instance
             */
            Option.create = function create(properties) {
                return new Option(properties);
            };

            /**
             * Encodes the specified Option message. Does not implicitly {@link Listing.Item.Option.verify|verify} messages.
             * @function encode
             * @memberof Listing.Item.Option
             * @static
             * @param {Listing.Item.IOption} message Option message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Option.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                if (message.variants != null && message.variants.length)
                    for (var i = 0; i < message.variants.length; ++i)
                        $root.Listing.Item.Option.Variant.encode(message.variants[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Option message, length delimited. Does not implicitly {@link Listing.Item.Option.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Listing.Item.Option
             * @static
             * @param {Listing.Item.IOption} message Option message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Option.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Option message from the specified reader or buffer.
             * @function decode
             * @memberof Listing.Item.Option
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Listing.Item.Option} Option
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Option.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing.Item.Option();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.description = reader.string();
                        break;
                    case 3:
                        if (!(message.variants && message.variants.length))
                            message.variants = [];
                        message.variants.push($root.Listing.Item.Option.Variant.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Option message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Listing.Item.Option
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Listing.Item.Option} Option
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Option.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Option message.
             * @function verify
             * @memberof Listing.Item.Option
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Option.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.variants != null && message.hasOwnProperty("variants")) {
                    if (!Array.isArray(message.variants))
                        return "variants: array expected";
                    for (var i = 0; i < message.variants.length; ++i) {
                        var error = $root.Listing.Item.Option.Variant.verify(message.variants[i]);
                        if (error)
                            return "variants." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Option message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Listing.Item.Option
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Listing.Item.Option} Option
             */
            Option.fromObject = function fromObject(object) {
                if (object instanceof $root.Listing.Item.Option)
                    return object;
                var message = new $root.Listing.Item.Option();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.variants) {
                    if (!Array.isArray(object.variants))
                        throw TypeError(".Listing.Item.Option.variants: array expected");
                    message.variants = [];
                    for (var i = 0; i < object.variants.length; ++i) {
                        if (typeof object.variants[i] !== "object")
                            throw TypeError(".Listing.Item.Option.variants: object expected");
                        message.variants[i] = $root.Listing.Item.Option.Variant.fromObject(object.variants[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Option message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Listing.Item.Option
             * @static
             * @param {Listing.Item.Option} message Option
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Option.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.variants = [];
                if (options.defaults) {
                    object.name = "";
                    object.description = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.variants && message.variants.length) {
                    object.variants = [];
                    for (var j = 0; j < message.variants.length; ++j)
                        object.variants[j] = $root.Listing.Item.Option.Variant.toObject(message.variants[j], options);
                }
                return object;
            };

            /**
             * Converts this Option to JSON.
             * @function toJSON
             * @memberof Listing.Item.Option
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Option.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Option.Variant = (function() {

                /**
                 * Properties of a Variant.
                 * @memberof Listing.Item.Option
                 * @interface IVariant
                 * @property {string|null} [name] Variant name
                 * @property {IImage|null} [image] Variant image
                 */

                /**
                 * Constructs a new Variant.
                 * @memberof Listing.Item.Option
                 * @classdesc Represents a Variant.
                 * @implements IVariant
                 * @constructor
                 * @param {Listing.Item.Option.IVariant=} [properties] Properties to set
                 */
                function Variant(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Variant name.
                 * @member {string} name
                 * @memberof Listing.Item.Option.Variant
                 * @instance
                 */
                Variant.prototype.name = "";

                /**
                 * Variant image.
                 * @member {IImage|null|undefined} image
                 * @memberof Listing.Item.Option.Variant
                 * @instance
                 */
                Variant.prototype.image = null;

                /**
                 * Creates a new Variant instance using the specified properties.
                 * @function create
                 * @memberof Listing.Item.Option.Variant
                 * @static
                 * @param {Listing.Item.Option.IVariant=} [properties] Properties to set
                 * @returns {Listing.Item.Option.Variant} Variant instance
                 */
                Variant.create = function create(properties) {
                    return new Variant(properties);
                };

                /**
                 * Encodes the specified Variant message. Does not implicitly {@link Listing.Item.Option.Variant.verify|verify} messages.
                 * @function encode
                 * @memberof Listing.Item.Option.Variant
                 * @static
                 * @param {Listing.Item.Option.IVariant} message Variant message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Variant.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.image != null && message.hasOwnProperty("image"))
                        $root.Image.encode(message.image, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Variant message, length delimited. Does not implicitly {@link Listing.Item.Option.Variant.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Listing.Item.Option.Variant
                 * @static
                 * @param {Listing.Item.Option.IVariant} message Variant message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Variant.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Variant message from the specified reader or buffer.
                 * @function decode
                 * @memberof Listing.Item.Option.Variant
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Listing.Item.Option.Variant} Variant
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Variant.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing.Item.Option.Variant();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.image = $root.Image.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Variant message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Listing.Item.Option.Variant
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Listing.Item.Option.Variant} Variant
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Variant.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Variant message.
                 * @function verify
                 * @memberof Listing.Item.Option.Variant
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Variant.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.image != null && message.hasOwnProperty("image")) {
                        var error = $root.Image.verify(message.image);
                        if (error)
                            return "image." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Variant message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Listing.Item.Option.Variant
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Listing.Item.Option.Variant} Variant
                 */
                Variant.fromObject = function fromObject(object) {
                    if (object instanceof $root.Listing.Item.Option.Variant)
                        return object;
                    var message = new $root.Listing.Item.Option.Variant();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.image != null) {
                        if (typeof object.image !== "object")
                            throw TypeError(".Listing.Item.Option.Variant.image: object expected");
                        message.image = $root.Image.fromObject(object.image);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Variant message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Listing.Item.Option.Variant
                 * @static
                 * @param {Listing.Item.Option.Variant} message Variant
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Variant.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.image = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.image != null && message.hasOwnProperty("image"))
                        object.image = $root.Image.toObject(message.image, options);
                    return object;
                };

                /**
                 * Converts this Variant to JSON.
                 * @function toJSON
                 * @memberof Listing.Item.Option.Variant
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Variant.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Variant;
            })();

            return Option;
        })();

        Item.Sku = (function() {

            /**
             * Properties of a Sku.
             * @memberof Listing.Item
             * @interface ISku
             * @property {Array.<number>|null} [variantCombo] Sku variantCombo
             * @property {string|null} [productID] Sku productID
             * @property {number|Long|null} [surcharge] Sku surcharge
             * @property {number|Long|null} [quantity] Sku quantity
             */

            /**
             * Constructs a new Sku.
             * @memberof Listing.Item
             * @classdesc Represents a Sku.
             * @implements ISku
             * @constructor
             * @param {Listing.Item.ISku=} [properties] Properties to set
             */
            function Sku(properties) {
                this.variantCombo = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sku variantCombo.
             * @member {Array.<number>} variantCombo
             * @memberof Listing.Item.Sku
             * @instance
             */
            Sku.prototype.variantCombo = $util.emptyArray;

            /**
             * Sku productID.
             * @member {string} productID
             * @memberof Listing.Item.Sku
             * @instance
             */
            Sku.prototype.productID = "";

            /**
             * Sku surcharge.
             * @member {number|Long} surcharge
             * @memberof Listing.Item.Sku
             * @instance
             */
            Sku.prototype.surcharge = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Sku quantity.
             * @member {number|Long} quantity
             * @memberof Listing.Item.Sku
             * @instance
             */
            Sku.prototype.quantity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Sku instance using the specified properties.
             * @function create
             * @memberof Listing.Item.Sku
             * @static
             * @param {Listing.Item.ISku=} [properties] Properties to set
             * @returns {Listing.Item.Sku} Sku instance
             */
            Sku.create = function create(properties) {
                return new Sku(properties);
            };

            /**
             * Encodes the specified Sku message. Does not implicitly {@link Listing.Item.Sku.verify|verify} messages.
             * @function encode
             * @memberof Listing.Item.Sku
             * @static
             * @param {Listing.Item.ISku} message Sku message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sku.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.variantCombo != null && message.variantCombo.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.variantCombo.length; ++i)
                        writer.uint32(message.variantCombo[i]);
                    writer.ldelim();
                }
                if (message.productID != null && message.hasOwnProperty("productID"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.productID);
                if (message.surcharge != null && message.hasOwnProperty("surcharge"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.surcharge);
                if (message.quantity != null && message.hasOwnProperty("quantity"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.quantity);
                return writer;
            };

            /**
             * Encodes the specified Sku message, length delimited. Does not implicitly {@link Listing.Item.Sku.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Listing.Item.Sku
             * @static
             * @param {Listing.Item.ISku} message Sku message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sku.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sku message from the specified reader or buffer.
             * @function decode
             * @memberof Listing.Item.Sku
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Listing.Item.Sku} Sku
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sku.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing.Item.Sku();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.variantCombo && message.variantCombo.length))
                            message.variantCombo = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.variantCombo.push(reader.uint32());
                        } else
                            message.variantCombo.push(reader.uint32());
                        break;
                    case 2:
                        message.productID = reader.string();
                        break;
                    case 3:
                        message.surcharge = reader.int64();
                        break;
                    case 4:
                        message.quantity = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sku message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Listing.Item.Sku
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Listing.Item.Sku} Sku
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sku.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sku message.
             * @function verify
             * @memberof Listing.Item.Sku
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sku.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.variantCombo != null && message.hasOwnProperty("variantCombo")) {
                    if (!Array.isArray(message.variantCombo))
                        return "variantCombo: array expected";
                    for (var i = 0; i < message.variantCombo.length; ++i)
                        if (!$util.isInteger(message.variantCombo[i]))
                            return "variantCombo: integer[] expected";
                }
                if (message.productID != null && message.hasOwnProperty("productID"))
                    if (!$util.isString(message.productID))
                        return "productID: string expected";
                if (message.surcharge != null && message.hasOwnProperty("surcharge"))
                    if (!$util.isInteger(message.surcharge) && !(message.surcharge && $util.isInteger(message.surcharge.low) && $util.isInteger(message.surcharge.high)))
                        return "surcharge: integer|Long expected";
                if (message.quantity != null && message.hasOwnProperty("quantity"))
                    if (!$util.isInteger(message.quantity) && !(message.quantity && $util.isInteger(message.quantity.low) && $util.isInteger(message.quantity.high)))
                        return "quantity: integer|Long expected";
                return null;
            };

            /**
             * Creates a Sku message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Listing.Item.Sku
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Listing.Item.Sku} Sku
             */
            Sku.fromObject = function fromObject(object) {
                if (object instanceof $root.Listing.Item.Sku)
                    return object;
                var message = new $root.Listing.Item.Sku();
                if (object.variantCombo) {
                    if (!Array.isArray(object.variantCombo))
                        throw TypeError(".Listing.Item.Sku.variantCombo: array expected");
                    message.variantCombo = [];
                    for (var i = 0; i < object.variantCombo.length; ++i)
                        message.variantCombo[i] = object.variantCombo[i] >>> 0;
                }
                if (object.productID != null)
                    message.productID = String(object.productID);
                if (object.surcharge != null)
                    if ($util.Long)
                        (message.surcharge = $util.Long.fromValue(object.surcharge)).unsigned = false;
                    else if (typeof object.surcharge === "string")
                        message.surcharge = parseInt(object.surcharge, 10);
                    else if (typeof object.surcharge === "number")
                        message.surcharge = object.surcharge;
                    else if (typeof object.surcharge === "object")
                        message.surcharge = new $util.LongBits(object.surcharge.low >>> 0, object.surcharge.high >>> 0).toNumber();
                if (object.quantity != null)
                    if ($util.Long)
                        (message.quantity = $util.Long.fromValue(object.quantity)).unsigned = false;
                    else if (typeof object.quantity === "string")
                        message.quantity = parseInt(object.quantity, 10);
                    else if (typeof object.quantity === "number")
                        message.quantity = object.quantity;
                    else if (typeof object.quantity === "object")
                        message.quantity = new $util.LongBits(object.quantity.low >>> 0, object.quantity.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Sku message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Listing.Item.Sku
             * @static
             * @param {Listing.Item.Sku} message Sku
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sku.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.variantCombo = [];
                if (options.defaults) {
                    object.productID = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.surcharge = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.surcharge = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.quantity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.quantity = options.longs === String ? "0" : 0;
                }
                if (message.variantCombo && message.variantCombo.length) {
                    object.variantCombo = [];
                    for (var j = 0; j < message.variantCombo.length; ++j)
                        object.variantCombo[j] = message.variantCombo[j];
                }
                if (message.productID != null && message.hasOwnProperty("productID"))
                    object.productID = message.productID;
                if (message.surcharge != null && message.hasOwnProperty("surcharge"))
                    if (typeof message.surcharge === "number")
                        object.surcharge = options.longs === String ? String(message.surcharge) : message.surcharge;
                    else
                        object.surcharge = options.longs === String ? $util.Long.prototype.toString.call(message.surcharge) : options.longs === Number ? new $util.LongBits(message.surcharge.low >>> 0, message.surcharge.high >>> 0).toNumber() : message.surcharge;
                if (message.quantity != null && message.hasOwnProperty("quantity"))
                    if (typeof message.quantity === "number")
                        object.quantity = options.longs === String ? String(message.quantity) : message.quantity;
                    else
                        object.quantity = options.longs === String ? $util.Long.prototype.toString.call(message.quantity) : options.longs === Number ? new $util.LongBits(message.quantity.low >>> 0, message.quantity.high >>> 0).toNumber() : message.quantity;
                return object;
            };

            /**
             * Converts this Sku to JSON.
             * @function toJSON
             * @memberof Listing.Item.Sku
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sku.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Sku;
        })();

        return Item;
    })();

    Listing.ShippingOption = (function() {

        /**
         * Properties of a ShippingOption.
         * @memberof Listing
         * @interface IShippingOption
         * @property {string|null} [name] ShippingOption name
         * @property {Listing.ShippingOption.ShippingType|null} [type] ShippingOption type
         * @property {Array.<CountryCode>|null} [regions] ShippingOption regions
         * @property {Array.<Listing.ShippingOption.IService>|null} [services] ShippingOption services
         */

        /**
         * Constructs a new ShippingOption.
         * @memberof Listing
         * @classdesc Represents a ShippingOption.
         * @implements IShippingOption
         * @constructor
         * @param {Listing.IShippingOption=} [properties] Properties to set
         */
        function ShippingOption(properties) {
            this.regions = [];
            this.services = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShippingOption name.
         * @member {string} name
         * @memberof Listing.ShippingOption
         * @instance
         */
        ShippingOption.prototype.name = "";

        /**
         * ShippingOption type.
         * @member {Listing.ShippingOption.ShippingType} type
         * @memberof Listing.ShippingOption
         * @instance
         */
        ShippingOption.prototype.type = 0;

        /**
         * ShippingOption regions.
         * @member {Array.<CountryCode>} regions
         * @memberof Listing.ShippingOption
         * @instance
         */
        ShippingOption.prototype.regions = $util.emptyArray;

        /**
         * ShippingOption services.
         * @member {Array.<Listing.ShippingOption.IService>} services
         * @memberof Listing.ShippingOption
         * @instance
         */
        ShippingOption.prototype.services = $util.emptyArray;

        /**
         * Creates a new ShippingOption instance using the specified properties.
         * @function create
         * @memberof Listing.ShippingOption
         * @static
         * @param {Listing.IShippingOption=} [properties] Properties to set
         * @returns {Listing.ShippingOption} ShippingOption instance
         */
        ShippingOption.create = function create(properties) {
            return new ShippingOption(properties);
        };

        /**
         * Encodes the specified ShippingOption message. Does not implicitly {@link Listing.ShippingOption.verify|verify} messages.
         * @function encode
         * @memberof Listing.ShippingOption
         * @static
         * @param {Listing.IShippingOption} message ShippingOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShippingOption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.regions != null && message.regions.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.regions.length; ++i)
                    writer.int32(message.regions[i]);
                writer.ldelim();
            }
            if (message.services != null && message.services.length)
                for (var i = 0; i < message.services.length; ++i)
                    $root.Listing.ShippingOption.Service.encode(message.services[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ShippingOption message, length delimited. Does not implicitly {@link Listing.ShippingOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Listing.ShippingOption
         * @static
         * @param {Listing.IShippingOption} message ShippingOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShippingOption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShippingOption message from the specified reader or buffer.
         * @function decode
         * @memberof Listing.ShippingOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Listing.ShippingOption} ShippingOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShippingOption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing.ShippingOption();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    if (!(message.regions && message.regions.length))
                        message.regions = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.regions.push(reader.int32());
                    } else
                        message.regions.push(reader.int32());
                    break;
                case 5:
                    if (!(message.services && message.services.length))
                        message.services = [];
                    message.services.push($root.Listing.ShippingOption.Service.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShippingOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Listing.ShippingOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Listing.ShippingOption} ShippingOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShippingOption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShippingOption message.
         * @function verify
         * @memberof Listing.ShippingOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShippingOption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.regions != null && message.hasOwnProperty("regions")) {
                if (!Array.isArray(message.regions))
                    return "regions: array expected";
                for (var i = 0; i < message.regions.length; ++i)
                    switch (message.regions[i]) {
                    default:
                        return "regions: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 58:
                    case 59:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 74:
                    case 75:
                    case 76:
                    case 77:
                    case 78:
                    case 79:
                    case 80:
                    case 81:
                    case 82:
                    case 83:
                    case 84:
                    case 85:
                    case 86:
                    case 87:
                    case 88:
                    case 89:
                    case 90:
                    case 91:
                    case 92:
                    case 93:
                    case 94:
                    case 95:
                    case 96:
                    case 97:
                    case 98:
                    case 99:
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 105:
                    case 106:
                    case 107:
                    case 108:
                    case 109:
                    case 110:
                    case 111:
                    case 112:
                    case 113:
                    case 114:
                    case 115:
                    case 116:
                    case 117:
                    case 118:
                    case 119:
                    case 120:
                    case 121:
                    case 122:
                    case 123:
                    case 124:
                    case 125:
                    case 126:
                    case 127:
                    case 128:
                    case 129:
                    case 130:
                    case 131:
                    case 132:
                    case 133:
                    case 134:
                    case 135:
                    case 136:
                    case 137:
                    case 138:
                    case 139:
                    case 140:
                    case 141:
                    case 142:
                    case 143:
                    case 144:
                    case 145:
                    case 146:
                    case 147:
                    case 148:
                    case 149:
                    case 150:
                    case 151:
                    case 152:
                    case 153:
                    case 154:
                    case 155:
                    case 156:
                    case 157:
                    case 158:
                    case 159:
                    case 160:
                    case 161:
                    case 162:
                    case 163:
                    case 164:
                    case 165:
                    case 166:
                    case 167:
                    case 168:
                    case 169:
                    case 170:
                    case 171:
                    case 172:
                    case 173:
                    case 174:
                    case 175:
                    case 176:
                    case 177:
                    case 178:
                    case 179:
                    case 180:
                    case 181:
                    case 182:
                    case 183:
                    case 184:
                    case 185:
                    case 186:
                    case 187:
                    case 188:
                    case 189:
                    case 190:
                    case 191:
                    case 192:
                    case 193:
                    case 194:
                    case 195:
                    case 196:
                    case 197:
                    case 198:
                    case 199:
                    case 200:
                    case 201:
                    case 202:
                    case 203:
                    case 204:
                    case 205:
                    case 206:
                    case 207:
                    case 208:
                    case 209:
                    case 210:
                    case 211:
                    case 212:
                    case 213:
                    case 214:
                    case 215:
                    case 216:
                    case 217:
                    case 218:
                    case 219:
                    case 220:
                    case 221:
                    case 222:
                    case 223:
                    case 224:
                    case 225:
                    case 226:
                    case 227:
                    case 228:
                    case 229:
                    case 230:
                    case 231:
                    case 232:
                    case 233:
                    case 234:
                    case 235:
                    case 236:
                    case 237:
                    case 238:
                    case 239:
                    case 240:
                    case 241:
                    case 242:
                    case 243:
                    case 244:
                    case 245:
                    case 246:
                    case 500:
                    case 501:
                    case 502:
                    case 503:
                    case 504:
                    case 505:
                    case 506:
                    case 507:
                    case 508:
                        break;
                    }
            }
            if (message.services != null && message.hasOwnProperty("services")) {
                if (!Array.isArray(message.services))
                    return "services: array expected";
                for (var i = 0; i < message.services.length; ++i) {
                    var error = $root.Listing.ShippingOption.Service.verify(message.services[i]);
                    if (error)
                        return "services." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ShippingOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Listing.ShippingOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Listing.ShippingOption} ShippingOption
         */
        ShippingOption.fromObject = function fromObject(object) {
            if (object instanceof $root.Listing.ShippingOption)
                return object;
            var message = new $root.Listing.ShippingOption();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            case "LOCAL_PICKUP":
            case 0:
                message.type = 0;
                break;
            case "FIXED_PRICE":
            case 1:
                message.type = 1;
                break;
            }
            if (object.regions) {
                if (!Array.isArray(object.regions))
                    throw TypeError(".Listing.ShippingOption.regions: array expected");
                message.regions = [];
                for (var i = 0; i < object.regions.length; ++i)
                    switch (object.regions[i]) {
                    default:
                    case "NA":
                    case 0:
                        message.regions[i] = 0;
                        break;
                    case "AFGHANISTAN":
                    case 1:
                        message.regions[i] = 1;
                        break;
                    case "ALAND_ISLANDS":
                    case 2:
                        message.regions[i] = 2;
                        break;
                    case "ALBANIA":
                    case 3:
                        message.regions[i] = 3;
                        break;
                    case "ALGERIA":
                    case 4:
                        message.regions[i] = 4;
                        break;
                    case "AMERICAN_SAMOA":
                    case 5:
                        message.regions[i] = 5;
                        break;
                    case "ANDORRA":
                    case 6:
                        message.regions[i] = 6;
                        break;
                    case "ANGOLA":
                    case 7:
                        message.regions[i] = 7;
                        break;
                    case "ANGUILLA":
                    case 8:
                        message.regions[i] = 8;
                        break;
                    case "ANTIGUA":
                    case 9:
                        message.regions[i] = 9;
                        break;
                    case "ARGENTINA":
                    case 10:
                        message.regions[i] = 10;
                        break;
                    case "ARMENIA":
                    case 11:
                        message.regions[i] = 11;
                        break;
                    case "ARUBA":
                    case 12:
                        message.regions[i] = 12;
                        break;
                    case "AUSTRALIA":
                    case 13:
                        message.regions[i] = 13;
                        break;
                    case "AUSTRIA":
                    case 14:
                        message.regions[i] = 14;
                        break;
                    case "AZERBAIJAN":
                    case 15:
                        message.regions[i] = 15;
                        break;
                    case "BAHAMAS":
                    case 16:
                        message.regions[i] = 16;
                        break;
                    case "BAHRAIN":
                    case 17:
                        message.regions[i] = 17;
                        break;
                    case "BANGLADESH":
                    case 18:
                        message.regions[i] = 18;
                        break;
                    case "BARBADOS":
                    case 19:
                        message.regions[i] = 19;
                        break;
                    case "BELARUS":
                    case 20:
                        message.regions[i] = 20;
                        break;
                    case "BELGIUM":
                    case 21:
                        message.regions[i] = 21;
                        break;
                    case "BELIZE":
                    case 22:
                        message.regions[i] = 22;
                        break;
                    case "BENIN":
                    case 23:
                        message.regions[i] = 23;
                        break;
                    case "BERMUDA":
                    case 24:
                        message.regions[i] = 24;
                        break;
                    case "BHUTAN":
                    case 25:
                        message.regions[i] = 25;
                        break;
                    case "BOLIVIA":
                    case 26:
                        message.regions[i] = 26;
                        break;
                    case "BONAIRE_SINT_EUSTATIUS_SABA":
                    case 27:
                        message.regions[i] = 27;
                        break;
                    case "BOSNIA":
                    case 28:
                        message.regions[i] = 28;
                        break;
                    case "BOTSWANA":
                    case 29:
                        message.regions[i] = 29;
                        break;
                    case "BOUVET_ISLAND":
                    case 30:
                        message.regions[i] = 30;
                        break;
                    case "BRAZIL":
                    case 31:
                        message.regions[i] = 31;
                        break;
                    case "BRITISH_INDIAN_OCEAN_TERRITORY":
                    case 32:
                        message.regions[i] = 32;
                        break;
                    case "BRUNEI_DARUSSALAM":
                    case 33:
                        message.regions[i] = 33;
                        break;
                    case "BULGARIA":
                    case 34:
                        message.regions[i] = 34;
                        break;
                    case "BURKINA_FASO":
                    case 35:
                        message.regions[i] = 35;
                        break;
                    case "BURUNDI":
                    case 36:
                        message.regions[i] = 36;
                        break;
                    case "CABO_VERDE":
                    case 37:
                        message.regions[i] = 37;
                        break;
                    case "CAMBODIA":
                    case 38:
                        message.regions[i] = 38;
                        break;
                    case "CAMEROON":
                    case 39:
                        message.regions[i] = 39;
                        break;
                    case "CANADA":
                    case 40:
                        message.regions[i] = 40;
                        break;
                    case "CAYMAN_ISLANDS":
                    case 41:
                        message.regions[i] = 41;
                        break;
                    case "CENTRAL_AFRICAN_REPUBLIC":
                    case 42:
                        message.regions[i] = 42;
                        break;
                    case "CHAD":
                    case 43:
                        message.regions[i] = 43;
                        break;
                    case "CHILE":
                    case 44:
                        message.regions[i] = 44;
                        break;
                    case "CHINA":
                    case 45:
                        message.regions[i] = 45;
                        break;
                    case "CHRISTMAS_ISLAND":
                    case 46:
                        message.regions[i] = 46;
                        break;
                    case "COCOS_ISLANDS":
                    case 47:
                        message.regions[i] = 47;
                        break;
                    case "COLOMBIA":
                    case 48:
                        message.regions[i] = 48;
                        break;
                    case "COMOROS":
                    case 49:
                        message.regions[i] = 49;
                        break;
                    case "CONGO_REPUBLIC":
                    case 50:
                        message.regions[i] = 50;
                        break;
                    case "CONGO":
                    case 51:
                        message.regions[i] = 51;
                        break;
                    case "COOK_ISLANDS":
                    case 52:
                        message.regions[i] = 52;
                        break;
                    case "COSTA_RICA":
                    case 53:
                        message.regions[i] = 53;
                        break;
                    case "COTE_DIVOIRE":
                    case 54:
                        message.regions[i] = 54;
                        break;
                    case "CROATIA":
                    case 55:
                        message.regions[i] = 55;
                        break;
                    case "CUBA":
                    case 56:
                        message.regions[i] = 56;
                        break;
                    case "CURACAO":
                    case 57:
                        message.regions[i] = 57;
                        break;
                    case "CYPRUS":
                    case 58:
                        message.regions[i] = 58;
                        break;
                    case "CZECH_REPUBLIC":
                    case 59:
                        message.regions[i] = 59;
                        break;
                    case "DENMARK":
                    case 60:
                        message.regions[i] = 60;
                        break;
                    case "DJIBOUTI":
                    case 61:
                        message.regions[i] = 61;
                        break;
                    case "DOMINICA":
                    case 62:
                        message.regions[i] = 62;
                        break;
                    case "DOMINICAN_REPUBLIC":
                    case 63:
                        message.regions[i] = 63;
                        break;
                    case "ECUADOR":
                    case 64:
                        message.regions[i] = 64;
                        break;
                    case "EGYPT":
                    case 65:
                        message.regions[i] = 65;
                        break;
                    case "EL_SALVADOR":
                    case 66:
                        message.regions[i] = 66;
                        break;
                    case "EQUATORIAL_GUINEA":
                    case 67:
                        message.regions[i] = 67;
                        break;
                    case "ERITREA":
                    case 68:
                        message.regions[i] = 68;
                        break;
                    case "ESTONIA":
                    case 69:
                        message.regions[i] = 69;
                        break;
                    case "ETHIOPIA":
                    case 70:
                        message.regions[i] = 70;
                        break;
                    case "FALKLAND_ISLANDS":
                    case 71:
                        message.regions[i] = 71;
                        break;
                    case "FAROE_ISLANDS":
                    case 72:
                        message.regions[i] = 72;
                        break;
                    case "FIJI":
                    case 73:
                        message.regions[i] = 73;
                        break;
                    case "FINLAND":
                    case 74:
                        message.regions[i] = 74;
                        break;
                    case "FRANCE":
                    case 75:
                        message.regions[i] = 75;
                        break;
                    case "FRENCH_GUIANA":
                    case 76:
                        message.regions[i] = 76;
                        break;
                    case "FRENCH_POLYNESIA":
                    case 77:
                        message.regions[i] = 77;
                        break;
                    case "FRENCH_SOUTHERN_TERRITORIES":
                    case 78:
                        message.regions[i] = 78;
                        break;
                    case "GABON":
                    case 79:
                        message.regions[i] = 79;
                        break;
                    case "GAMBIA":
                    case 80:
                        message.regions[i] = 80;
                        break;
                    case "GEORGIA":
                    case 81:
                        message.regions[i] = 81;
                        break;
                    case "GERMANY":
                    case 82:
                        message.regions[i] = 82;
                        break;
                    case "GHANA":
                    case 83:
                        message.regions[i] = 83;
                        break;
                    case "GIBRALTAR":
                    case 84:
                        message.regions[i] = 84;
                        break;
                    case "GREECE":
                    case 85:
                        message.regions[i] = 85;
                        break;
                    case "GREENLAND":
                    case 86:
                        message.regions[i] = 86;
                        break;
                    case "GRENADA":
                    case 87:
                        message.regions[i] = 87;
                        break;
                    case "GUADELOUPE":
                    case 88:
                        message.regions[i] = 88;
                        break;
                    case "GUAM":
                    case 89:
                        message.regions[i] = 89;
                        break;
                    case "GUATEMALA":
                    case 90:
                        message.regions[i] = 90;
                        break;
                    case "GUERNSEY":
                    case 91:
                        message.regions[i] = 91;
                        break;
                    case "GUINEA":
                    case 92:
                        message.regions[i] = 92;
                        break;
                    case "GUINEA_BISSAU":
                    case 93:
                        message.regions[i] = 93;
                        break;
                    case "GUYANA":
                    case 94:
                        message.regions[i] = 94;
                        break;
                    case "HAITI":
                    case 95:
                        message.regions[i] = 95;
                        break;
                    case "HEARD_ISLAND":
                    case 96:
                        message.regions[i] = 96;
                        break;
                    case "HOLY_SEE":
                    case 97:
                        message.regions[i] = 97;
                        break;
                    case "HONDURAS":
                    case 98:
                        message.regions[i] = 98;
                        break;
                    case "HONG_KONG":
                    case 99:
                        message.regions[i] = 99;
                        break;
                    case "HUNGARY":
                    case 100:
                        message.regions[i] = 100;
                        break;
                    case "ICELAND":
                    case 101:
                        message.regions[i] = 101;
                        break;
                    case "INDIA":
                    case 102:
                        message.regions[i] = 102;
                        break;
                    case "INDONESIA":
                    case 103:
                        message.regions[i] = 103;
                        break;
                    case "IRAN":
                    case 104:
                        message.regions[i] = 104;
                        break;
                    case "IRAQ":
                    case 105:
                        message.regions[i] = 105;
                        break;
                    case "IRELAND":
                    case 106:
                        message.regions[i] = 106;
                        break;
                    case "ISLE_OF_MAN":
                    case 107:
                        message.regions[i] = 107;
                        break;
                    case "ISRAEL":
                    case 108:
                        message.regions[i] = 108;
                        break;
                    case "ITALY":
                    case 109:
                        message.regions[i] = 109;
                        break;
                    case "JAMAICA":
                    case 110:
                        message.regions[i] = 110;
                        break;
                    case "JAPAN":
                    case 111:
                        message.regions[i] = 111;
                        break;
                    case "JERSEY":
                    case 112:
                        message.regions[i] = 112;
                        break;
                    case "JORDAN":
                    case 113:
                        message.regions[i] = 113;
                        break;
                    case "KAZAKHSTAN":
                    case 114:
                        message.regions[i] = 114;
                        break;
                    case "KENYA":
                    case 115:
                        message.regions[i] = 115;
                        break;
                    case "KIRIBATI":
                    case 116:
                        message.regions[i] = 116;
                        break;
                    case "NORTH_KOREA":
                    case 117:
                        message.regions[i] = 117;
                        break;
                    case "SOUTH_KOREA":
                    case 118:
                        message.regions[i] = 118;
                        break;
                    case "KUWAIT":
                    case 119:
                        message.regions[i] = 119;
                        break;
                    case "KYRGYZSTAN":
                    case 120:
                        message.regions[i] = 120;
                        break;
                    case "LAO":
                    case 121:
                        message.regions[i] = 121;
                        break;
                    case "LATVIA":
                    case 122:
                        message.regions[i] = 122;
                        break;
                    case "LEBANON":
                    case 123:
                        message.regions[i] = 123;
                        break;
                    case "LESOTHO":
                    case 124:
                        message.regions[i] = 124;
                        break;
                    case "LIBERIA":
                    case 125:
                        message.regions[i] = 125;
                        break;
                    case "LIBYA":
                    case 126:
                        message.regions[i] = 126;
                        break;
                    case "LIECHTENSTEIN":
                    case 127:
                        message.regions[i] = 127;
                        break;
                    case "LITHUANIA":
                    case 128:
                        message.regions[i] = 128;
                        break;
                    case "LUXEMBOURG":
                    case 129:
                        message.regions[i] = 129;
                        break;
                    case "MACAO":
                    case 130:
                        message.regions[i] = 130;
                        break;
                    case "MACEDONIA":
                    case 131:
                        message.regions[i] = 131;
                        break;
                    case "MADAGASCAR":
                    case 132:
                        message.regions[i] = 132;
                        break;
                    case "MALAWI":
                    case 133:
                        message.regions[i] = 133;
                        break;
                    case "MALAYSIA":
                    case 134:
                        message.regions[i] = 134;
                        break;
                    case "MALDIVES":
                    case 135:
                        message.regions[i] = 135;
                        break;
                    case "MALI":
                    case 136:
                        message.regions[i] = 136;
                        break;
                    case "MALTA":
                    case 137:
                        message.regions[i] = 137;
                        break;
                    case "MARSHALL_ISLANDS":
                    case 138:
                        message.regions[i] = 138;
                        break;
                    case "MARTINIQUE":
                    case 139:
                        message.regions[i] = 139;
                        break;
                    case "MAURITANIA":
                    case 140:
                        message.regions[i] = 140;
                        break;
                    case "MAURITIUS":
                    case 141:
                        message.regions[i] = 141;
                        break;
                    case "MAYOTTE":
                    case 142:
                        message.regions[i] = 142;
                        break;
                    case "MEXICO":
                    case 143:
                        message.regions[i] = 143;
                        break;
                    case "MICRONESIA":
                    case 144:
                        message.regions[i] = 144;
                        break;
                    case "MOLDOVA":
                    case 145:
                        message.regions[i] = 145;
                        break;
                    case "MONACO":
                    case 146:
                        message.regions[i] = 146;
                        break;
                    case "MONGOLIA":
                    case 147:
                        message.regions[i] = 147;
                        break;
                    case "MONTENEGRO":
                    case 148:
                        message.regions[i] = 148;
                        break;
                    case "MONTSERRAT":
                    case 149:
                        message.regions[i] = 149;
                        break;
                    case "MOROCCO":
                    case 150:
                        message.regions[i] = 150;
                        break;
                    case "MOZAMBIQUE":
                    case 151:
                        message.regions[i] = 151;
                        break;
                    case "MYANMAR":
                    case 152:
                        message.regions[i] = 152;
                        break;
                    case "NAMIBIA":
                    case 153:
                        message.regions[i] = 153;
                        break;
                    case "NAURU":
                    case 154:
                        message.regions[i] = 154;
                        break;
                    case "NEPAL":
                    case 155:
                        message.regions[i] = 155;
                        break;
                    case "NETHERLANDS":
                    case 156:
                        message.regions[i] = 156;
                        break;
                    case "NEW_CALEDONIA":
                    case 157:
                        message.regions[i] = 157;
                        break;
                    case "NEW_ZEALAND":
                    case 158:
                        message.regions[i] = 158;
                        break;
                    case "NICARAGUA":
                    case 159:
                        message.regions[i] = 159;
                        break;
                    case "NIGER":
                    case 160:
                        message.regions[i] = 160;
                        break;
                    case "NIGERIA":
                    case 161:
                        message.regions[i] = 161;
                        break;
                    case "NIUE":
                    case 162:
                        message.regions[i] = 162;
                        break;
                    case "NORFOLK_ISLAND":
                    case 163:
                        message.regions[i] = 163;
                        break;
                    case "NORTHERN_MARIANA_ISLANDS":
                    case 164:
                        message.regions[i] = 164;
                        break;
                    case "NORWAY":
                    case 165:
                        message.regions[i] = 165;
                        break;
                    case "OMAN":
                    case 166:
                        message.regions[i] = 166;
                        break;
                    case "PAKISTAN":
                    case 167:
                        message.regions[i] = 167;
                        break;
                    case "PALAU":
                    case 168:
                        message.regions[i] = 168;
                        break;
                    case "PANAMA":
                    case 169:
                        message.regions[i] = 169;
                        break;
                    case "PAPUA_NEW_GUINEA":
                    case 170:
                        message.regions[i] = 170;
                        break;
                    case "PARAGUAY":
                    case 171:
                        message.regions[i] = 171;
                        break;
                    case "PERU":
                    case 172:
                        message.regions[i] = 172;
                        break;
                    case "PHILIPPINES":
                    case 173:
                        message.regions[i] = 173;
                        break;
                    case "PITCAIRN":
                    case 174:
                        message.regions[i] = 174;
                        break;
                    case "POLAND":
                    case 175:
                        message.regions[i] = 175;
                        break;
                    case "PORTUGAL":
                    case 176:
                        message.regions[i] = 176;
                        break;
                    case "PUERTO_RICO":
                    case 177:
                        message.regions[i] = 177;
                        break;
                    case "QATAR":
                    case 178:
                        message.regions[i] = 178;
                        break;
                    case "REUNION":
                    case 179:
                        message.regions[i] = 179;
                        break;
                    case "ROMANIA":
                    case 180:
                        message.regions[i] = 180;
                        break;
                    case "RUSSIA":
                    case 181:
                        message.regions[i] = 181;
                        break;
                    case "RWANDA":
                    case 182:
                        message.regions[i] = 182;
                        break;
                    case "SAINT_BARTHELEMY":
                    case 183:
                        message.regions[i] = 183;
                        break;
                    case "SAINT_HELENA":
                    case 184:
                        message.regions[i] = 184;
                        break;
                    case "SAINT_KITTS":
                    case 185:
                        message.regions[i] = 185;
                        break;
                    case "SAINT_LUCIA":
                    case 186:
                        message.regions[i] = 186;
                        break;
                    case "SAINT_MARTIN":
                    case 187:
                        message.regions[i] = 187;
                        break;
                    case "SAINT_PIERRE":
                    case 188:
                        message.regions[i] = 188;
                        break;
                    case "SAINT_VINCENT":
                    case 189:
                        message.regions[i] = 189;
                        break;
                    case "SAMOA":
                    case 190:
                        message.regions[i] = 190;
                        break;
                    case "SAN_MARINO":
                    case 191:
                        message.regions[i] = 191;
                        break;
                    case "SAO_TOME":
                    case 192:
                        message.regions[i] = 192;
                        break;
                    case "SAUDI_ARABIA":
                    case 193:
                        message.regions[i] = 193;
                        break;
                    case "SENEGAL":
                    case 194:
                        message.regions[i] = 194;
                        break;
                    case "SERBIA":
                    case 195:
                        message.regions[i] = 195;
                        break;
                    case "SEYCHELLES":
                    case 196:
                        message.regions[i] = 196;
                        break;
                    case "SIERRA_LEONE":
                    case 197:
                        message.regions[i] = 197;
                        break;
                    case "SINGAPORE":
                    case 198:
                        message.regions[i] = 198;
                        break;
                    case "SINT_MAARTEN":
                    case 199:
                        message.regions[i] = 199;
                        break;
                    case "SUCRE":
                    case 200:
                        message.regions[i] = 200;
                        break;
                    case "SLOVAKIA":
                    case 201:
                        message.regions[i] = 201;
                        break;
                    case "SLOVENIA":
                    case 202:
                        message.regions[i] = 202;
                        break;
                    case "SOLOMON_ISLANDS":
                    case 203:
                        message.regions[i] = 203;
                        break;
                    case "SOMALIA":
                    case 204:
                        message.regions[i] = 204;
                        break;
                    case "SOUTH_AFRICA":
                    case 205:
                        message.regions[i] = 205;
                        break;
                    case "SOUTH_SUDAN":
                    case 206:
                        message.regions[i] = 206;
                        break;
                    case "SPAIN":
                    case 207:
                        message.regions[i] = 207;
                        break;
                    case "SRI_LANKA":
                    case 208:
                        message.regions[i] = 208;
                        break;
                    case "SUDAN":
                    case 209:
                        message.regions[i] = 209;
                        break;
                    case "SURINAME":
                    case 210:
                        message.regions[i] = 210;
                        break;
                    case "SVALBARD":
                    case 211:
                        message.regions[i] = 211;
                        break;
                    case "SWAZILAND":
                    case 212:
                        message.regions[i] = 212;
                        break;
                    case "SWEDEN":
                    case 213:
                        message.regions[i] = 213;
                        break;
                    case "SWITZERLAND":
                    case 214:
                        message.regions[i] = 214;
                        break;
                    case "SYRIAN_ARAB_REPUBLIC":
                    case 215:
                        message.regions[i] = 215;
                        break;
                    case "TAIWAN":
                    case 216:
                        message.regions[i] = 216;
                        break;
                    case "TAJIKISTAN":
                    case 217:
                        message.regions[i] = 217;
                        break;
                    case "TANZANIA":
                    case 218:
                        message.regions[i] = 218;
                        break;
                    case "THAILAND":
                    case 219:
                        message.regions[i] = 219;
                        break;
                    case "TIMOR_LESTE":
                    case 220:
                        message.regions[i] = 220;
                        break;
                    case "TOGO":
                    case 221:
                        message.regions[i] = 221;
                        break;
                    case "TOKELAU":
                    case 222:
                        message.regions[i] = 222;
                        break;
                    case "TONGA":
                    case 223:
                        message.regions[i] = 223;
                        break;
                    case "TRINIDAD":
                    case 224:
                        message.regions[i] = 224;
                        break;
                    case "TUNISIA":
                    case 225:
                        message.regions[i] = 225;
                        break;
                    case "TURKEY":
                    case 226:
                        message.regions[i] = 226;
                        break;
                    case "TURKMENISTAN":
                    case 227:
                        message.regions[i] = 227;
                        break;
                    case "TURKS_AND_CAICOS_ISLANDS":
                    case 228:
                        message.regions[i] = 228;
                        break;
                    case "TUVALU":
                    case 229:
                        message.regions[i] = 229;
                        break;
                    case "UGANDA":
                    case 230:
                        message.regions[i] = 230;
                        break;
                    case "UKRAINE":
                    case 231:
                        message.regions[i] = 231;
                        break;
                    case "UNITED_ARAB_EMIRATES":
                    case 232:
                        message.regions[i] = 232;
                        break;
                    case "UNITED_KINGDOM":
                    case 233:
                        message.regions[i] = 233;
                        break;
                    case "UNITED_STATES":
                    case 234:
                        message.regions[i] = 234;
                        break;
                    case "URUGUAY":
                    case 235:
                        message.regions[i] = 235;
                        break;
                    case "UZBEKISTAN":
                    case 236:
                        message.regions[i] = 236;
                        break;
                    case "VANUATU":
                    case 237:
                        message.regions[i] = 237;
                        break;
                    case "VENEZUELA":
                    case 238:
                        message.regions[i] = 238;
                        break;
                    case "VIETNAM":
                    case 239:
                        message.regions[i] = 239;
                        break;
                    case "VIRGIN_ISLANDS_BRITISH":
                    case 240:
                        message.regions[i] = 240;
                        break;
                    case "VIRGIN_ISLANDS_US":
                    case 241:
                        message.regions[i] = 241;
                        break;
                    case "WALLIS_AND_FUTUNA":
                    case 242:
                        message.regions[i] = 242;
                        break;
                    case "WESTERN_SAHARA":
                    case 243:
                        message.regions[i] = 243;
                        break;
                    case "YEMEN":
                    case 244:
                        message.regions[i] = 244;
                        break;
                    case "ZAMBIA":
                    case 245:
                        message.regions[i] = 245;
                        break;
                    case "ZIMBABWE":
                    case 246:
                        message.regions[i] = 246;
                        break;
                    case "ALL":
                    case 500:
                        message.regions[i] = 500;
                        break;
                    case "AFRICA":
                    case 501:
                        message.regions[i] = 501;
                        break;
                    case "ASIA":
                    case 502:
                        message.regions[i] = 502;
                        break;
                    case "CENTRAL_AMERICA":
                    case 503:
                        message.regions[i] = 503;
                        break;
                    case "EUROPE":
                    case 504:
                        message.regions[i] = 504;
                        break;
                    case "MIDDLE_EAST":
                    case 505:
                        message.regions[i] = 505;
                        break;
                    case "NORTH_AMERICA":
                    case 506:
                        message.regions[i] = 506;
                        break;
                    case "SOUTH_AMERICA":
                    case 507:
                        message.regions[i] = 507;
                        break;
                    case "OCEANIA":
                    case 508:
                        message.regions[i] = 508;
                        break;
                    }
            }
            if (object.services) {
                if (!Array.isArray(object.services))
                    throw TypeError(".Listing.ShippingOption.services: array expected");
                message.services = [];
                for (var i = 0; i < object.services.length; ++i) {
                    if (typeof object.services[i] !== "object")
                        throw TypeError(".Listing.ShippingOption.services: object expected");
                    message.services[i] = $root.Listing.ShippingOption.Service.fromObject(object.services[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ShippingOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Listing.ShippingOption
         * @static
         * @param {Listing.ShippingOption} message ShippingOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShippingOption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.regions = [];
                object.services = [];
            }
            if (options.defaults) {
                object.name = "";
                object.type = options.enums === String ? "LOCAL_PICKUP" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.Listing.ShippingOption.ShippingType[message.type] : message.type;
            if (message.regions && message.regions.length) {
                object.regions = [];
                for (var j = 0; j < message.regions.length; ++j)
                    object.regions[j] = options.enums === String ? $root.CountryCode[message.regions[j]] : message.regions[j];
            }
            if (message.services && message.services.length) {
                object.services = [];
                for (var j = 0; j < message.services.length; ++j)
                    object.services[j] = $root.Listing.ShippingOption.Service.toObject(message.services[j], options);
            }
            return object;
        };

        /**
         * Converts this ShippingOption to JSON.
         * @function toJSON
         * @memberof Listing.ShippingOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShippingOption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ShippingType enum.
         * @name Listing.ShippingOption.ShippingType
         * @enum {string}
         * @property {number} LOCAL_PICKUP=0 LOCAL_PICKUP value
         * @property {number} FIXED_PRICE=1 FIXED_PRICE value
         */
        ShippingOption.ShippingType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LOCAL_PICKUP"] = 0;
            values[valuesById[1] = "FIXED_PRICE"] = 1;
            return values;
        })();

        ShippingOption.Service = (function() {

            /**
             * Properties of a Service.
             * @memberof Listing.ShippingOption
             * @interface IService
             * @property {string|null} [name] Service name
             * @property {number|Long|null} [price] Service price
             * @property {string|null} [estimatedDelivery] Service estimatedDelivery
             * @property {number|Long|null} [additionalItemPrice] Service additionalItemPrice
             */

            /**
             * Constructs a new Service.
             * @memberof Listing.ShippingOption
             * @classdesc Represents a Service.
             * @implements IService
             * @constructor
             * @param {Listing.ShippingOption.IService=} [properties] Properties to set
             */
            function Service(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Service name.
             * @member {string} name
             * @memberof Listing.ShippingOption.Service
             * @instance
             */
            Service.prototype.name = "";

            /**
             * Service price.
             * @member {number|Long} price
             * @memberof Listing.ShippingOption.Service
             * @instance
             */
            Service.prototype.price = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Service estimatedDelivery.
             * @member {string} estimatedDelivery
             * @memberof Listing.ShippingOption.Service
             * @instance
             */
            Service.prototype.estimatedDelivery = "";

            /**
             * Service additionalItemPrice.
             * @member {number|Long} additionalItemPrice
             * @memberof Listing.ShippingOption.Service
             * @instance
             */
            Service.prototype.additionalItemPrice = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Service instance using the specified properties.
             * @function create
             * @memberof Listing.ShippingOption.Service
             * @static
             * @param {Listing.ShippingOption.IService=} [properties] Properties to set
             * @returns {Listing.ShippingOption.Service} Service instance
             */
            Service.create = function create(properties) {
                return new Service(properties);
            };

            /**
             * Encodes the specified Service message. Does not implicitly {@link Listing.ShippingOption.Service.verify|verify} messages.
             * @function encode
             * @memberof Listing.ShippingOption.Service
             * @static
             * @param {Listing.ShippingOption.IService} message Service message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Service.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.price != null && message.hasOwnProperty("price"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.price);
                if (message.estimatedDelivery != null && message.hasOwnProperty("estimatedDelivery"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.estimatedDelivery);
                if (message.additionalItemPrice != null && message.hasOwnProperty("additionalItemPrice"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.additionalItemPrice);
                return writer;
            };

            /**
             * Encodes the specified Service message, length delimited. Does not implicitly {@link Listing.ShippingOption.Service.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Listing.ShippingOption.Service
             * @static
             * @param {Listing.ShippingOption.IService} message Service message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Service.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Service message from the specified reader or buffer.
             * @function decode
             * @memberof Listing.ShippingOption.Service
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Listing.ShippingOption.Service} Service
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Service.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing.ShippingOption.Service();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.price = reader.uint64();
                        break;
                    case 3:
                        message.estimatedDelivery = reader.string();
                        break;
                    case 4:
                        message.additionalItemPrice = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Service message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Listing.ShippingOption.Service
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Listing.ShippingOption.Service} Service
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Service.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Service message.
             * @function verify
             * @memberof Listing.ShippingOption.Service
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Service.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.price != null && message.hasOwnProperty("price"))
                    if (!$util.isInteger(message.price) && !(message.price && $util.isInteger(message.price.low) && $util.isInteger(message.price.high)))
                        return "price: integer|Long expected";
                if (message.estimatedDelivery != null && message.hasOwnProperty("estimatedDelivery"))
                    if (!$util.isString(message.estimatedDelivery))
                        return "estimatedDelivery: string expected";
                if (message.additionalItemPrice != null && message.hasOwnProperty("additionalItemPrice"))
                    if (!$util.isInteger(message.additionalItemPrice) && !(message.additionalItemPrice && $util.isInteger(message.additionalItemPrice.low) && $util.isInteger(message.additionalItemPrice.high)))
                        return "additionalItemPrice: integer|Long expected";
                return null;
            };

            /**
             * Creates a Service message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Listing.ShippingOption.Service
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Listing.ShippingOption.Service} Service
             */
            Service.fromObject = function fromObject(object) {
                if (object instanceof $root.Listing.ShippingOption.Service)
                    return object;
                var message = new $root.Listing.ShippingOption.Service();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.price != null)
                    if ($util.Long)
                        (message.price = $util.Long.fromValue(object.price)).unsigned = true;
                    else if (typeof object.price === "string")
                        message.price = parseInt(object.price, 10);
                    else if (typeof object.price === "number")
                        message.price = object.price;
                    else if (typeof object.price === "object")
                        message.price = new $util.LongBits(object.price.low >>> 0, object.price.high >>> 0).toNumber(true);
                if (object.estimatedDelivery != null)
                    message.estimatedDelivery = String(object.estimatedDelivery);
                if (object.additionalItemPrice != null)
                    if ($util.Long)
                        (message.additionalItemPrice = $util.Long.fromValue(object.additionalItemPrice)).unsigned = true;
                    else if (typeof object.additionalItemPrice === "string")
                        message.additionalItemPrice = parseInt(object.additionalItemPrice, 10);
                    else if (typeof object.additionalItemPrice === "number")
                        message.additionalItemPrice = object.additionalItemPrice;
                    else if (typeof object.additionalItemPrice === "object")
                        message.additionalItemPrice = new $util.LongBits(object.additionalItemPrice.low >>> 0, object.additionalItemPrice.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Service message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Listing.ShippingOption.Service
             * @static
             * @param {Listing.ShippingOption.Service} message Service
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Service.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.price = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.price = options.longs === String ? "0" : 0;
                    object.estimatedDelivery = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.additionalItemPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.additionalItemPrice = options.longs === String ? "0" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.price != null && message.hasOwnProperty("price"))
                    if (typeof message.price === "number")
                        object.price = options.longs === String ? String(message.price) : message.price;
                    else
                        object.price = options.longs === String ? $util.Long.prototype.toString.call(message.price) : options.longs === Number ? new $util.LongBits(message.price.low >>> 0, message.price.high >>> 0).toNumber(true) : message.price;
                if (message.estimatedDelivery != null && message.hasOwnProperty("estimatedDelivery"))
                    object.estimatedDelivery = message.estimatedDelivery;
                if (message.additionalItemPrice != null && message.hasOwnProperty("additionalItemPrice"))
                    if (typeof message.additionalItemPrice === "number")
                        object.additionalItemPrice = options.longs === String ? String(message.additionalItemPrice) : message.additionalItemPrice;
                    else
                        object.additionalItemPrice = options.longs === String ? $util.Long.prototype.toString.call(message.additionalItemPrice) : options.longs === Number ? new $util.LongBits(message.additionalItemPrice.low >>> 0, message.additionalItemPrice.high >>> 0).toNumber(true) : message.additionalItemPrice;
                return object;
            };

            /**
             * Converts this Service to JSON.
             * @function toJSON
             * @memberof Listing.ShippingOption.Service
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Service.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Service;
        })();

        return ShippingOption;
    })();

    Listing.Tax = (function() {

        /**
         * Properties of a Tax.
         * @memberof Listing
         * @interface ITax
         * @property {string|null} [taxType] Tax taxType
         * @property {Array.<CountryCode>|null} [taxRegions] Tax taxRegions
         * @property {boolean|null} [taxShipping] Tax taxShipping
         * @property {number|null} [percentage] Tax percentage
         */

        /**
         * Constructs a new Tax.
         * @memberof Listing
         * @classdesc Represents a Tax.
         * @implements ITax
         * @constructor
         * @param {Listing.ITax=} [properties] Properties to set
         */
        function Tax(properties) {
            this.taxRegions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tax taxType.
         * @member {string} taxType
         * @memberof Listing.Tax
         * @instance
         */
        Tax.prototype.taxType = "";

        /**
         * Tax taxRegions.
         * @member {Array.<CountryCode>} taxRegions
         * @memberof Listing.Tax
         * @instance
         */
        Tax.prototype.taxRegions = $util.emptyArray;

        /**
         * Tax taxShipping.
         * @member {boolean} taxShipping
         * @memberof Listing.Tax
         * @instance
         */
        Tax.prototype.taxShipping = false;

        /**
         * Tax percentage.
         * @member {number} percentage
         * @memberof Listing.Tax
         * @instance
         */
        Tax.prototype.percentage = 0;

        /**
         * Creates a new Tax instance using the specified properties.
         * @function create
         * @memberof Listing.Tax
         * @static
         * @param {Listing.ITax=} [properties] Properties to set
         * @returns {Listing.Tax} Tax instance
         */
        Tax.create = function create(properties) {
            return new Tax(properties);
        };

        /**
         * Encodes the specified Tax message. Does not implicitly {@link Listing.Tax.verify|verify} messages.
         * @function encode
         * @memberof Listing.Tax
         * @static
         * @param {Listing.ITax} message Tax message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tax.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taxType != null && message.hasOwnProperty("taxType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.taxType);
            if (message.taxRegions != null && message.taxRegions.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.taxRegions.length; ++i)
                    writer.int32(message.taxRegions[i]);
                writer.ldelim();
            }
            if (message.taxShipping != null && message.hasOwnProperty("taxShipping"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.taxShipping);
            if (message.percentage != null && message.hasOwnProperty("percentage"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.percentage);
            return writer;
        };

        /**
         * Encodes the specified Tax message, length delimited. Does not implicitly {@link Listing.Tax.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Listing.Tax
         * @static
         * @param {Listing.ITax} message Tax message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tax.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tax message from the specified reader or buffer.
         * @function decode
         * @memberof Listing.Tax
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Listing.Tax} Tax
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tax.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing.Tax();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taxType = reader.string();
                    break;
                case 2:
                    if (!(message.taxRegions && message.taxRegions.length))
                        message.taxRegions = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.taxRegions.push(reader.int32());
                    } else
                        message.taxRegions.push(reader.int32());
                    break;
                case 3:
                    message.taxShipping = reader.bool();
                    break;
                case 4:
                    message.percentage = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Tax message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Listing.Tax
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Listing.Tax} Tax
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tax.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tax message.
         * @function verify
         * @memberof Listing.Tax
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tax.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taxType != null && message.hasOwnProperty("taxType"))
                if (!$util.isString(message.taxType))
                    return "taxType: string expected";
            if (message.taxRegions != null && message.hasOwnProperty("taxRegions")) {
                if (!Array.isArray(message.taxRegions))
                    return "taxRegions: array expected";
                for (var i = 0; i < message.taxRegions.length; ++i)
                    switch (message.taxRegions[i]) {
                    default:
                        return "taxRegions: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 58:
                    case 59:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 74:
                    case 75:
                    case 76:
                    case 77:
                    case 78:
                    case 79:
                    case 80:
                    case 81:
                    case 82:
                    case 83:
                    case 84:
                    case 85:
                    case 86:
                    case 87:
                    case 88:
                    case 89:
                    case 90:
                    case 91:
                    case 92:
                    case 93:
                    case 94:
                    case 95:
                    case 96:
                    case 97:
                    case 98:
                    case 99:
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 105:
                    case 106:
                    case 107:
                    case 108:
                    case 109:
                    case 110:
                    case 111:
                    case 112:
                    case 113:
                    case 114:
                    case 115:
                    case 116:
                    case 117:
                    case 118:
                    case 119:
                    case 120:
                    case 121:
                    case 122:
                    case 123:
                    case 124:
                    case 125:
                    case 126:
                    case 127:
                    case 128:
                    case 129:
                    case 130:
                    case 131:
                    case 132:
                    case 133:
                    case 134:
                    case 135:
                    case 136:
                    case 137:
                    case 138:
                    case 139:
                    case 140:
                    case 141:
                    case 142:
                    case 143:
                    case 144:
                    case 145:
                    case 146:
                    case 147:
                    case 148:
                    case 149:
                    case 150:
                    case 151:
                    case 152:
                    case 153:
                    case 154:
                    case 155:
                    case 156:
                    case 157:
                    case 158:
                    case 159:
                    case 160:
                    case 161:
                    case 162:
                    case 163:
                    case 164:
                    case 165:
                    case 166:
                    case 167:
                    case 168:
                    case 169:
                    case 170:
                    case 171:
                    case 172:
                    case 173:
                    case 174:
                    case 175:
                    case 176:
                    case 177:
                    case 178:
                    case 179:
                    case 180:
                    case 181:
                    case 182:
                    case 183:
                    case 184:
                    case 185:
                    case 186:
                    case 187:
                    case 188:
                    case 189:
                    case 190:
                    case 191:
                    case 192:
                    case 193:
                    case 194:
                    case 195:
                    case 196:
                    case 197:
                    case 198:
                    case 199:
                    case 200:
                    case 201:
                    case 202:
                    case 203:
                    case 204:
                    case 205:
                    case 206:
                    case 207:
                    case 208:
                    case 209:
                    case 210:
                    case 211:
                    case 212:
                    case 213:
                    case 214:
                    case 215:
                    case 216:
                    case 217:
                    case 218:
                    case 219:
                    case 220:
                    case 221:
                    case 222:
                    case 223:
                    case 224:
                    case 225:
                    case 226:
                    case 227:
                    case 228:
                    case 229:
                    case 230:
                    case 231:
                    case 232:
                    case 233:
                    case 234:
                    case 235:
                    case 236:
                    case 237:
                    case 238:
                    case 239:
                    case 240:
                    case 241:
                    case 242:
                    case 243:
                    case 244:
                    case 245:
                    case 246:
                    case 500:
                    case 501:
                    case 502:
                    case 503:
                    case 504:
                    case 505:
                    case 506:
                    case 507:
                    case 508:
                        break;
                    }
            }
            if (message.taxShipping != null && message.hasOwnProperty("taxShipping"))
                if (typeof message.taxShipping !== "boolean")
                    return "taxShipping: boolean expected";
            if (message.percentage != null && message.hasOwnProperty("percentage"))
                if (typeof message.percentage !== "number")
                    return "percentage: number expected";
            return null;
        };

        /**
         * Creates a Tax message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Listing.Tax
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Listing.Tax} Tax
         */
        Tax.fromObject = function fromObject(object) {
            if (object instanceof $root.Listing.Tax)
                return object;
            var message = new $root.Listing.Tax();
            if (object.taxType != null)
                message.taxType = String(object.taxType);
            if (object.taxRegions) {
                if (!Array.isArray(object.taxRegions))
                    throw TypeError(".Listing.Tax.taxRegions: array expected");
                message.taxRegions = [];
                for (var i = 0; i < object.taxRegions.length; ++i)
                    switch (object.taxRegions[i]) {
                    default:
                    case "NA":
                    case 0:
                        message.taxRegions[i] = 0;
                        break;
                    case "AFGHANISTAN":
                    case 1:
                        message.taxRegions[i] = 1;
                        break;
                    case "ALAND_ISLANDS":
                    case 2:
                        message.taxRegions[i] = 2;
                        break;
                    case "ALBANIA":
                    case 3:
                        message.taxRegions[i] = 3;
                        break;
                    case "ALGERIA":
                    case 4:
                        message.taxRegions[i] = 4;
                        break;
                    case "AMERICAN_SAMOA":
                    case 5:
                        message.taxRegions[i] = 5;
                        break;
                    case "ANDORRA":
                    case 6:
                        message.taxRegions[i] = 6;
                        break;
                    case "ANGOLA":
                    case 7:
                        message.taxRegions[i] = 7;
                        break;
                    case "ANGUILLA":
                    case 8:
                        message.taxRegions[i] = 8;
                        break;
                    case "ANTIGUA":
                    case 9:
                        message.taxRegions[i] = 9;
                        break;
                    case "ARGENTINA":
                    case 10:
                        message.taxRegions[i] = 10;
                        break;
                    case "ARMENIA":
                    case 11:
                        message.taxRegions[i] = 11;
                        break;
                    case "ARUBA":
                    case 12:
                        message.taxRegions[i] = 12;
                        break;
                    case "AUSTRALIA":
                    case 13:
                        message.taxRegions[i] = 13;
                        break;
                    case "AUSTRIA":
                    case 14:
                        message.taxRegions[i] = 14;
                        break;
                    case "AZERBAIJAN":
                    case 15:
                        message.taxRegions[i] = 15;
                        break;
                    case "BAHAMAS":
                    case 16:
                        message.taxRegions[i] = 16;
                        break;
                    case "BAHRAIN":
                    case 17:
                        message.taxRegions[i] = 17;
                        break;
                    case "BANGLADESH":
                    case 18:
                        message.taxRegions[i] = 18;
                        break;
                    case "BARBADOS":
                    case 19:
                        message.taxRegions[i] = 19;
                        break;
                    case "BELARUS":
                    case 20:
                        message.taxRegions[i] = 20;
                        break;
                    case "BELGIUM":
                    case 21:
                        message.taxRegions[i] = 21;
                        break;
                    case "BELIZE":
                    case 22:
                        message.taxRegions[i] = 22;
                        break;
                    case "BENIN":
                    case 23:
                        message.taxRegions[i] = 23;
                        break;
                    case "BERMUDA":
                    case 24:
                        message.taxRegions[i] = 24;
                        break;
                    case "BHUTAN":
                    case 25:
                        message.taxRegions[i] = 25;
                        break;
                    case "BOLIVIA":
                    case 26:
                        message.taxRegions[i] = 26;
                        break;
                    case "BONAIRE_SINT_EUSTATIUS_SABA":
                    case 27:
                        message.taxRegions[i] = 27;
                        break;
                    case "BOSNIA":
                    case 28:
                        message.taxRegions[i] = 28;
                        break;
                    case "BOTSWANA":
                    case 29:
                        message.taxRegions[i] = 29;
                        break;
                    case "BOUVET_ISLAND":
                    case 30:
                        message.taxRegions[i] = 30;
                        break;
                    case "BRAZIL":
                    case 31:
                        message.taxRegions[i] = 31;
                        break;
                    case "BRITISH_INDIAN_OCEAN_TERRITORY":
                    case 32:
                        message.taxRegions[i] = 32;
                        break;
                    case "BRUNEI_DARUSSALAM":
                    case 33:
                        message.taxRegions[i] = 33;
                        break;
                    case "BULGARIA":
                    case 34:
                        message.taxRegions[i] = 34;
                        break;
                    case "BURKINA_FASO":
                    case 35:
                        message.taxRegions[i] = 35;
                        break;
                    case "BURUNDI":
                    case 36:
                        message.taxRegions[i] = 36;
                        break;
                    case "CABO_VERDE":
                    case 37:
                        message.taxRegions[i] = 37;
                        break;
                    case "CAMBODIA":
                    case 38:
                        message.taxRegions[i] = 38;
                        break;
                    case "CAMEROON":
                    case 39:
                        message.taxRegions[i] = 39;
                        break;
                    case "CANADA":
                    case 40:
                        message.taxRegions[i] = 40;
                        break;
                    case "CAYMAN_ISLANDS":
                    case 41:
                        message.taxRegions[i] = 41;
                        break;
                    case "CENTRAL_AFRICAN_REPUBLIC":
                    case 42:
                        message.taxRegions[i] = 42;
                        break;
                    case "CHAD":
                    case 43:
                        message.taxRegions[i] = 43;
                        break;
                    case "CHILE":
                    case 44:
                        message.taxRegions[i] = 44;
                        break;
                    case "CHINA":
                    case 45:
                        message.taxRegions[i] = 45;
                        break;
                    case "CHRISTMAS_ISLAND":
                    case 46:
                        message.taxRegions[i] = 46;
                        break;
                    case "COCOS_ISLANDS":
                    case 47:
                        message.taxRegions[i] = 47;
                        break;
                    case "COLOMBIA":
                    case 48:
                        message.taxRegions[i] = 48;
                        break;
                    case "COMOROS":
                    case 49:
                        message.taxRegions[i] = 49;
                        break;
                    case "CONGO_REPUBLIC":
                    case 50:
                        message.taxRegions[i] = 50;
                        break;
                    case "CONGO":
                    case 51:
                        message.taxRegions[i] = 51;
                        break;
                    case "COOK_ISLANDS":
                    case 52:
                        message.taxRegions[i] = 52;
                        break;
                    case "COSTA_RICA":
                    case 53:
                        message.taxRegions[i] = 53;
                        break;
                    case "COTE_DIVOIRE":
                    case 54:
                        message.taxRegions[i] = 54;
                        break;
                    case "CROATIA":
                    case 55:
                        message.taxRegions[i] = 55;
                        break;
                    case "CUBA":
                    case 56:
                        message.taxRegions[i] = 56;
                        break;
                    case "CURACAO":
                    case 57:
                        message.taxRegions[i] = 57;
                        break;
                    case "CYPRUS":
                    case 58:
                        message.taxRegions[i] = 58;
                        break;
                    case "CZECH_REPUBLIC":
                    case 59:
                        message.taxRegions[i] = 59;
                        break;
                    case "DENMARK":
                    case 60:
                        message.taxRegions[i] = 60;
                        break;
                    case "DJIBOUTI":
                    case 61:
                        message.taxRegions[i] = 61;
                        break;
                    case "DOMINICA":
                    case 62:
                        message.taxRegions[i] = 62;
                        break;
                    case "DOMINICAN_REPUBLIC":
                    case 63:
                        message.taxRegions[i] = 63;
                        break;
                    case "ECUADOR":
                    case 64:
                        message.taxRegions[i] = 64;
                        break;
                    case "EGYPT":
                    case 65:
                        message.taxRegions[i] = 65;
                        break;
                    case "EL_SALVADOR":
                    case 66:
                        message.taxRegions[i] = 66;
                        break;
                    case "EQUATORIAL_GUINEA":
                    case 67:
                        message.taxRegions[i] = 67;
                        break;
                    case "ERITREA":
                    case 68:
                        message.taxRegions[i] = 68;
                        break;
                    case "ESTONIA":
                    case 69:
                        message.taxRegions[i] = 69;
                        break;
                    case "ETHIOPIA":
                    case 70:
                        message.taxRegions[i] = 70;
                        break;
                    case "FALKLAND_ISLANDS":
                    case 71:
                        message.taxRegions[i] = 71;
                        break;
                    case "FAROE_ISLANDS":
                    case 72:
                        message.taxRegions[i] = 72;
                        break;
                    case "FIJI":
                    case 73:
                        message.taxRegions[i] = 73;
                        break;
                    case "FINLAND":
                    case 74:
                        message.taxRegions[i] = 74;
                        break;
                    case "FRANCE":
                    case 75:
                        message.taxRegions[i] = 75;
                        break;
                    case "FRENCH_GUIANA":
                    case 76:
                        message.taxRegions[i] = 76;
                        break;
                    case "FRENCH_POLYNESIA":
                    case 77:
                        message.taxRegions[i] = 77;
                        break;
                    case "FRENCH_SOUTHERN_TERRITORIES":
                    case 78:
                        message.taxRegions[i] = 78;
                        break;
                    case "GABON":
                    case 79:
                        message.taxRegions[i] = 79;
                        break;
                    case "GAMBIA":
                    case 80:
                        message.taxRegions[i] = 80;
                        break;
                    case "GEORGIA":
                    case 81:
                        message.taxRegions[i] = 81;
                        break;
                    case "GERMANY":
                    case 82:
                        message.taxRegions[i] = 82;
                        break;
                    case "GHANA":
                    case 83:
                        message.taxRegions[i] = 83;
                        break;
                    case "GIBRALTAR":
                    case 84:
                        message.taxRegions[i] = 84;
                        break;
                    case "GREECE":
                    case 85:
                        message.taxRegions[i] = 85;
                        break;
                    case "GREENLAND":
                    case 86:
                        message.taxRegions[i] = 86;
                        break;
                    case "GRENADA":
                    case 87:
                        message.taxRegions[i] = 87;
                        break;
                    case "GUADELOUPE":
                    case 88:
                        message.taxRegions[i] = 88;
                        break;
                    case "GUAM":
                    case 89:
                        message.taxRegions[i] = 89;
                        break;
                    case "GUATEMALA":
                    case 90:
                        message.taxRegions[i] = 90;
                        break;
                    case "GUERNSEY":
                    case 91:
                        message.taxRegions[i] = 91;
                        break;
                    case "GUINEA":
                    case 92:
                        message.taxRegions[i] = 92;
                        break;
                    case "GUINEA_BISSAU":
                    case 93:
                        message.taxRegions[i] = 93;
                        break;
                    case "GUYANA":
                    case 94:
                        message.taxRegions[i] = 94;
                        break;
                    case "HAITI":
                    case 95:
                        message.taxRegions[i] = 95;
                        break;
                    case "HEARD_ISLAND":
                    case 96:
                        message.taxRegions[i] = 96;
                        break;
                    case "HOLY_SEE":
                    case 97:
                        message.taxRegions[i] = 97;
                        break;
                    case "HONDURAS":
                    case 98:
                        message.taxRegions[i] = 98;
                        break;
                    case "HONG_KONG":
                    case 99:
                        message.taxRegions[i] = 99;
                        break;
                    case "HUNGARY":
                    case 100:
                        message.taxRegions[i] = 100;
                        break;
                    case "ICELAND":
                    case 101:
                        message.taxRegions[i] = 101;
                        break;
                    case "INDIA":
                    case 102:
                        message.taxRegions[i] = 102;
                        break;
                    case "INDONESIA":
                    case 103:
                        message.taxRegions[i] = 103;
                        break;
                    case "IRAN":
                    case 104:
                        message.taxRegions[i] = 104;
                        break;
                    case "IRAQ":
                    case 105:
                        message.taxRegions[i] = 105;
                        break;
                    case "IRELAND":
                    case 106:
                        message.taxRegions[i] = 106;
                        break;
                    case "ISLE_OF_MAN":
                    case 107:
                        message.taxRegions[i] = 107;
                        break;
                    case "ISRAEL":
                    case 108:
                        message.taxRegions[i] = 108;
                        break;
                    case "ITALY":
                    case 109:
                        message.taxRegions[i] = 109;
                        break;
                    case "JAMAICA":
                    case 110:
                        message.taxRegions[i] = 110;
                        break;
                    case "JAPAN":
                    case 111:
                        message.taxRegions[i] = 111;
                        break;
                    case "JERSEY":
                    case 112:
                        message.taxRegions[i] = 112;
                        break;
                    case "JORDAN":
                    case 113:
                        message.taxRegions[i] = 113;
                        break;
                    case "KAZAKHSTAN":
                    case 114:
                        message.taxRegions[i] = 114;
                        break;
                    case "KENYA":
                    case 115:
                        message.taxRegions[i] = 115;
                        break;
                    case "KIRIBATI":
                    case 116:
                        message.taxRegions[i] = 116;
                        break;
                    case "NORTH_KOREA":
                    case 117:
                        message.taxRegions[i] = 117;
                        break;
                    case "SOUTH_KOREA":
                    case 118:
                        message.taxRegions[i] = 118;
                        break;
                    case "KUWAIT":
                    case 119:
                        message.taxRegions[i] = 119;
                        break;
                    case "KYRGYZSTAN":
                    case 120:
                        message.taxRegions[i] = 120;
                        break;
                    case "LAO":
                    case 121:
                        message.taxRegions[i] = 121;
                        break;
                    case "LATVIA":
                    case 122:
                        message.taxRegions[i] = 122;
                        break;
                    case "LEBANON":
                    case 123:
                        message.taxRegions[i] = 123;
                        break;
                    case "LESOTHO":
                    case 124:
                        message.taxRegions[i] = 124;
                        break;
                    case "LIBERIA":
                    case 125:
                        message.taxRegions[i] = 125;
                        break;
                    case "LIBYA":
                    case 126:
                        message.taxRegions[i] = 126;
                        break;
                    case "LIECHTENSTEIN":
                    case 127:
                        message.taxRegions[i] = 127;
                        break;
                    case "LITHUANIA":
                    case 128:
                        message.taxRegions[i] = 128;
                        break;
                    case "LUXEMBOURG":
                    case 129:
                        message.taxRegions[i] = 129;
                        break;
                    case "MACAO":
                    case 130:
                        message.taxRegions[i] = 130;
                        break;
                    case "MACEDONIA":
                    case 131:
                        message.taxRegions[i] = 131;
                        break;
                    case "MADAGASCAR":
                    case 132:
                        message.taxRegions[i] = 132;
                        break;
                    case "MALAWI":
                    case 133:
                        message.taxRegions[i] = 133;
                        break;
                    case "MALAYSIA":
                    case 134:
                        message.taxRegions[i] = 134;
                        break;
                    case "MALDIVES":
                    case 135:
                        message.taxRegions[i] = 135;
                        break;
                    case "MALI":
                    case 136:
                        message.taxRegions[i] = 136;
                        break;
                    case "MALTA":
                    case 137:
                        message.taxRegions[i] = 137;
                        break;
                    case "MARSHALL_ISLANDS":
                    case 138:
                        message.taxRegions[i] = 138;
                        break;
                    case "MARTINIQUE":
                    case 139:
                        message.taxRegions[i] = 139;
                        break;
                    case "MAURITANIA":
                    case 140:
                        message.taxRegions[i] = 140;
                        break;
                    case "MAURITIUS":
                    case 141:
                        message.taxRegions[i] = 141;
                        break;
                    case "MAYOTTE":
                    case 142:
                        message.taxRegions[i] = 142;
                        break;
                    case "MEXICO":
                    case 143:
                        message.taxRegions[i] = 143;
                        break;
                    case "MICRONESIA":
                    case 144:
                        message.taxRegions[i] = 144;
                        break;
                    case "MOLDOVA":
                    case 145:
                        message.taxRegions[i] = 145;
                        break;
                    case "MONACO":
                    case 146:
                        message.taxRegions[i] = 146;
                        break;
                    case "MONGOLIA":
                    case 147:
                        message.taxRegions[i] = 147;
                        break;
                    case "MONTENEGRO":
                    case 148:
                        message.taxRegions[i] = 148;
                        break;
                    case "MONTSERRAT":
                    case 149:
                        message.taxRegions[i] = 149;
                        break;
                    case "MOROCCO":
                    case 150:
                        message.taxRegions[i] = 150;
                        break;
                    case "MOZAMBIQUE":
                    case 151:
                        message.taxRegions[i] = 151;
                        break;
                    case "MYANMAR":
                    case 152:
                        message.taxRegions[i] = 152;
                        break;
                    case "NAMIBIA":
                    case 153:
                        message.taxRegions[i] = 153;
                        break;
                    case "NAURU":
                    case 154:
                        message.taxRegions[i] = 154;
                        break;
                    case "NEPAL":
                    case 155:
                        message.taxRegions[i] = 155;
                        break;
                    case "NETHERLANDS":
                    case 156:
                        message.taxRegions[i] = 156;
                        break;
                    case "NEW_CALEDONIA":
                    case 157:
                        message.taxRegions[i] = 157;
                        break;
                    case "NEW_ZEALAND":
                    case 158:
                        message.taxRegions[i] = 158;
                        break;
                    case "NICARAGUA":
                    case 159:
                        message.taxRegions[i] = 159;
                        break;
                    case "NIGER":
                    case 160:
                        message.taxRegions[i] = 160;
                        break;
                    case "NIGERIA":
                    case 161:
                        message.taxRegions[i] = 161;
                        break;
                    case "NIUE":
                    case 162:
                        message.taxRegions[i] = 162;
                        break;
                    case "NORFOLK_ISLAND":
                    case 163:
                        message.taxRegions[i] = 163;
                        break;
                    case "NORTHERN_MARIANA_ISLANDS":
                    case 164:
                        message.taxRegions[i] = 164;
                        break;
                    case "NORWAY":
                    case 165:
                        message.taxRegions[i] = 165;
                        break;
                    case "OMAN":
                    case 166:
                        message.taxRegions[i] = 166;
                        break;
                    case "PAKISTAN":
                    case 167:
                        message.taxRegions[i] = 167;
                        break;
                    case "PALAU":
                    case 168:
                        message.taxRegions[i] = 168;
                        break;
                    case "PANAMA":
                    case 169:
                        message.taxRegions[i] = 169;
                        break;
                    case "PAPUA_NEW_GUINEA":
                    case 170:
                        message.taxRegions[i] = 170;
                        break;
                    case "PARAGUAY":
                    case 171:
                        message.taxRegions[i] = 171;
                        break;
                    case "PERU":
                    case 172:
                        message.taxRegions[i] = 172;
                        break;
                    case "PHILIPPINES":
                    case 173:
                        message.taxRegions[i] = 173;
                        break;
                    case "PITCAIRN":
                    case 174:
                        message.taxRegions[i] = 174;
                        break;
                    case "POLAND":
                    case 175:
                        message.taxRegions[i] = 175;
                        break;
                    case "PORTUGAL":
                    case 176:
                        message.taxRegions[i] = 176;
                        break;
                    case "PUERTO_RICO":
                    case 177:
                        message.taxRegions[i] = 177;
                        break;
                    case "QATAR":
                    case 178:
                        message.taxRegions[i] = 178;
                        break;
                    case "REUNION":
                    case 179:
                        message.taxRegions[i] = 179;
                        break;
                    case "ROMANIA":
                    case 180:
                        message.taxRegions[i] = 180;
                        break;
                    case "RUSSIA":
                    case 181:
                        message.taxRegions[i] = 181;
                        break;
                    case "RWANDA":
                    case 182:
                        message.taxRegions[i] = 182;
                        break;
                    case "SAINT_BARTHELEMY":
                    case 183:
                        message.taxRegions[i] = 183;
                        break;
                    case "SAINT_HELENA":
                    case 184:
                        message.taxRegions[i] = 184;
                        break;
                    case "SAINT_KITTS":
                    case 185:
                        message.taxRegions[i] = 185;
                        break;
                    case "SAINT_LUCIA":
                    case 186:
                        message.taxRegions[i] = 186;
                        break;
                    case "SAINT_MARTIN":
                    case 187:
                        message.taxRegions[i] = 187;
                        break;
                    case "SAINT_PIERRE":
                    case 188:
                        message.taxRegions[i] = 188;
                        break;
                    case "SAINT_VINCENT":
                    case 189:
                        message.taxRegions[i] = 189;
                        break;
                    case "SAMOA":
                    case 190:
                        message.taxRegions[i] = 190;
                        break;
                    case "SAN_MARINO":
                    case 191:
                        message.taxRegions[i] = 191;
                        break;
                    case "SAO_TOME":
                    case 192:
                        message.taxRegions[i] = 192;
                        break;
                    case "SAUDI_ARABIA":
                    case 193:
                        message.taxRegions[i] = 193;
                        break;
                    case "SENEGAL":
                    case 194:
                        message.taxRegions[i] = 194;
                        break;
                    case "SERBIA":
                    case 195:
                        message.taxRegions[i] = 195;
                        break;
                    case "SEYCHELLES":
                    case 196:
                        message.taxRegions[i] = 196;
                        break;
                    case "SIERRA_LEONE":
                    case 197:
                        message.taxRegions[i] = 197;
                        break;
                    case "SINGAPORE":
                    case 198:
                        message.taxRegions[i] = 198;
                        break;
                    case "SINT_MAARTEN":
                    case 199:
                        message.taxRegions[i] = 199;
                        break;
                    case "SUCRE":
                    case 200:
                        message.taxRegions[i] = 200;
                        break;
                    case "SLOVAKIA":
                    case 201:
                        message.taxRegions[i] = 201;
                        break;
                    case "SLOVENIA":
                    case 202:
                        message.taxRegions[i] = 202;
                        break;
                    case "SOLOMON_ISLANDS":
                    case 203:
                        message.taxRegions[i] = 203;
                        break;
                    case "SOMALIA":
                    case 204:
                        message.taxRegions[i] = 204;
                        break;
                    case "SOUTH_AFRICA":
                    case 205:
                        message.taxRegions[i] = 205;
                        break;
                    case "SOUTH_SUDAN":
                    case 206:
                        message.taxRegions[i] = 206;
                        break;
                    case "SPAIN":
                    case 207:
                        message.taxRegions[i] = 207;
                        break;
                    case "SRI_LANKA":
                    case 208:
                        message.taxRegions[i] = 208;
                        break;
                    case "SUDAN":
                    case 209:
                        message.taxRegions[i] = 209;
                        break;
                    case "SURINAME":
                    case 210:
                        message.taxRegions[i] = 210;
                        break;
                    case "SVALBARD":
                    case 211:
                        message.taxRegions[i] = 211;
                        break;
                    case "SWAZILAND":
                    case 212:
                        message.taxRegions[i] = 212;
                        break;
                    case "SWEDEN":
                    case 213:
                        message.taxRegions[i] = 213;
                        break;
                    case "SWITZERLAND":
                    case 214:
                        message.taxRegions[i] = 214;
                        break;
                    case "SYRIAN_ARAB_REPUBLIC":
                    case 215:
                        message.taxRegions[i] = 215;
                        break;
                    case "TAIWAN":
                    case 216:
                        message.taxRegions[i] = 216;
                        break;
                    case "TAJIKISTAN":
                    case 217:
                        message.taxRegions[i] = 217;
                        break;
                    case "TANZANIA":
                    case 218:
                        message.taxRegions[i] = 218;
                        break;
                    case "THAILAND":
                    case 219:
                        message.taxRegions[i] = 219;
                        break;
                    case "TIMOR_LESTE":
                    case 220:
                        message.taxRegions[i] = 220;
                        break;
                    case "TOGO":
                    case 221:
                        message.taxRegions[i] = 221;
                        break;
                    case "TOKELAU":
                    case 222:
                        message.taxRegions[i] = 222;
                        break;
                    case "TONGA":
                    case 223:
                        message.taxRegions[i] = 223;
                        break;
                    case "TRINIDAD":
                    case 224:
                        message.taxRegions[i] = 224;
                        break;
                    case "TUNISIA":
                    case 225:
                        message.taxRegions[i] = 225;
                        break;
                    case "TURKEY":
                    case 226:
                        message.taxRegions[i] = 226;
                        break;
                    case "TURKMENISTAN":
                    case 227:
                        message.taxRegions[i] = 227;
                        break;
                    case "TURKS_AND_CAICOS_ISLANDS":
                    case 228:
                        message.taxRegions[i] = 228;
                        break;
                    case "TUVALU":
                    case 229:
                        message.taxRegions[i] = 229;
                        break;
                    case "UGANDA":
                    case 230:
                        message.taxRegions[i] = 230;
                        break;
                    case "UKRAINE":
                    case 231:
                        message.taxRegions[i] = 231;
                        break;
                    case "UNITED_ARAB_EMIRATES":
                    case 232:
                        message.taxRegions[i] = 232;
                        break;
                    case "UNITED_KINGDOM":
                    case 233:
                        message.taxRegions[i] = 233;
                        break;
                    case "UNITED_STATES":
                    case 234:
                        message.taxRegions[i] = 234;
                        break;
                    case "URUGUAY":
                    case 235:
                        message.taxRegions[i] = 235;
                        break;
                    case "UZBEKISTAN":
                    case 236:
                        message.taxRegions[i] = 236;
                        break;
                    case "VANUATU":
                    case 237:
                        message.taxRegions[i] = 237;
                        break;
                    case "VENEZUELA":
                    case 238:
                        message.taxRegions[i] = 238;
                        break;
                    case "VIETNAM":
                    case 239:
                        message.taxRegions[i] = 239;
                        break;
                    case "VIRGIN_ISLANDS_BRITISH":
                    case 240:
                        message.taxRegions[i] = 240;
                        break;
                    case "VIRGIN_ISLANDS_US":
                    case 241:
                        message.taxRegions[i] = 241;
                        break;
                    case "WALLIS_AND_FUTUNA":
                    case 242:
                        message.taxRegions[i] = 242;
                        break;
                    case "WESTERN_SAHARA":
                    case 243:
                        message.taxRegions[i] = 243;
                        break;
                    case "YEMEN":
                    case 244:
                        message.taxRegions[i] = 244;
                        break;
                    case "ZAMBIA":
                    case 245:
                        message.taxRegions[i] = 245;
                        break;
                    case "ZIMBABWE":
                    case 246:
                        message.taxRegions[i] = 246;
                        break;
                    case "ALL":
                    case 500:
                        message.taxRegions[i] = 500;
                        break;
                    case "AFRICA":
                    case 501:
                        message.taxRegions[i] = 501;
                        break;
                    case "ASIA":
                    case 502:
                        message.taxRegions[i] = 502;
                        break;
                    case "CENTRAL_AMERICA":
                    case 503:
                        message.taxRegions[i] = 503;
                        break;
                    case "EUROPE":
                    case 504:
                        message.taxRegions[i] = 504;
                        break;
                    case "MIDDLE_EAST":
                    case 505:
                        message.taxRegions[i] = 505;
                        break;
                    case "NORTH_AMERICA":
                    case 506:
                        message.taxRegions[i] = 506;
                        break;
                    case "SOUTH_AMERICA":
                    case 507:
                        message.taxRegions[i] = 507;
                        break;
                    case "OCEANIA":
                    case 508:
                        message.taxRegions[i] = 508;
                        break;
                    }
            }
            if (object.taxShipping != null)
                message.taxShipping = Boolean(object.taxShipping);
            if (object.percentage != null)
                message.percentage = Number(object.percentage);
            return message;
        };

        /**
         * Creates a plain object from a Tax message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Listing.Tax
         * @static
         * @param {Listing.Tax} message Tax
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tax.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.taxRegions = [];
            if (options.defaults) {
                object.taxType = "";
                object.taxShipping = false;
                object.percentage = 0;
            }
            if (message.taxType != null && message.hasOwnProperty("taxType"))
                object.taxType = message.taxType;
            if (message.taxRegions && message.taxRegions.length) {
                object.taxRegions = [];
                for (var j = 0; j < message.taxRegions.length; ++j)
                    object.taxRegions[j] = options.enums === String ? $root.CountryCode[message.taxRegions[j]] : message.taxRegions[j];
            }
            if (message.taxShipping != null && message.hasOwnProperty("taxShipping"))
                object.taxShipping = message.taxShipping;
            if (message.percentage != null && message.hasOwnProperty("percentage"))
                object.percentage = options.json && !isFinite(message.percentage) ? String(message.percentage) : message.percentage;
            return object;
        };

        /**
         * Converts this Tax to JSON.
         * @function toJSON
         * @memberof Listing.Tax
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tax.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tax;
    })();

    Listing.Coupon = (function() {

        /**
         * Properties of a Coupon.
         * @memberof Listing
         * @interface ICoupon
         * @property {string|null} [title] Coupon title
         * @property {string|null} [hash] Coupon hash
         * @property {string|null} [discountCode] Coupon discountCode
         * @property {number|null} [percentDiscount] Coupon percentDiscount
         * @property {number|Long|null} [priceDiscount] Coupon priceDiscount
         */

        /**
         * Constructs a new Coupon.
         * @memberof Listing
         * @classdesc Represents a Coupon.
         * @implements ICoupon
         * @constructor
         * @param {Listing.ICoupon=} [properties] Properties to set
         */
        function Coupon(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Coupon title.
         * @member {string} title
         * @memberof Listing.Coupon
         * @instance
         */
        Coupon.prototype.title = "";

        /**
         * Coupon hash.
         * @member {string} hash
         * @memberof Listing.Coupon
         * @instance
         */
        Coupon.prototype.hash = "";

        /**
         * Coupon discountCode.
         * @member {string} discountCode
         * @memberof Listing.Coupon
         * @instance
         */
        Coupon.prototype.discountCode = "";

        /**
         * Coupon percentDiscount.
         * @member {number} percentDiscount
         * @memberof Listing.Coupon
         * @instance
         */
        Coupon.prototype.percentDiscount = 0;

        /**
         * Coupon priceDiscount.
         * @member {number|Long} priceDiscount
         * @memberof Listing.Coupon
         * @instance
         */
        Coupon.prototype.priceDiscount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Coupon code.
         * @member {"hash"|"discountCode"|undefined} code
         * @memberof Listing.Coupon
         * @instance
         */
        Object.defineProperty(Coupon.prototype, "code", {
            get: $util.oneOfGetter($oneOfFields = ["hash", "discountCode"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Coupon discount.
         * @member {"percentDiscount"|"priceDiscount"|undefined} discount
         * @memberof Listing.Coupon
         * @instance
         */
        Object.defineProperty(Coupon.prototype, "discount", {
            get: $util.oneOfGetter($oneOfFields = ["percentDiscount", "priceDiscount"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Coupon instance using the specified properties.
         * @function create
         * @memberof Listing.Coupon
         * @static
         * @param {Listing.ICoupon=} [properties] Properties to set
         * @returns {Listing.Coupon} Coupon instance
         */
        Coupon.create = function create(properties) {
            return new Coupon(properties);
        };

        /**
         * Encodes the specified Coupon message. Does not implicitly {@link Listing.Coupon.verify|verify} messages.
         * @function encode
         * @memberof Listing.Coupon
         * @static
         * @param {Listing.ICoupon} message Coupon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coupon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hash);
            if (message.discountCode != null && message.hasOwnProperty("discountCode"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.discountCode);
            if (message.percentDiscount != null && message.hasOwnProperty("percentDiscount"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.percentDiscount);
            if (message.priceDiscount != null && message.hasOwnProperty("priceDiscount"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.priceDiscount);
            return writer;
        };

        /**
         * Encodes the specified Coupon message, length delimited. Does not implicitly {@link Listing.Coupon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Listing.Coupon
         * @static
         * @param {Listing.ICoupon} message Coupon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coupon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Coupon message from the specified reader or buffer.
         * @function decode
         * @memberof Listing.Coupon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Listing.Coupon} Coupon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coupon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Listing.Coupon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.hash = reader.string();
                    break;
                case 3:
                    message.discountCode = reader.string();
                    break;
                case 5:
                    message.percentDiscount = reader.float();
                    break;
                case 6:
                    message.priceDiscount = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Coupon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Listing.Coupon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Listing.Coupon} Coupon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coupon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Coupon message.
         * @function verify
         * @memberof Listing.Coupon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Coupon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.hash != null && message.hasOwnProperty("hash")) {
                properties.code = 1;
                if (!$util.isString(message.hash))
                    return "hash: string expected";
            }
            if (message.discountCode != null && message.hasOwnProperty("discountCode")) {
                if (properties.code === 1)
                    return "code: multiple values";
                properties.code = 1;
                if (!$util.isString(message.discountCode))
                    return "discountCode: string expected";
            }
            if (message.percentDiscount != null && message.hasOwnProperty("percentDiscount")) {
                properties.discount = 1;
                if (typeof message.percentDiscount !== "number")
                    return "percentDiscount: number expected";
            }
            if (message.priceDiscount != null && message.hasOwnProperty("priceDiscount")) {
                if (properties.discount === 1)
                    return "discount: multiple values";
                properties.discount = 1;
                if (!$util.isInteger(message.priceDiscount) && !(message.priceDiscount && $util.isInteger(message.priceDiscount.low) && $util.isInteger(message.priceDiscount.high)))
                    return "priceDiscount: integer|Long expected";
            }
            return null;
        };

        /**
         * Creates a Coupon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Listing.Coupon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Listing.Coupon} Coupon
         */
        Coupon.fromObject = function fromObject(object) {
            if (object instanceof $root.Listing.Coupon)
                return object;
            var message = new $root.Listing.Coupon();
            if (object.title != null)
                message.title = String(object.title);
            if (object.hash != null)
                message.hash = String(object.hash);
            if (object.discountCode != null)
                message.discountCode = String(object.discountCode);
            if (object.percentDiscount != null)
                message.percentDiscount = Number(object.percentDiscount);
            if (object.priceDiscount != null)
                if ($util.Long)
                    (message.priceDiscount = $util.Long.fromValue(object.priceDiscount)).unsigned = true;
                else if (typeof object.priceDiscount === "string")
                    message.priceDiscount = parseInt(object.priceDiscount, 10);
                else if (typeof object.priceDiscount === "number")
                    message.priceDiscount = object.priceDiscount;
                else if (typeof object.priceDiscount === "object")
                    message.priceDiscount = new $util.LongBits(object.priceDiscount.low >>> 0, object.priceDiscount.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a Coupon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Listing.Coupon
         * @static
         * @param {Listing.Coupon} message Coupon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Coupon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.title = "";
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.hash != null && message.hasOwnProperty("hash")) {
                object.hash = message.hash;
                if (options.oneofs)
                    object.code = "hash";
            }
            if (message.discountCode != null && message.hasOwnProperty("discountCode")) {
                object.discountCode = message.discountCode;
                if (options.oneofs)
                    object.code = "discountCode";
            }
            if (message.percentDiscount != null && message.hasOwnProperty("percentDiscount")) {
                object.percentDiscount = options.json && !isFinite(message.percentDiscount) ? String(message.percentDiscount) : message.percentDiscount;
                if (options.oneofs)
                    object.discount = "percentDiscount";
            }
            if (message.priceDiscount != null && message.hasOwnProperty("priceDiscount")) {
                if (typeof message.priceDiscount === "number")
                    object.priceDiscount = options.longs === String ? String(message.priceDiscount) : message.priceDiscount;
                else
                    object.priceDiscount = options.longs === String ? $util.Long.prototype.toString.call(message.priceDiscount) : options.longs === Number ? new $util.LongBits(message.priceDiscount.low >>> 0, message.priceDiscount.high >>> 0).toNumber(true) : message.priceDiscount;
                if (options.oneofs)
                    object.discount = "priceDiscount";
            }
            return object;
        };

        /**
         * Converts this Coupon to JSON.
         * @function toJSON
         * @memberof Listing.Coupon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Coupon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Coupon;
    })();

    return Listing;
})();

$root.Order = (function() {

    /**
     * Properties of an Order.
     * @exports IOrder
     * @interface IOrder
     * @property {string|null} [refundAddress] Order refundAddress
     * @property {number|Long|null} [refundFee] Order refundFee
     * @property {Order.IShipping|null} [shipping] Order shipping
     * @property {IID|null} [buyerID] Order buyerID
     * @property {google.protobuf.ITimestamp|null} [timestamp] Order timestamp
     * @property {Array.<Order.IItem>|null} [items] Order items
     * @property {Order.IPayment|null} [payment] Order payment
     * @property {Array.<Uint8Array>|null} [ratingKeys] Order ratingKeys
     * @property {string|null} [alternateContactInfo] Order alternateContactInfo
     * @property {number|null} [version] Order version
     */

    /**
     * Constructs a new Order.
     * @exports Order
     * @classdesc Represents an Order.
     * @implements IOrder
     * @constructor
     * @param {IOrder=} [properties] Properties to set
     */
    function Order(properties) {
        this.items = [];
        this.ratingKeys = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Order refundAddress.
     * @member {string} refundAddress
     * @memberof Order
     * @instance
     */
    Order.prototype.refundAddress = "";

    /**
     * Order refundFee.
     * @member {number|Long} refundFee
     * @memberof Order
     * @instance
     */
    Order.prototype.refundFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Order shipping.
     * @member {Order.IShipping|null|undefined} shipping
     * @memberof Order
     * @instance
     */
    Order.prototype.shipping = null;

    /**
     * Order buyerID.
     * @member {IID|null|undefined} buyerID
     * @memberof Order
     * @instance
     */
    Order.prototype.buyerID = null;

    /**
     * Order timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof Order
     * @instance
     */
    Order.prototype.timestamp = null;

    /**
     * Order items.
     * @member {Array.<Order.IItem>} items
     * @memberof Order
     * @instance
     */
    Order.prototype.items = $util.emptyArray;

    /**
     * Order payment.
     * @member {Order.IPayment|null|undefined} payment
     * @memberof Order
     * @instance
     */
    Order.prototype.payment = null;

    /**
     * Order ratingKeys.
     * @member {Array.<Uint8Array>} ratingKeys
     * @memberof Order
     * @instance
     */
    Order.prototype.ratingKeys = $util.emptyArray;

    /**
     * Order alternateContactInfo.
     * @member {string} alternateContactInfo
     * @memberof Order
     * @instance
     */
    Order.prototype.alternateContactInfo = "";

    /**
     * Order version.
     * @member {number} version
     * @memberof Order
     * @instance
     */
    Order.prototype.version = 0;

    /**
     * Creates a new Order instance using the specified properties.
     * @function create
     * @memberof Order
     * @static
     * @param {IOrder=} [properties] Properties to set
     * @returns {Order} Order instance
     */
    Order.create = function create(properties) {
        return new Order(properties);
    };

    /**
     * Encodes the specified Order message. Does not implicitly {@link Order.verify|verify} messages.
     * @function encode
     * @memberof Order
     * @static
     * @param {IOrder} message Order message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Order.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.refundAddress != null && message.hasOwnProperty("refundAddress"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.refundAddress);
        if (message.refundFee != null && message.hasOwnProperty("refundFee"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.refundFee);
        if (message.shipping != null && message.hasOwnProperty("shipping"))
            $root.Order.Shipping.encode(message.shipping, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.buyerID != null && message.hasOwnProperty("buyerID"))
            $root.ID.encode(message.buyerID, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.items != null && message.items.length)
            for (var i = 0; i < message.items.length; ++i)
                $root.Order.Item.encode(message.items[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.payment != null && message.hasOwnProperty("payment"))
            $root.Order.Payment.encode(message.payment, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.ratingKeys != null && message.ratingKeys.length)
            for (var i = 0; i < message.ratingKeys.length; ++i)
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.ratingKeys[i]);
        if (message.alternateContactInfo != null && message.hasOwnProperty("alternateContactInfo"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.alternateContactInfo);
        if (message.version != null && message.hasOwnProperty("version"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.version);
        return writer;
    };

    /**
     * Encodes the specified Order message, length delimited. Does not implicitly {@link Order.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Order
     * @static
     * @param {IOrder} message Order message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Order.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Order message from the specified reader or buffer.
     * @function decode
     * @memberof Order
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Order} Order
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Order.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Order();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.refundAddress = reader.string();
                break;
            case 2:
                message.refundFee = reader.uint64();
                break;
            case 3:
                message.shipping = $root.Order.Shipping.decode(reader, reader.uint32());
                break;
            case 4:
                message.buyerID = $root.ID.decode(reader, reader.uint32());
                break;
            case 5:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 6:
                if (!(message.items && message.items.length))
                    message.items = [];
                message.items.push($root.Order.Item.decode(reader, reader.uint32()));
                break;
            case 7:
                message.payment = $root.Order.Payment.decode(reader, reader.uint32());
                break;
            case 8:
                if (!(message.ratingKeys && message.ratingKeys.length))
                    message.ratingKeys = [];
                message.ratingKeys.push(reader.bytes());
                break;
            case 9:
                message.alternateContactInfo = reader.string();
                break;
            case 10:
                message.version = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Order message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Order
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Order} Order
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Order.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Order message.
     * @function verify
     * @memberof Order
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Order.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.refundAddress != null && message.hasOwnProperty("refundAddress"))
            if (!$util.isString(message.refundAddress))
                return "refundAddress: string expected";
        if (message.refundFee != null && message.hasOwnProperty("refundFee"))
            if (!$util.isInteger(message.refundFee) && !(message.refundFee && $util.isInteger(message.refundFee.low) && $util.isInteger(message.refundFee.high)))
                return "refundFee: integer|Long expected";
        if (message.shipping != null && message.hasOwnProperty("shipping")) {
            var error = $root.Order.Shipping.verify(message.shipping);
            if (error)
                return "shipping." + error;
        }
        if (message.buyerID != null && message.hasOwnProperty("buyerID")) {
            var error = $root.ID.verify(message.buyerID);
            if (error)
                return "buyerID." + error;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.items != null && message.hasOwnProperty("items")) {
            if (!Array.isArray(message.items))
                return "items: array expected";
            for (var i = 0; i < message.items.length; ++i) {
                var error = $root.Order.Item.verify(message.items[i]);
                if (error)
                    return "items." + error;
            }
        }
        if (message.payment != null && message.hasOwnProperty("payment")) {
            var error = $root.Order.Payment.verify(message.payment);
            if (error)
                return "payment." + error;
        }
        if (message.ratingKeys != null && message.hasOwnProperty("ratingKeys")) {
            if (!Array.isArray(message.ratingKeys))
                return "ratingKeys: array expected";
            for (var i = 0; i < message.ratingKeys.length; ++i)
                if (!(message.ratingKeys[i] && typeof message.ratingKeys[i].length === "number" || $util.isString(message.ratingKeys[i])))
                    return "ratingKeys: buffer[] expected";
        }
        if (message.alternateContactInfo != null && message.hasOwnProperty("alternateContactInfo"))
            if (!$util.isString(message.alternateContactInfo))
                return "alternateContactInfo: string expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version))
                return "version: integer expected";
        return null;
    };

    /**
     * Creates an Order message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Order
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Order} Order
     */
    Order.fromObject = function fromObject(object) {
        if (object instanceof $root.Order)
            return object;
        var message = new $root.Order();
        if (object.refundAddress != null)
            message.refundAddress = String(object.refundAddress);
        if (object.refundFee != null)
            if ($util.Long)
                (message.refundFee = $util.Long.fromValue(object.refundFee)).unsigned = true;
            else if (typeof object.refundFee === "string")
                message.refundFee = parseInt(object.refundFee, 10);
            else if (typeof object.refundFee === "number")
                message.refundFee = object.refundFee;
            else if (typeof object.refundFee === "object")
                message.refundFee = new $util.LongBits(object.refundFee.low >>> 0, object.refundFee.high >>> 0).toNumber(true);
        if (object.shipping != null) {
            if (typeof object.shipping !== "object")
                throw TypeError(".Order.shipping: object expected");
            message.shipping = $root.Order.Shipping.fromObject(object.shipping);
        }
        if (object.buyerID != null) {
            if (typeof object.buyerID !== "object")
                throw TypeError(".Order.buyerID: object expected");
            message.buyerID = $root.ID.fromObject(object.buyerID);
        }
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".Order.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.items) {
            if (!Array.isArray(object.items))
                throw TypeError(".Order.items: array expected");
            message.items = [];
            for (var i = 0; i < object.items.length; ++i) {
                if (typeof object.items[i] !== "object")
                    throw TypeError(".Order.items: object expected");
                message.items[i] = $root.Order.Item.fromObject(object.items[i]);
            }
        }
        if (object.payment != null) {
            if (typeof object.payment !== "object")
                throw TypeError(".Order.payment: object expected");
            message.payment = $root.Order.Payment.fromObject(object.payment);
        }
        if (object.ratingKeys) {
            if (!Array.isArray(object.ratingKeys))
                throw TypeError(".Order.ratingKeys: array expected");
            message.ratingKeys = [];
            for (var i = 0; i < object.ratingKeys.length; ++i)
                if (typeof object.ratingKeys[i] === "string")
                    $util.base64.decode(object.ratingKeys[i], message.ratingKeys[i] = $util.newBuffer($util.base64.length(object.ratingKeys[i])), 0);
                else if (object.ratingKeys[i].length)
                    message.ratingKeys[i] = object.ratingKeys[i];
        }
        if (object.alternateContactInfo != null)
            message.alternateContactInfo = String(object.alternateContactInfo);
        if (object.version != null)
            message.version = object.version >>> 0;
        return message;
    };

    /**
     * Creates a plain object from an Order message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Order
     * @static
     * @param {Order} message Order
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Order.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.items = [];
            object.ratingKeys = [];
        }
        if (options.defaults) {
            object.refundAddress = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.refundFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.refundFee = options.longs === String ? "0" : 0;
            object.shipping = null;
            object.buyerID = null;
            object.timestamp = null;
            object.payment = null;
            object.alternateContactInfo = "";
            object.version = 0;
        }
        if (message.refundAddress != null && message.hasOwnProperty("refundAddress"))
            object.refundAddress = message.refundAddress;
        if (message.refundFee != null && message.hasOwnProperty("refundFee"))
            if (typeof message.refundFee === "number")
                object.refundFee = options.longs === String ? String(message.refundFee) : message.refundFee;
            else
                object.refundFee = options.longs === String ? $util.Long.prototype.toString.call(message.refundFee) : options.longs === Number ? new $util.LongBits(message.refundFee.low >>> 0, message.refundFee.high >>> 0).toNumber(true) : message.refundFee;
        if (message.shipping != null && message.hasOwnProperty("shipping"))
            object.shipping = $root.Order.Shipping.toObject(message.shipping, options);
        if (message.buyerID != null && message.hasOwnProperty("buyerID"))
            object.buyerID = $root.ID.toObject(message.buyerID, options);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.items && message.items.length) {
            object.items = [];
            for (var j = 0; j < message.items.length; ++j)
                object.items[j] = $root.Order.Item.toObject(message.items[j], options);
        }
        if (message.payment != null && message.hasOwnProperty("payment"))
            object.payment = $root.Order.Payment.toObject(message.payment, options);
        if (message.ratingKeys && message.ratingKeys.length) {
            object.ratingKeys = [];
            for (var j = 0; j < message.ratingKeys.length; ++j)
                object.ratingKeys[j] = options.bytes === String ? $util.base64.encode(message.ratingKeys[j], 0, message.ratingKeys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ratingKeys[j]) : message.ratingKeys[j];
        }
        if (message.alternateContactInfo != null && message.hasOwnProperty("alternateContactInfo"))
            object.alternateContactInfo = message.alternateContactInfo;
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        return object;
    };

    /**
     * Converts this Order to JSON.
     * @function toJSON
     * @memberof Order
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Order.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Order.Shipping = (function() {

        /**
         * Properties of a Shipping.
         * @memberof Order
         * @interface IShipping
         * @property {string|null} [shipTo] Shipping shipTo
         * @property {string|null} [address] Shipping address
         * @property {string|null} [city] Shipping city
         * @property {string|null} [state] Shipping state
         * @property {string|null} [postalCode] Shipping postalCode
         * @property {CountryCode|null} [country] Shipping country
         * @property {string|null} [addressNotes] Shipping addressNotes
         */

        /**
         * Constructs a new Shipping.
         * @memberof Order
         * @classdesc Represents a Shipping.
         * @implements IShipping
         * @constructor
         * @param {Order.IShipping=} [properties] Properties to set
         */
        function Shipping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Shipping shipTo.
         * @member {string} shipTo
         * @memberof Order.Shipping
         * @instance
         */
        Shipping.prototype.shipTo = "";

        /**
         * Shipping address.
         * @member {string} address
         * @memberof Order.Shipping
         * @instance
         */
        Shipping.prototype.address = "";

        /**
         * Shipping city.
         * @member {string} city
         * @memberof Order.Shipping
         * @instance
         */
        Shipping.prototype.city = "";

        /**
         * Shipping state.
         * @member {string} state
         * @memberof Order.Shipping
         * @instance
         */
        Shipping.prototype.state = "";

        /**
         * Shipping postalCode.
         * @member {string} postalCode
         * @memberof Order.Shipping
         * @instance
         */
        Shipping.prototype.postalCode = "";

        /**
         * Shipping country.
         * @member {CountryCode} country
         * @memberof Order.Shipping
         * @instance
         */
        Shipping.prototype.country = 0;

        /**
         * Shipping addressNotes.
         * @member {string} addressNotes
         * @memberof Order.Shipping
         * @instance
         */
        Shipping.prototype.addressNotes = "";

        /**
         * Creates a new Shipping instance using the specified properties.
         * @function create
         * @memberof Order.Shipping
         * @static
         * @param {Order.IShipping=} [properties] Properties to set
         * @returns {Order.Shipping} Shipping instance
         */
        Shipping.create = function create(properties) {
            return new Shipping(properties);
        };

        /**
         * Encodes the specified Shipping message. Does not implicitly {@link Order.Shipping.verify|verify} messages.
         * @function encode
         * @memberof Order.Shipping
         * @static
         * @param {Order.IShipping} message Shipping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Shipping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shipTo != null && message.hasOwnProperty("shipTo"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.shipTo);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
            if (message.city != null && message.hasOwnProperty("city"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.city);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.state);
            if (message.postalCode != null && message.hasOwnProperty("postalCode"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.postalCode);
            if (message.country != null && message.hasOwnProperty("country"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.country);
            if (message.addressNotes != null && message.hasOwnProperty("addressNotes"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.addressNotes);
            return writer;
        };

        /**
         * Encodes the specified Shipping message, length delimited. Does not implicitly {@link Order.Shipping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Order.Shipping
         * @static
         * @param {Order.IShipping} message Shipping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Shipping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Shipping message from the specified reader or buffer.
         * @function decode
         * @memberof Order.Shipping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Order.Shipping} Shipping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Shipping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Order.Shipping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shipTo = reader.string();
                    break;
                case 2:
                    message.address = reader.string();
                    break;
                case 3:
                    message.city = reader.string();
                    break;
                case 4:
                    message.state = reader.string();
                    break;
                case 5:
                    message.postalCode = reader.string();
                    break;
                case 6:
                    message.country = reader.int32();
                    break;
                case 7:
                    message.addressNotes = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Shipping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Order.Shipping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Order.Shipping} Shipping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Shipping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Shipping message.
         * @function verify
         * @memberof Order.Shipping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Shipping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shipTo != null && message.hasOwnProperty("shipTo"))
                if (!$util.isString(message.shipTo))
                    return "shipTo: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            if (message.city != null && message.hasOwnProperty("city"))
                if (!$util.isString(message.city))
                    return "city: string expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isString(message.state))
                    return "state: string expected";
            if (message.postalCode != null && message.hasOwnProperty("postalCode"))
                if (!$util.isString(message.postalCode))
                    return "postalCode: string expected";
            if (message.country != null && message.hasOwnProperty("country"))
                switch (message.country) {
                default:
                    return "country: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                case 117:
                case 118:
                case 119:
                case 120:
                case 121:
                case 122:
                case 123:
                case 124:
                case 125:
                case 126:
                case 127:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                case 150:
                case 151:
                case 152:
                case 153:
                case 154:
                case 155:
                case 156:
                case 157:
                case 158:
                case 159:
                case 160:
                case 161:
                case 162:
                case 163:
                case 164:
                case 165:
                case 166:
                case 167:
                case 168:
                case 169:
                case 170:
                case 171:
                case 172:
                case 173:
                case 174:
                case 175:
                case 176:
                case 177:
                case 178:
                case 179:
                case 180:
                case 181:
                case 182:
                case 183:
                case 184:
                case 185:
                case 186:
                case 187:
                case 188:
                case 189:
                case 190:
                case 191:
                case 192:
                case 193:
                case 194:
                case 195:
                case 196:
                case 197:
                case 198:
                case 199:
                case 200:
                case 201:
                case 202:
                case 203:
                case 204:
                case 205:
                case 206:
                case 207:
                case 208:
                case 209:
                case 210:
                case 211:
                case 212:
                case 213:
                case 214:
                case 215:
                case 216:
                case 217:
                case 218:
                case 219:
                case 220:
                case 221:
                case 222:
                case 223:
                case 224:
                case 225:
                case 226:
                case 227:
                case 228:
                case 229:
                case 230:
                case 231:
                case 232:
                case 233:
                case 234:
                case 235:
                case 236:
                case 237:
                case 238:
                case 239:
                case 240:
                case 241:
                case 242:
                case 243:
                case 244:
                case 245:
                case 246:
                case 500:
                case 501:
                case 502:
                case 503:
                case 504:
                case 505:
                case 506:
                case 507:
                case 508:
                    break;
                }
            if (message.addressNotes != null && message.hasOwnProperty("addressNotes"))
                if (!$util.isString(message.addressNotes))
                    return "addressNotes: string expected";
            return null;
        };

        /**
         * Creates a Shipping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Order.Shipping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Order.Shipping} Shipping
         */
        Shipping.fromObject = function fromObject(object) {
            if (object instanceof $root.Order.Shipping)
                return object;
            var message = new $root.Order.Shipping();
            if (object.shipTo != null)
                message.shipTo = String(object.shipTo);
            if (object.address != null)
                message.address = String(object.address);
            if (object.city != null)
                message.city = String(object.city);
            if (object.state != null)
                message.state = String(object.state);
            if (object.postalCode != null)
                message.postalCode = String(object.postalCode);
            switch (object.country) {
            case "NA":
            case 0:
                message.country = 0;
                break;
            case "AFGHANISTAN":
            case 1:
                message.country = 1;
                break;
            case "ALAND_ISLANDS":
            case 2:
                message.country = 2;
                break;
            case "ALBANIA":
            case 3:
                message.country = 3;
                break;
            case "ALGERIA":
            case 4:
                message.country = 4;
                break;
            case "AMERICAN_SAMOA":
            case 5:
                message.country = 5;
                break;
            case "ANDORRA":
            case 6:
                message.country = 6;
                break;
            case "ANGOLA":
            case 7:
                message.country = 7;
                break;
            case "ANGUILLA":
            case 8:
                message.country = 8;
                break;
            case "ANTIGUA":
            case 9:
                message.country = 9;
                break;
            case "ARGENTINA":
            case 10:
                message.country = 10;
                break;
            case "ARMENIA":
            case 11:
                message.country = 11;
                break;
            case "ARUBA":
            case 12:
                message.country = 12;
                break;
            case "AUSTRALIA":
            case 13:
                message.country = 13;
                break;
            case "AUSTRIA":
            case 14:
                message.country = 14;
                break;
            case "AZERBAIJAN":
            case 15:
                message.country = 15;
                break;
            case "BAHAMAS":
            case 16:
                message.country = 16;
                break;
            case "BAHRAIN":
            case 17:
                message.country = 17;
                break;
            case "BANGLADESH":
            case 18:
                message.country = 18;
                break;
            case "BARBADOS":
            case 19:
                message.country = 19;
                break;
            case "BELARUS":
            case 20:
                message.country = 20;
                break;
            case "BELGIUM":
            case 21:
                message.country = 21;
                break;
            case "BELIZE":
            case 22:
                message.country = 22;
                break;
            case "BENIN":
            case 23:
                message.country = 23;
                break;
            case "BERMUDA":
            case 24:
                message.country = 24;
                break;
            case "BHUTAN":
            case 25:
                message.country = 25;
                break;
            case "BOLIVIA":
            case 26:
                message.country = 26;
                break;
            case "BONAIRE_SINT_EUSTATIUS_SABA":
            case 27:
                message.country = 27;
                break;
            case "BOSNIA":
            case 28:
                message.country = 28;
                break;
            case "BOTSWANA":
            case 29:
                message.country = 29;
                break;
            case "BOUVET_ISLAND":
            case 30:
                message.country = 30;
                break;
            case "BRAZIL":
            case 31:
                message.country = 31;
                break;
            case "BRITISH_INDIAN_OCEAN_TERRITORY":
            case 32:
                message.country = 32;
                break;
            case "BRUNEI_DARUSSALAM":
            case 33:
                message.country = 33;
                break;
            case "BULGARIA":
            case 34:
                message.country = 34;
                break;
            case "BURKINA_FASO":
            case 35:
                message.country = 35;
                break;
            case "BURUNDI":
            case 36:
                message.country = 36;
                break;
            case "CABO_VERDE":
            case 37:
                message.country = 37;
                break;
            case "CAMBODIA":
            case 38:
                message.country = 38;
                break;
            case "CAMEROON":
            case 39:
                message.country = 39;
                break;
            case "CANADA":
            case 40:
                message.country = 40;
                break;
            case "CAYMAN_ISLANDS":
            case 41:
                message.country = 41;
                break;
            case "CENTRAL_AFRICAN_REPUBLIC":
            case 42:
                message.country = 42;
                break;
            case "CHAD":
            case 43:
                message.country = 43;
                break;
            case "CHILE":
            case 44:
                message.country = 44;
                break;
            case "CHINA":
            case 45:
                message.country = 45;
                break;
            case "CHRISTMAS_ISLAND":
            case 46:
                message.country = 46;
                break;
            case "COCOS_ISLANDS":
            case 47:
                message.country = 47;
                break;
            case "COLOMBIA":
            case 48:
                message.country = 48;
                break;
            case "COMOROS":
            case 49:
                message.country = 49;
                break;
            case "CONGO_REPUBLIC":
            case 50:
                message.country = 50;
                break;
            case "CONGO":
            case 51:
                message.country = 51;
                break;
            case "COOK_ISLANDS":
            case 52:
                message.country = 52;
                break;
            case "COSTA_RICA":
            case 53:
                message.country = 53;
                break;
            case "COTE_DIVOIRE":
            case 54:
                message.country = 54;
                break;
            case "CROATIA":
            case 55:
                message.country = 55;
                break;
            case "CUBA":
            case 56:
                message.country = 56;
                break;
            case "CURACAO":
            case 57:
                message.country = 57;
                break;
            case "CYPRUS":
            case 58:
                message.country = 58;
                break;
            case "CZECH_REPUBLIC":
            case 59:
                message.country = 59;
                break;
            case "DENMARK":
            case 60:
                message.country = 60;
                break;
            case "DJIBOUTI":
            case 61:
                message.country = 61;
                break;
            case "DOMINICA":
            case 62:
                message.country = 62;
                break;
            case "DOMINICAN_REPUBLIC":
            case 63:
                message.country = 63;
                break;
            case "ECUADOR":
            case 64:
                message.country = 64;
                break;
            case "EGYPT":
            case 65:
                message.country = 65;
                break;
            case "EL_SALVADOR":
            case 66:
                message.country = 66;
                break;
            case "EQUATORIAL_GUINEA":
            case 67:
                message.country = 67;
                break;
            case "ERITREA":
            case 68:
                message.country = 68;
                break;
            case "ESTONIA":
            case 69:
                message.country = 69;
                break;
            case "ETHIOPIA":
            case 70:
                message.country = 70;
                break;
            case "FALKLAND_ISLANDS":
            case 71:
                message.country = 71;
                break;
            case "FAROE_ISLANDS":
            case 72:
                message.country = 72;
                break;
            case "FIJI":
            case 73:
                message.country = 73;
                break;
            case "FINLAND":
            case 74:
                message.country = 74;
                break;
            case "FRANCE":
            case 75:
                message.country = 75;
                break;
            case "FRENCH_GUIANA":
            case 76:
                message.country = 76;
                break;
            case "FRENCH_POLYNESIA":
            case 77:
                message.country = 77;
                break;
            case "FRENCH_SOUTHERN_TERRITORIES":
            case 78:
                message.country = 78;
                break;
            case "GABON":
            case 79:
                message.country = 79;
                break;
            case "GAMBIA":
            case 80:
                message.country = 80;
                break;
            case "GEORGIA":
            case 81:
                message.country = 81;
                break;
            case "GERMANY":
            case 82:
                message.country = 82;
                break;
            case "GHANA":
            case 83:
                message.country = 83;
                break;
            case "GIBRALTAR":
            case 84:
                message.country = 84;
                break;
            case "GREECE":
            case 85:
                message.country = 85;
                break;
            case "GREENLAND":
            case 86:
                message.country = 86;
                break;
            case "GRENADA":
            case 87:
                message.country = 87;
                break;
            case "GUADELOUPE":
            case 88:
                message.country = 88;
                break;
            case "GUAM":
            case 89:
                message.country = 89;
                break;
            case "GUATEMALA":
            case 90:
                message.country = 90;
                break;
            case "GUERNSEY":
            case 91:
                message.country = 91;
                break;
            case "GUINEA":
            case 92:
                message.country = 92;
                break;
            case "GUINEA_BISSAU":
            case 93:
                message.country = 93;
                break;
            case "GUYANA":
            case 94:
                message.country = 94;
                break;
            case "HAITI":
            case 95:
                message.country = 95;
                break;
            case "HEARD_ISLAND":
            case 96:
                message.country = 96;
                break;
            case "HOLY_SEE":
            case 97:
                message.country = 97;
                break;
            case "HONDURAS":
            case 98:
                message.country = 98;
                break;
            case "HONG_KONG":
            case 99:
                message.country = 99;
                break;
            case "HUNGARY":
            case 100:
                message.country = 100;
                break;
            case "ICELAND":
            case 101:
                message.country = 101;
                break;
            case "INDIA":
            case 102:
                message.country = 102;
                break;
            case "INDONESIA":
            case 103:
                message.country = 103;
                break;
            case "IRAN":
            case 104:
                message.country = 104;
                break;
            case "IRAQ":
            case 105:
                message.country = 105;
                break;
            case "IRELAND":
            case 106:
                message.country = 106;
                break;
            case "ISLE_OF_MAN":
            case 107:
                message.country = 107;
                break;
            case "ISRAEL":
            case 108:
                message.country = 108;
                break;
            case "ITALY":
            case 109:
                message.country = 109;
                break;
            case "JAMAICA":
            case 110:
                message.country = 110;
                break;
            case "JAPAN":
            case 111:
                message.country = 111;
                break;
            case "JERSEY":
            case 112:
                message.country = 112;
                break;
            case "JORDAN":
            case 113:
                message.country = 113;
                break;
            case "KAZAKHSTAN":
            case 114:
                message.country = 114;
                break;
            case "KENYA":
            case 115:
                message.country = 115;
                break;
            case "KIRIBATI":
            case 116:
                message.country = 116;
                break;
            case "NORTH_KOREA":
            case 117:
                message.country = 117;
                break;
            case "SOUTH_KOREA":
            case 118:
                message.country = 118;
                break;
            case "KUWAIT":
            case 119:
                message.country = 119;
                break;
            case "KYRGYZSTAN":
            case 120:
                message.country = 120;
                break;
            case "LAO":
            case 121:
                message.country = 121;
                break;
            case "LATVIA":
            case 122:
                message.country = 122;
                break;
            case "LEBANON":
            case 123:
                message.country = 123;
                break;
            case "LESOTHO":
            case 124:
                message.country = 124;
                break;
            case "LIBERIA":
            case 125:
                message.country = 125;
                break;
            case "LIBYA":
            case 126:
                message.country = 126;
                break;
            case "LIECHTENSTEIN":
            case 127:
                message.country = 127;
                break;
            case "LITHUANIA":
            case 128:
                message.country = 128;
                break;
            case "LUXEMBOURG":
            case 129:
                message.country = 129;
                break;
            case "MACAO":
            case 130:
                message.country = 130;
                break;
            case "MACEDONIA":
            case 131:
                message.country = 131;
                break;
            case "MADAGASCAR":
            case 132:
                message.country = 132;
                break;
            case "MALAWI":
            case 133:
                message.country = 133;
                break;
            case "MALAYSIA":
            case 134:
                message.country = 134;
                break;
            case "MALDIVES":
            case 135:
                message.country = 135;
                break;
            case "MALI":
            case 136:
                message.country = 136;
                break;
            case "MALTA":
            case 137:
                message.country = 137;
                break;
            case "MARSHALL_ISLANDS":
            case 138:
                message.country = 138;
                break;
            case "MARTINIQUE":
            case 139:
                message.country = 139;
                break;
            case "MAURITANIA":
            case 140:
                message.country = 140;
                break;
            case "MAURITIUS":
            case 141:
                message.country = 141;
                break;
            case "MAYOTTE":
            case 142:
                message.country = 142;
                break;
            case "MEXICO":
            case 143:
                message.country = 143;
                break;
            case "MICRONESIA":
            case 144:
                message.country = 144;
                break;
            case "MOLDOVA":
            case 145:
                message.country = 145;
                break;
            case "MONACO":
            case 146:
                message.country = 146;
                break;
            case "MONGOLIA":
            case 147:
                message.country = 147;
                break;
            case "MONTENEGRO":
            case 148:
                message.country = 148;
                break;
            case "MONTSERRAT":
            case 149:
                message.country = 149;
                break;
            case "MOROCCO":
            case 150:
                message.country = 150;
                break;
            case "MOZAMBIQUE":
            case 151:
                message.country = 151;
                break;
            case "MYANMAR":
            case 152:
                message.country = 152;
                break;
            case "NAMIBIA":
            case 153:
                message.country = 153;
                break;
            case "NAURU":
            case 154:
                message.country = 154;
                break;
            case "NEPAL":
            case 155:
                message.country = 155;
                break;
            case "NETHERLANDS":
            case 156:
                message.country = 156;
                break;
            case "NEW_CALEDONIA":
            case 157:
                message.country = 157;
                break;
            case "NEW_ZEALAND":
            case 158:
                message.country = 158;
                break;
            case "NICARAGUA":
            case 159:
                message.country = 159;
                break;
            case "NIGER":
            case 160:
                message.country = 160;
                break;
            case "NIGERIA":
            case 161:
                message.country = 161;
                break;
            case "NIUE":
            case 162:
                message.country = 162;
                break;
            case "NORFOLK_ISLAND":
            case 163:
                message.country = 163;
                break;
            case "NORTHERN_MARIANA_ISLANDS":
            case 164:
                message.country = 164;
                break;
            case "NORWAY":
            case 165:
                message.country = 165;
                break;
            case "OMAN":
            case 166:
                message.country = 166;
                break;
            case "PAKISTAN":
            case 167:
                message.country = 167;
                break;
            case "PALAU":
            case 168:
                message.country = 168;
                break;
            case "PANAMA":
            case 169:
                message.country = 169;
                break;
            case "PAPUA_NEW_GUINEA":
            case 170:
                message.country = 170;
                break;
            case "PARAGUAY":
            case 171:
                message.country = 171;
                break;
            case "PERU":
            case 172:
                message.country = 172;
                break;
            case "PHILIPPINES":
            case 173:
                message.country = 173;
                break;
            case "PITCAIRN":
            case 174:
                message.country = 174;
                break;
            case "POLAND":
            case 175:
                message.country = 175;
                break;
            case "PORTUGAL":
            case 176:
                message.country = 176;
                break;
            case "PUERTO_RICO":
            case 177:
                message.country = 177;
                break;
            case "QATAR":
            case 178:
                message.country = 178;
                break;
            case "REUNION":
            case 179:
                message.country = 179;
                break;
            case "ROMANIA":
            case 180:
                message.country = 180;
                break;
            case "RUSSIA":
            case 181:
                message.country = 181;
                break;
            case "RWANDA":
            case 182:
                message.country = 182;
                break;
            case "SAINT_BARTHELEMY":
            case 183:
                message.country = 183;
                break;
            case "SAINT_HELENA":
            case 184:
                message.country = 184;
                break;
            case "SAINT_KITTS":
            case 185:
                message.country = 185;
                break;
            case "SAINT_LUCIA":
            case 186:
                message.country = 186;
                break;
            case "SAINT_MARTIN":
            case 187:
                message.country = 187;
                break;
            case "SAINT_PIERRE":
            case 188:
                message.country = 188;
                break;
            case "SAINT_VINCENT":
            case 189:
                message.country = 189;
                break;
            case "SAMOA":
            case 190:
                message.country = 190;
                break;
            case "SAN_MARINO":
            case 191:
                message.country = 191;
                break;
            case "SAO_TOME":
            case 192:
                message.country = 192;
                break;
            case "SAUDI_ARABIA":
            case 193:
                message.country = 193;
                break;
            case "SENEGAL":
            case 194:
                message.country = 194;
                break;
            case "SERBIA":
            case 195:
                message.country = 195;
                break;
            case "SEYCHELLES":
            case 196:
                message.country = 196;
                break;
            case "SIERRA_LEONE":
            case 197:
                message.country = 197;
                break;
            case "SINGAPORE":
            case 198:
                message.country = 198;
                break;
            case "SINT_MAARTEN":
            case 199:
                message.country = 199;
                break;
            case "SUCRE":
            case 200:
                message.country = 200;
                break;
            case "SLOVAKIA":
            case 201:
                message.country = 201;
                break;
            case "SLOVENIA":
            case 202:
                message.country = 202;
                break;
            case "SOLOMON_ISLANDS":
            case 203:
                message.country = 203;
                break;
            case "SOMALIA":
            case 204:
                message.country = 204;
                break;
            case "SOUTH_AFRICA":
            case 205:
                message.country = 205;
                break;
            case "SOUTH_SUDAN":
            case 206:
                message.country = 206;
                break;
            case "SPAIN":
            case 207:
                message.country = 207;
                break;
            case "SRI_LANKA":
            case 208:
                message.country = 208;
                break;
            case "SUDAN":
            case 209:
                message.country = 209;
                break;
            case "SURINAME":
            case 210:
                message.country = 210;
                break;
            case "SVALBARD":
            case 211:
                message.country = 211;
                break;
            case "SWAZILAND":
            case 212:
                message.country = 212;
                break;
            case "SWEDEN":
            case 213:
                message.country = 213;
                break;
            case "SWITZERLAND":
            case 214:
                message.country = 214;
                break;
            case "SYRIAN_ARAB_REPUBLIC":
            case 215:
                message.country = 215;
                break;
            case "TAIWAN":
            case 216:
                message.country = 216;
                break;
            case "TAJIKISTAN":
            case 217:
                message.country = 217;
                break;
            case "TANZANIA":
            case 218:
                message.country = 218;
                break;
            case "THAILAND":
            case 219:
                message.country = 219;
                break;
            case "TIMOR_LESTE":
            case 220:
                message.country = 220;
                break;
            case "TOGO":
            case 221:
                message.country = 221;
                break;
            case "TOKELAU":
            case 222:
                message.country = 222;
                break;
            case "TONGA":
            case 223:
                message.country = 223;
                break;
            case "TRINIDAD":
            case 224:
                message.country = 224;
                break;
            case "TUNISIA":
            case 225:
                message.country = 225;
                break;
            case "TURKEY":
            case 226:
                message.country = 226;
                break;
            case "TURKMENISTAN":
            case 227:
                message.country = 227;
                break;
            case "TURKS_AND_CAICOS_ISLANDS":
            case 228:
                message.country = 228;
                break;
            case "TUVALU":
            case 229:
                message.country = 229;
                break;
            case "UGANDA":
            case 230:
                message.country = 230;
                break;
            case "UKRAINE":
            case 231:
                message.country = 231;
                break;
            case "UNITED_ARAB_EMIRATES":
            case 232:
                message.country = 232;
                break;
            case "UNITED_KINGDOM":
            case 233:
                message.country = 233;
                break;
            case "UNITED_STATES":
            case 234:
                message.country = 234;
                break;
            case "URUGUAY":
            case 235:
                message.country = 235;
                break;
            case "UZBEKISTAN":
            case 236:
                message.country = 236;
                break;
            case "VANUATU":
            case 237:
                message.country = 237;
                break;
            case "VENEZUELA":
            case 238:
                message.country = 238;
                break;
            case "VIETNAM":
            case 239:
                message.country = 239;
                break;
            case "VIRGIN_ISLANDS_BRITISH":
            case 240:
                message.country = 240;
                break;
            case "VIRGIN_ISLANDS_US":
            case 241:
                message.country = 241;
                break;
            case "WALLIS_AND_FUTUNA":
            case 242:
                message.country = 242;
                break;
            case "WESTERN_SAHARA":
            case 243:
                message.country = 243;
                break;
            case "YEMEN":
            case 244:
                message.country = 244;
                break;
            case "ZAMBIA":
            case 245:
                message.country = 245;
                break;
            case "ZIMBABWE":
            case 246:
                message.country = 246;
                break;
            case "ALL":
            case 500:
                message.country = 500;
                break;
            case "AFRICA":
            case 501:
                message.country = 501;
                break;
            case "ASIA":
            case 502:
                message.country = 502;
                break;
            case "CENTRAL_AMERICA":
            case 503:
                message.country = 503;
                break;
            case "EUROPE":
            case 504:
                message.country = 504;
                break;
            case "MIDDLE_EAST":
            case 505:
                message.country = 505;
                break;
            case "NORTH_AMERICA":
            case 506:
                message.country = 506;
                break;
            case "SOUTH_AMERICA":
            case 507:
                message.country = 507;
                break;
            case "OCEANIA":
            case 508:
                message.country = 508;
                break;
            }
            if (object.addressNotes != null)
                message.addressNotes = String(object.addressNotes);
            return message;
        };

        /**
         * Creates a plain object from a Shipping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Order.Shipping
         * @static
         * @param {Order.Shipping} message Shipping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Shipping.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.shipTo = "";
                object.address = "";
                object.city = "";
                object.state = "";
                object.postalCode = "";
                object.country = options.enums === String ? "NA" : 0;
                object.addressNotes = "";
            }
            if (message.shipTo != null && message.hasOwnProperty("shipTo"))
                object.shipTo = message.shipTo;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            if (message.city != null && message.hasOwnProperty("city"))
                object.city = message.city;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.postalCode != null && message.hasOwnProperty("postalCode"))
                object.postalCode = message.postalCode;
            if (message.country != null && message.hasOwnProperty("country"))
                object.country = options.enums === String ? $root.CountryCode[message.country] : message.country;
            if (message.addressNotes != null && message.hasOwnProperty("addressNotes"))
                object.addressNotes = message.addressNotes;
            return object;
        };

        /**
         * Converts this Shipping to JSON.
         * @function toJSON
         * @memberof Order.Shipping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Shipping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Shipping;
    })();

    Order.Item = (function() {

        /**
         * Properties of an Item.
         * @memberof Order
         * @interface IItem
         * @property {string|null} [listingHash] Item listingHash
         * @property {number|null} [quantity] Item quantity
         * @property {number|Long|null} [quantity64] Item quantity64
         * @property {Array.<Order.Item.IOption>|null} [options] Item options
         * @property {Order.Item.IShippingOption|null} [shippingOption] Item shippingOption
         * @property {string|null} [memo] Item memo
         * @property {Array.<string>|null} [couponCodes] Item couponCodes
         * @property {string|null} [paymentAddress] Item paymentAddress
         */

        /**
         * Constructs a new Item.
         * @memberof Order
         * @classdesc Represents an Item.
         * @implements IItem
         * @constructor
         * @param {Order.IItem=} [properties] Properties to set
         */
        function Item(properties) {
            this.options = [];
            this.couponCodes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Item listingHash.
         * @member {string} listingHash
         * @memberof Order.Item
         * @instance
         */
        Item.prototype.listingHash = "";

        /**
         * Item quantity.
         * @member {number} quantity
         * @memberof Order.Item
         * @instance
         */
        Item.prototype.quantity = 0;

        /**
         * Item quantity64.
         * @member {number|Long} quantity64
         * @memberof Order.Item
         * @instance
         */
        Item.prototype.quantity64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Item options.
         * @member {Array.<Order.Item.IOption>} options
         * @memberof Order.Item
         * @instance
         */
        Item.prototype.options = $util.emptyArray;

        /**
         * Item shippingOption.
         * @member {Order.Item.IShippingOption|null|undefined} shippingOption
         * @memberof Order.Item
         * @instance
         */
        Item.prototype.shippingOption = null;

        /**
         * Item memo.
         * @member {string} memo
         * @memberof Order.Item
         * @instance
         */
        Item.prototype.memo = "";

        /**
         * Item couponCodes.
         * @member {Array.<string>} couponCodes
         * @memberof Order.Item
         * @instance
         */
        Item.prototype.couponCodes = $util.emptyArray;

        /**
         * Item paymentAddress.
         * @member {string} paymentAddress
         * @memberof Order.Item
         * @instance
         */
        Item.prototype.paymentAddress = "";

        /**
         * Creates a new Item instance using the specified properties.
         * @function create
         * @memberof Order.Item
         * @static
         * @param {Order.IItem=} [properties] Properties to set
         * @returns {Order.Item} Item instance
         */
        Item.create = function create(properties) {
            return new Item(properties);
        };

        /**
         * Encodes the specified Item message. Does not implicitly {@link Order.Item.verify|verify} messages.
         * @function encode
         * @memberof Order.Item
         * @static
         * @param {Order.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.listingHash != null && message.hasOwnProperty("listingHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.listingHash);
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.quantity);
            if (message.options != null && message.options.length)
                for (var i = 0; i < message.options.length; ++i)
                    $root.Order.Item.Option.encode(message.options[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.shippingOption != null && message.hasOwnProperty("shippingOption"))
                $root.Order.Item.ShippingOption.encode(message.shippingOption, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.memo);
            if (message.couponCodes != null && message.couponCodes.length)
                for (var i = 0; i < message.couponCodes.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.couponCodes[i]);
            if (message.paymentAddress != null && message.hasOwnProperty("paymentAddress"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.paymentAddress);
            if (message.quantity64 != null && message.hasOwnProperty("quantity64"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.quantity64);
            return writer;
        };

        /**
         * Encodes the specified Item message, length delimited. Does not implicitly {@link Order.Item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Order.Item
         * @static
         * @param {Order.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Item message from the specified reader or buffer.
         * @function decode
         * @memberof Order.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Order.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Order.Item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.listingHash = reader.string();
                    break;
                case 2:
                    message.quantity = reader.uint32();
                    break;
                case 8:
                    message.quantity64 = reader.uint64();
                    break;
                case 3:
                    if (!(message.options && message.options.length))
                        message.options = [];
                    message.options.push($root.Order.Item.Option.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.shippingOption = $root.Order.Item.ShippingOption.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.memo = reader.string();
                    break;
                case 6:
                    if (!(message.couponCodes && message.couponCodes.length))
                        message.couponCodes = [];
                    message.couponCodes.push(reader.string());
                    break;
                case 7:
                    message.paymentAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Order.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Order.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Item message.
         * @function verify
         * @memberof Order.Item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.listingHash != null && message.hasOwnProperty("listingHash"))
                if (!$util.isString(message.listingHash))
                    return "listingHash: string expected";
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                if (!$util.isInteger(message.quantity))
                    return "quantity: integer expected";
            if (message.quantity64 != null && message.hasOwnProperty("quantity64"))
                if (!$util.isInteger(message.quantity64) && !(message.quantity64 && $util.isInteger(message.quantity64.low) && $util.isInteger(message.quantity64.high)))
                    return "quantity64: integer|Long expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!Array.isArray(message.options))
                    return "options: array expected";
                for (var i = 0; i < message.options.length; ++i) {
                    var error = $root.Order.Item.Option.verify(message.options[i]);
                    if (error)
                        return "options." + error;
                }
            }
            if (message.shippingOption != null && message.hasOwnProperty("shippingOption")) {
                var error = $root.Order.Item.ShippingOption.verify(message.shippingOption);
                if (error)
                    return "shippingOption." + error;
            }
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.couponCodes != null && message.hasOwnProperty("couponCodes")) {
                if (!Array.isArray(message.couponCodes))
                    return "couponCodes: array expected";
                for (var i = 0; i < message.couponCodes.length; ++i)
                    if (!$util.isString(message.couponCodes[i]))
                        return "couponCodes: string[] expected";
            }
            if (message.paymentAddress != null && message.hasOwnProperty("paymentAddress"))
                if (!$util.isString(message.paymentAddress))
                    return "paymentAddress: string expected";
            return null;
        };

        /**
         * Creates an Item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Order.Item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Order.Item} Item
         */
        Item.fromObject = function fromObject(object) {
            if (object instanceof $root.Order.Item)
                return object;
            var message = new $root.Order.Item();
            if (object.listingHash != null)
                message.listingHash = String(object.listingHash);
            if (object.quantity != null)
                message.quantity = object.quantity >>> 0;
            if (object.quantity64 != null)
                if ($util.Long)
                    (message.quantity64 = $util.Long.fromValue(object.quantity64)).unsigned = true;
                else if (typeof object.quantity64 === "string")
                    message.quantity64 = parseInt(object.quantity64, 10);
                else if (typeof object.quantity64 === "number")
                    message.quantity64 = object.quantity64;
                else if (typeof object.quantity64 === "object")
                    message.quantity64 = new $util.LongBits(object.quantity64.low >>> 0, object.quantity64.high >>> 0).toNumber(true);
            if (object.options) {
                if (!Array.isArray(object.options))
                    throw TypeError(".Order.Item.options: array expected");
                message.options = [];
                for (var i = 0; i < object.options.length; ++i) {
                    if (typeof object.options[i] !== "object")
                        throw TypeError(".Order.Item.options: object expected");
                    message.options[i] = $root.Order.Item.Option.fromObject(object.options[i]);
                }
            }
            if (object.shippingOption != null) {
                if (typeof object.shippingOption !== "object")
                    throw TypeError(".Order.Item.shippingOption: object expected");
                message.shippingOption = $root.Order.Item.ShippingOption.fromObject(object.shippingOption);
            }
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.couponCodes) {
                if (!Array.isArray(object.couponCodes))
                    throw TypeError(".Order.Item.couponCodes: array expected");
                message.couponCodes = [];
                for (var i = 0; i < object.couponCodes.length; ++i)
                    message.couponCodes[i] = String(object.couponCodes[i]);
            }
            if (object.paymentAddress != null)
                message.paymentAddress = String(object.paymentAddress);
            return message;
        };

        /**
         * Creates a plain object from an Item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Order.Item
         * @static
         * @param {Order.Item} message Item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.options = [];
                object.couponCodes = [];
            }
            if (options.defaults) {
                object.listingHash = "";
                object.quantity = 0;
                object.shippingOption = null;
                object.memo = "";
                object.paymentAddress = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.quantity64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quantity64 = options.longs === String ? "0" : 0;
            }
            if (message.listingHash != null && message.hasOwnProperty("listingHash"))
                object.listingHash = message.listingHash;
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                object.quantity = message.quantity;
            if (message.options && message.options.length) {
                object.options = [];
                for (var j = 0; j < message.options.length; ++j)
                    object.options[j] = $root.Order.Item.Option.toObject(message.options[j], options);
            }
            if (message.shippingOption != null && message.hasOwnProperty("shippingOption"))
                object.shippingOption = $root.Order.Item.ShippingOption.toObject(message.shippingOption, options);
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.couponCodes && message.couponCodes.length) {
                object.couponCodes = [];
                for (var j = 0; j < message.couponCodes.length; ++j)
                    object.couponCodes[j] = message.couponCodes[j];
            }
            if (message.paymentAddress != null && message.hasOwnProperty("paymentAddress"))
                object.paymentAddress = message.paymentAddress;
            if (message.quantity64 != null && message.hasOwnProperty("quantity64"))
                if (typeof message.quantity64 === "number")
                    object.quantity64 = options.longs === String ? String(message.quantity64) : message.quantity64;
                else
                    object.quantity64 = options.longs === String ? $util.Long.prototype.toString.call(message.quantity64) : options.longs === Number ? new $util.LongBits(message.quantity64.low >>> 0, message.quantity64.high >>> 0).toNumber(true) : message.quantity64;
            return object;
        };

        /**
         * Converts this Item to JSON.
         * @function toJSON
         * @memberof Order.Item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Item.Option = (function() {

            /**
             * Properties of an Option.
             * @memberof Order.Item
             * @interface IOption
             * @property {string|null} [name] Option name
             * @property {string|null} [value] Option value
             */

            /**
             * Constructs a new Option.
             * @memberof Order.Item
             * @classdesc Represents an Option.
             * @implements IOption
             * @constructor
             * @param {Order.Item.IOption=} [properties] Properties to set
             */
            function Option(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Option name.
             * @member {string} name
             * @memberof Order.Item.Option
             * @instance
             */
            Option.prototype.name = "";

            /**
             * Option value.
             * @member {string} value
             * @memberof Order.Item.Option
             * @instance
             */
            Option.prototype.value = "";

            /**
             * Creates a new Option instance using the specified properties.
             * @function create
             * @memberof Order.Item.Option
             * @static
             * @param {Order.Item.IOption=} [properties] Properties to set
             * @returns {Order.Item.Option} Option instance
             */
            Option.create = function create(properties) {
                return new Option(properties);
            };

            /**
             * Encodes the specified Option message. Does not implicitly {@link Order.Item.Option.verify|verify} messages.
             * @function encode
             * @memberof Order.Item.Option
             * @static
             * @param {Order.Item.IOption} message Option message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Option.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified Option message, length delimited. Does not implicitly {@link Order.Item.Option.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Order.Item.Option
             * @static
             * @param {Order.Item.IOption} message Option message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Option.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Option message from the specified reader or buffer.
             * @function decode
             * @memberof Order.Item.Option
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Order.Item.Option} Option
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Option.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Order.Item.Option();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Option message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Order.Item.Option
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Order.Item.Option} Option
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Option.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Option message.
             * @function verify
             * @memberof Order.Item.Option
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Option.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates an Option message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Order.Item.Option
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Order.Item.Option} Option
             */
            Option.fromObject = function fromObject(object) {
                if (object instanceof $root.Order.Item.Option)
                    return object;
                var message = new $root.Order.Item.Option();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from an Option message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Order.Item.Option
             * @static
             * @param {Order.Item.Option} message Option
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Option.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Option to JSON.
             * @function toJSON
             * @memberof Order.Item.Option
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Option.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Option;
        })();

        Item.ShippingOption = (function() {

            /**
             * Properties of a ShippingOption.
             * @memberof Order.Item
             * @interface IShippingOption
             * @property {string|null} [name] ShippingOption name
             * @property {string|null} [service] ShippingOption service
             */

            /**
             * Constructs a new ShippingOption.
             * @memberof Order.Item
             * @classdesc Represents a ShippingOption.
             * @implements IShippingOption
             * @constructor
             * @param {Order.Item.IShippingOption=} [properties] Properties to set
             */
            function ShippingOption(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShippingOption name.
             * @member {string} name
             * @memberof Order.Item.ShippingOption
             * @instance
             */
            ShippingOption.prototype.name = "";

            /**
             * ShippingOption service.
             * @member {string} service
             * @memberof Order.Item.ShippingOption
             * @instance
             */
            ShippingOption.prototype.service = "";

            /**
             * Creates a new ShippingOption instance using the specified properties.
             * @function create
             * @memberof Order.Item.ShippingOption
             * @static
             * @param {Order.Item.IShippingOption=} [properties] Properties to set
             * @returns {Order.Item.ShippingOption} ShippingOption instance
             */
            ShippingOption.create = function create(properties) {
                return new ShippingOption(properties);
            };

            /**
             * Encodes the specified ShippingOption message. Does not implicitly {@link Order.Item.ShippingOption.verify|verify} messages.
             * @function encode
             * @memberof Order.Item.ShippingOption
             * @static
             * @param {Order.Item.IShippingOption} message ShippingOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShippingOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.service != null && message.hasOwnProperty("service"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.service);
                return writer;
            };

            /**
             * Encodes the specified ShippingOption message, length delimited. Does not implicitly {@link Order.Item.ShippingOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Order.Item.ShippingOption
             * @static
             * @param {Order.Item.IShippingOption} message ShippingOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShippingOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShippingOption message from the specified reader or buffer.
             * @function decode
             * @memberof Order.Item.ShippingOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Order.Item.ShippingOption} ShippingOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShippingOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Order.Item.ShippingOption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.service = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShippingOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Order.Item.ShippingOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Order.Item.ShippingOption} ShippingOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShippingOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShippingOption message.
             * @function verify
             * @memberof Order.Item.ShippingOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShippingOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.service != null && message.hasOwnProperty("service"))
                    if (!$util.isString(message.service))
                        return "service: string expected";
                return null;
            };

            /**
             * Creates a ShippingOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Order.Item.ShippingOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Order.Item.ShippingOption} ShippingOption
             */
            ShippingOption.fromObject = function fromObject(object) {
                if (object instanceof $root.Order.Item.ShippingOption)
                    return object;
                var message = new $root.Order.Item.ShippingOption();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.service != null)
                    message.service = String(object.service);
                return message;
            };

            /**
             * Creates a plain object from a ShippingOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Order.Item.ShippingOption
             * @static
             * @param {Order.Item.ShippingOption} message ShippingOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShippingOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.service = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.service != null && message.hasOwnProperty("service"))
                    object.service = message.service;
                return object;
            };

            /**
             * Converts this ShippingOption to JSON.
             * @function toJSON
             * @memberof Order.Item.ShippingOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShippingOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ShippingOption;
        })();

        return Item;
    })();

    Order.Payment = (function() {

        /**
         * Properties of a Payment.
         * @memberof Order
         * @interface IPayment
         * @property {Order.Payment.Method|null} [method] Payment method
         * @property {string|null} [moderator] Payment moderator
         * @property {number|Long|null} [amount] Payment amount
         * @property {string|null} [chaincode] Payment chaincode
         * @property {string|null} [address] Payment address
         * @property {string|null} [redeemScript] Payment redeemScript
         * @property {Uint8Array|null} [moderatorKey] Payment moderatorKey
         */

        /**
         * Constructs a new Payment.
         * @memberof Order
         * @classdesc Represents a Payment.
         * @implements IPayment
         * @constructor
         * @param {Order.IPayment=} [properties] Properties to set
         */
        function Payment(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Payment method.
         * @member {Order.Payment.Method} method
         * @memberof Order.Payment
         * @instance
         */
        Payment.prototype.method = 0;

        /**
         * Payment moderator.
         * @member {string} moderator
         * @memberof Order.Payment
         * @instance
         */
        Payment.prototype.moderator = "";

        /**
         * Payment amount.
         * @member {number|Long} amount
         * @memberof Order.Payment
         * @instance
         */
        Payment.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Payment chaincode.
         * @member {string} chaincode
         * @memberof Order.Payment
         * @instance
         */
        Payment.prototype.chaincode = "";

        /**
         * Payment address.
         * @member {string} address
         * @memberof Order.Payment
         * @instance
         */
        Payment.prototype.address = "";

        /**
         * Payment redeemScript.
         * @member {string} redeemScript
         * @memberof Order.Payment
         * @instance
         */
        Payment.prototype.redeemScript = "";

        /**
         * Payment moderatorKey.
         * @member {Uint8Array} moderatorKey
         * @memberof Order.Payment
         * @instance
         */
        Payment.prototype.moderatorKey = $util.newBuffer([]);

        /**
         * Creates a new Payment instance using the specified properties.
         * @function create
         * @memberof Order.Payment
         * @static
         * @param {Order.IPayment=} [properties] Properties to set
         * @returns {Order.Payment} Payment instance
         */
        Payment.create = function create(properties) {
            return new Payment(properties);
        };

        /**
         * Encodes the specified Payment message. Does not implicitly {@link Order.Payment.verify|verify} messages.
         * @function encode
         * @memberof Order.Payment
         * @static
         * @param {Order.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.method != null && message.hasOwnProperty("method"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);
            if (message.moderator != null && message.hasOwnProperty("moderator"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.moderator);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.amount);
            if (message.chaincode != null && message.hasOwnProperty("chaincode"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.chaincode);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.address);
            if (message.redeemScript != null && message.hasOwnProperty("redeemScript"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.redeemScript);
            if (message.moderatorKey != null && message.hasOwnProperty("moderatorKey"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.moderatorKey);
            return writer;
        };

        /**
         * Encodes the specified Payment message, length delimited. Does not implicitly {@link Order.Payment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Order.Payment
         * @static
         * @param {Order.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Payment message from the specified reader or buffer.
         * @function decode
         * @memberof Order.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Order.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Order.Payment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.method = reader.int32();
                    break;
                case 2:
                    message.moderator = reader.string();
                    break;
                case 3:
                    message.amount = reader.uint64();
                    break;
                case 4:
                    message.chaincode = reader.string();
                    break;
                case 5:
                    message.address = reader.string();
                    break;
                case 6:
                    message.redeemScript = reader.string();
                    break;
                case 7:
                    message.moderatorKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Payment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Order.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Order.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Payment message.
         * @function verify
         * @memberof Order.Payment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Payment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.method != null && message.hasOwnProperty("method"))
                switch (message.method) {
                default:
                    return "method: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.moderator != null && message.hasOwnProperty("moderator"))
                if (!$util.isString(message.moderator))
                    return "moderator: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.chaincode != null && message.hasOwnProperty("chaincode"))
                if (!$util.isString(message.chaincode))
                    return "chaincode: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            if (message.redeemScript != null && message.hasOwnProperty("redeemScript"))
                if (!$util.isString(message.redeemScript))
                    return "redeemScript: string expected";
            if (message.moderatorKey != null && message.hasOwnProperty("moderatorKey"))
                if (!(message.moderatorKey && typeof message.moderatorKey.length === "number" || $util.isString(message.moderatorKey)))
                    return "moderatorKey: buffer expected";
            return null;
        };

        /**
         * Creates a Payment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Order.Payment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Order.Payment} Payment
         */
        Payment.fromObject = function fromObject(object) {
            if (object instanceof $root.Order.Payment)
                return object;
            var message = new $root.Order.Payment();
            switch (object.method) {
            case "ADDRESS_REQUEST":
            case 0:
                message.method = 0;
                break;
            case "DIRECT":
            case 1:
                message.method = 1;
                break;
            case "MODERATED":
            case 2:
                message.method = 2;
                break;
            }
            if (object.moderator != null)
                message.moderator = String(object.moderator);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
            if (object.chaincode != null)
                message.chaincode = String(object.chaincode);
            if (object.address != null)
                message.address = String(object.address);
            if (object.redeemScript != null)
                message.redeemScript = String(object.redeemScript);
            if (object.moderatorKey != null)
                if (typeof object.moderatorKey === "string")
                    $util.base64.decode(object.moderatorKey, message.moderatorKey = $util.newBuffer($util.base64.length(object.moderatorKey)), 0);
                else if (object.moderatorKey.length)
                    message.moderatorKey = object.moderatorKey;
            return message;
        };

        /**
         * Creates a plain object from a Payment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Order.Payment
         * @static
         * @param {Order.Payment} message Payment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Payment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.method = options.enums === String ? "ADDRESS_REQUEST" : 0;
                object.moderator = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.chaincode = "";
                object.address = "";
                object.redeemScript = "";
                object.moderatorKey = options.bytes === String ? "" : [];
            }
            if (message.method != null && message.hasOwnProperty("method"))
                object.method = options.enums === String ? $root.Order.Payment.Method[message.method] : message.method;
            if (message.moderator != null && message.hasOwnProperty("moderator"))
                object.moderator = message.moderator;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
            if (message.chaincode != null && message.hasOwnProperty("chaincode"))
                object.chaincode = message.chaincode;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            if (message.redeemScript != null && message.hasOwnProperty("redeemScript"))
                object.redeemScript = message.redeemScript;
            if (message.moderatorKey != null && message.hasOwnProperty("moderatorKey"))
                object.moderatorKey = options.bytes === String ? $util.base64.encode(message.moderatorKey, 0, message.moderatorKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.moderatorKey) : message.moderatorKey;
            return object;
        };

        /**
         * Converts this Payment to JSON.
         * @function toJSON
         * @memberof Order.Payment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Payment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Method enum.
         * @name Order.Payment.Method
         * @enum {string}
         * @property {number} ADDRESS_REQUEST=0 ADDRESS_REQUEST value
         * @property {number} DIRECT=1 DIRECT value
         * @property {number} MODERATED=2 MODERATED value
         */
        Payment.Method = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADDRESS_REQUEST"] = 0;
            values[valuesById[1] = "DIRECT"] = 1;
            values[valuesById[2] = "MODERATED"] = 2;
            return values;
        })();

        return Payment;
    })();

    return Order;
})();

$root.OrderConfirmation = (function() {

    /**
     * Properties of an OrderConfirmation.
     * @exports IOrderConfirmation
     * @interface IOrderConfirmation
     * @property {string|null} [orderID] OrderConfirmation orderID
     * @property {google.protobuf.ITimestamp|null} [timestamp] OrderConfirmation timestamp
     * @property {string|null} [paymentAddress] OrderConfirmation paymentAddress
     * @property {number|Long|null} [requestedAmount] OrderConfirmation requestedAmount
     * @property {Array.<IRatingSignature>|null} [ratingSignatures] OrderConfirmation ratingSignatures
     */

    /**
     * Constructs a new OrderConfirmation.
     * @exports OrderConfirmation
     * @classdesc Represents an OrderConfirmation.
     * @implements IOrderConfirmation
     * @constructor
     * @param {IOrderConfirmation=} [properties] Properties to set
     */
    function OrderConfirmation(properties) {
        this.ratingSignatures = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OrderConfirmation orderID.
     * @member {string} orderID
     * @memberof OrderConfirmation
     * @instance
     */
    OrderConfirmation.prototype.orderID = "";

    /**
     * OrderConfirmation timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof OrderConfirmation
     * @instance
     */
    OrderConfirmation.prototype.timestamp = null;

    /**
     * OrderConfirmation paymentAddress.
     * @member {string} paymentAddress
     * @memberof OrderConfirmation
     * @instance
     */
    OrderConfirmation.prototype.paymentAddress = "";

    /**
     * OrderConfirmation requestedAmount.
     * @member {number|Long} requestedAmount
     * @memberof OrderConfirmation
     * @instance
     */
    OrderConfirmation.prototype.requestedAmount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * OrderConfirmation ratingSignatures.
     * @member {Array.<IRatingSignature>} ratingSignatures
     * @memberof OrderConfirmation
     * @instance
     */
    OrderConfirmation.prototype.ratingSignatures = $util.emptyArray;

    /**
     * Creates a new OrderConfirmation instance using the specified properties.
     * @function create
     * @memberof OrderConfirmation
     * @static
     * @param {IOrderConfirmation=} [properties] Properties to set
     * @returns {OrderConfirmation} OrderConfirmation instance
     */
    OrderConfirmation.create = function create(properties) {
        return new OrderConfirmation(properties);
    };

    /**
     * Encodes the specified OrderConfirmation message. Does not implicitly {@link OrderConfirmation.verify|verify} messages.
     * @function encode
     * @memberof OrderConfirmation
     * @static
     * @param {IOrderConfirmation} message OrderConfirmation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderConfirmation.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderID);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.paymentAddress != null && message.hasOwnProperty("paymentAddress"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.paymentAddress);
        if (message.requestedAmount != null && message.hasOwnProperty("requestedAmount"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.requestedAmount);
        if (message.ratingSignatures != null && message.ratingSignatures.length)
            for (var i = 0; i < message.ratingSignatures.length; ++i)
                $root.RatingSignature.encode(message.ratingSignatures[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OrderConfirmation message, length delimited. Does not implicitly {@link OrderConfirmation.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OrderConfirmation
     * @static
     * @param {IOrderConfirmation} message OrderConfirmation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderConfirmation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OrderConfirmation message from the specified reader or buffer.
     * @function decode
     * @memberof OrderConfirmation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OrderConfirmation} OrderConfirmation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderConfirmation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderConfirmation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.orderID = reader.string();
                break;
            case 2:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 3:
                message.paymentAddress = reader.string();
                break;
            case 4:
                message.requestedAmount = reader.uint64();
                break;
            case 5:
                if (!(message.ratingSignatures && message.ratingSignatures.length))
                    message.ratingSignatures = [];
                message.ratingSignatures.push($root.RatingSignature.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OrderConfirmation message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OrderConfirmation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OrderConfirmation} OrderConfirmation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderConfirmation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OrderConfirmation message.
     * @function verify
     * @memberof OrderConfirmation
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OrderConfirmation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            if (!$util.isString(message.orderID))
                return "orderID: string expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.paymentAddress != null && message.hasOwnProperty("paymentAddress"))
            if (!$util.isString(message.paymentAddress))
                return "paymentAddress: string expected";
        if (message.requestedAmount != null && message.hasOwnProperty("requestedAmount"))
            if (!$util.isInteger(message.requestedAmount) && !(message.requestedAmount && $util.isInteger(message.requestedAmount.low) && $util.isInteger(message.requestedAmount.high)))
                return "requestedAmount: integer|Long expected";
        if (message.ratingSignatures != null && message.hasOwnProperty("ratingSignatures")) {
            if (!Array.isArray(message.ratingSignatures))
                return "ratingSignatures: array expected";
            for (var i = 0; i < message.ratingSignatures.length; ++i) {
                var error = $root.RatingSignature.verify(message.ratingSignatures[i]);
                if (error)
                    return "ratingSignatures." + error;
            }
        }
        return null;
    };

    /**
     * Creates an OrderConfirmation message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OrderConfirmation
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OrderConfirmation} OrderConfirmation
     */
    OrderConfirmation.fromObject = function fromObject(object) {
        if (object instanceof $root.OrderConfirmation)
            return object;
        var message = new $root.OrderConfirmation();
        if (object.orderID != null)
            message.orderID = String(object.orderID);
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".OrderConfirmation.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.paymentAddress != null)
            message.paymentAddress = String(object.paymentAddress);
        if (object.requestedAmount != null)
            if ($util.Long)
                (message.requestedAmount = $util.Long.fromValue(object.requestedAmount)).unsigned = true;
            else if (typeof object.requestedAmount === "string")
                message.requestedAmount = parseInt(object.requestedAmount, 10);
            else if (typeof object.requestedAmount === "number")
                message.requestedAmount = object.requestedAmount;
            else if (typeof object.requestedAmount === "object")
                message.requestedAmount = new $util.LongBits(object.requestedAmount.low >>> 0, object.requestedAmount.high >>> 0).toNumber(true);
        if (object.ratingSignatures) {
            if (!Array.isArray(object.ratingSignatures))
                throw TypeError(".OrderConfirmation.ratingSignatures: array expected");
            message.ratingSignatures = [];
            for (var i = 0; i < object.ratingSignatures.length; ++i) {
                if (typeof object.ratingSignatures[i] !== "object")
                    throw TypeError(".OrderConfirmation.ratingSignatures: object expected");
                message.ratingSignatures[i] = $root.RatingSignature.fromObject(object.ratingSignatures[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an OrderConfirmation message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OrderConfirmation
     * @static
     * @param {OrderConfirmation} message OrderConfirmation
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OrderConfirmation.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.ratingSignatures = [];
        if (options.defaults) {
            object.orderID = "";
            object.timestamp = null;
            object.paymentAddress = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.requestedAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.requestedAmount = options.longs === String ? "0" : 0;
        }
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            object.orderID = message.orderID;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.paymentAddress != null && message.hasOwnProperty("paymentAddress"))
            object.paymentAddress = message.paymentAddress;
        if (message.requestedAmount != null && message.hasOwnProperty("requestedAmount"))
            if (typeof message.requestedAmount === "number")
                object.requestedAmount = options.longs === String ? String(message.requestedAmount) : message.requestedAmount;
            else
                object.requestedAmount = options.longs === String ? $util.Long.prototype.toString.call(message.requestedAmount) : options.longs === Number ? new $util.LongBits(message.requestedAmount.low >>> 0, message.requestedAmount.high >>> 0).toNumber(true) : message.requestedAmount;
        if (message.ratingSignatures && message.ratingSignatures.length) {
            object.ratingSignatures = [];
            for (var j = 0; j < message.ratingSignatures.length; ++j)
                object.ratingSignatures[j] = $root.RatingSignature.toObject(message.ratingSignatures[j], options);
        }
        return object;
    };

    /**
     * Converts this OrderConfirmation to JSON.
     * @function toJSON
     * @memberof OrderConfirmation
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OrderConfirmation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OrderConfirmation;
})();

$root.OrderReject = (function() {

    /**
     * Properties of an OrderReject.
     * @exports IOrderReject
     * @interface IOrderReject
     * @property {string|null} [orderID] OrderReject orderID
     * @property {google.protobuf.ITimestamp|null} [timestamp] OrderReject timestamp
     * @property {Array.<IBitcoinSignature>|null} [sigs] OrderReject sigs
     */

    /**
     * Constructs a new OrderReject.
     * @exports OrderReject
     * @classdesc Represents an OrderReject.
     * @implements IOrderReject
     * @constructor
     * @param {IOrderReject=} [properties] Properties to set
     */
    function OrderReject(properties) {
        this.sigs = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OrderReject orderID.
     * @member {string} orderID
     * @memberof OrderReject
     * @instance
     */
    OrderReject.prototype.orderID = "";

    /**
     * OrderReject timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof OrderReject
     * @instance
     */
    OrderReject.prototype.timestamp = null;

    /**
     * OrderReject sigs.
     * @member {Array.<IBitcoinSignature>} sigs
     * @memberof OrderReject
     * @instance
     */
    OrderReject.prototype.sigs = $util.emptyArray;

    /**
     * Creates a new OrderReject instance using the specified properties.
     * @function create
     * @memberof OrderReject
     * @static
     * @param {IOrderReject=} [properties] Properties to set
     * @returns {OrderReject} OrderReject instance
     */
    OrderReject.create = function create(properties) {
        return new OrderReject(properties);
    };

    /**
     * Encodes the specified OrderReject message. Does not implicitly {@link OrderReject.verify|verify} messages.
     * @function encode
     * @memberof OrderReject
     * @static
     * @param {IOrderReject} message OrderReject message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderReject.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderID);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.sigs != null && message.sigs.length)
            for (var i = 0; i < message.sigs.length; ++i)
                $root.BitcoinSignature.encode(message.sigs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OrderReject message, length delimited. Does not implicitly {@link OrderReject.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OrderReject
     * @static
     * @param {IOrderReject} message OrderReject message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderReject.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OrderReject message from the specified reader or buffer.
     * @function decode
     * @memberof OrderReject
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OrderReject} OrderReject
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderReject.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderReject();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.orderID = reader.string();
                break;
            case 2:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.sigs && message.sigs.length))
                    message.sigs = [];
                message.sigs.push($root.BitcoinSignature.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OrderReject message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OrderReject
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OrderReject} OrderReject
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderReject.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OrderReject message.
     * @function verify
     * @memberof OrderReject
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OrderReject.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            if (!$util.isString(message.orderID))
                return "orderID: string expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.sigs != null && message.hasOwnProperty("sigs")) {
            if (!Array.isArray(message.sigs))
                return "sigs: array expected";
            for (var i = 0; i < message.sigs.length; ++i) {
                var error = $root.BitcoinSignature.verify(message.sigs[i]);
                if (error)
                    return "sigs." + error;
            }
        }
        return null;
    };

    /**
     * Creates an OrderReject message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OrderReject
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OrderReject} OrderReject
     */
    OrderReject.fromObject = function fromObject(object) {
        if (object instanceof $root.OrderReject)
            return object;
        var message = new $root.OrderReject();
        if (object.orderID != null)
            message.orderID = String(object.orderID);
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".OrderReject.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.sigs) {
            if (!Array.isArray(object.sigs))
                throw TypeError(".OrderReject.sigs: array expected");
            message.sigs = [];
            for (var i = 0; i < object.sigs.length; ++i) {
                if (typeof object.sigs[i] !== "object")
                    throw TypeError(".OrderReject.sigs: object expected");
                message.sigs[i] = $root.BitcoinSignature.fromObject(object.sigs[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an OrderReject message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OrderReject
     * @static
     * @param {OrderReject} message OrderReject
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OrderReject.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.sigs = [];
        if (options.defaults) {
            object.orderID = "";
            object.timestamp = null;
        }
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            object.orderID = message.orderID;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.sigs && message.sigs.length) {
            object.sigs = [];
            for (var j = 0; j < message.sigs.length; ++j)
                object.sigs[j] = $root.BitcoinSignature.toObject(message.sigs[j], options);
        }
        return object;
    };

    /**
     * Converts this OrderReject to JSON.
     * @function toJSON
     * @memberof OrderReject
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OrderReject.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OrderReject;
})();

$root.RatingSignature = (function() {

    /**
     * Properties of a RatingSignature.
     * @exports IRatingSignature
     * @interface IRatingSignature
     * @property {RatingSignature.ITransactionMetadata|null} [metadata] RatingSignature metadata
     * @property {Uint8Array|null} [signature] RatingSignature signature
     */

    /**
     * Constructs a new RatingSignature.
     * @exports RatingSignature
     * @classdesc Represents a RatingSignature.
     * @implements IRatingSignature
     * @constructor
     * @param {IRatingSignature=} [properties] Properties to set
     */
    function RatingSignature(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RatingSignature metadata.
     * @member {RatingSignature.ITransactionMetadata|null|undefined} metadata
     * @memberof RatingSignature
     * @instance
     */
    RatingSignature.prototype.metadata = null;

    /**
     * RatingSignature signature.
     * @member {Uint8Array} signature
     * @memberof RatingSignature
     * @instance
     */
    RatingSignature.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new RatingSignature instance using the specified properties.
     * @function create
     * @memberof RatingSignature
     * @static
     * @param {IRatingSignature=} [properties] Properties to set
     * @returns {RatingSignature} RatingSignature instance
     */
    RatingSignature.create = function create(properties) {
        return new RatingSignature(properties);
    };

    /**
     * Encodes the specified RatingSignature message. Does not implicitly {@link RatingSignature.verify|verify} messages.
     * @function encode
     * @memberof RatingSignature
     * @static
     * @param {IRatingSignature} message RatingSignature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RatingSignature.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            $root.RatingSignature.TransactionMetadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.signature != null && message.hasOwnProperty("signature"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
        return writer;
    };

    /**
     * Encodes the specified RatingSignature message, length delimited. Does not implicitly {@link RatingSignature.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RatingSignature
     * @static
     * @param {IRatingSignature} message RatingSignature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RatingSignature.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RatingSignature message from the specified reader or buffer.
     * @function decode
     * @memberof RatingSignature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RatingSignature} RatingSignature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RatingSignature.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RatingSignature();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.metadata = $root.RatingSignature.TransactionMetadata.decode(reader, reader.uint32());
                break;
            case 2:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RatingSignature message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RatingSignature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RatingSignature} RatingSignature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RatingSignature.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RatingSignature message.
     * @function verify
     * @memberof RatingSignature
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RatingSignature.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            var error = $root.RatingSignature.TransactionMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates a RatingSignature message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RatingSignature
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RatingSignature} RatingSignature
     */
    RatingSignature.fromObject = function fromObject(object) {
        if (object instanceof $root.RatingSignature)
            return object;
        var message = new $root.RatingSignature();
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".RatingSignature.metadata: object expected");
            message.metadata = $root.RatingSignature.TransactionMetadata.fromObject(object.metadata);
        }
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from a RatingSignature message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RatingSignature
     * @static
     * @param {RatingSignature} message RatingSignature
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RatingSignature.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.metadata = null;
            object.signature = options.bytes === String ? "" : [];
        }
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RatingSignature.TransactionMetadata.toObject(message.metadata, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        return object;
    };

    /**
     * Converts this RatingSignature to JSON.
     * @function toJSON
     * @memberof RatingSignature
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RatingSignature.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    RatingSignature.TransactionMetadata = (function() {

        /**
         * Properties of a TransactionMetadata.
         * @memberof RatingSignature
         * @interface ITransactionMetadata
         * @property {string|null} [listingSlug] TransactionMetadata listingSlug
         * @property {Uint8Array|null} [ratingKey] TransactionMetadata ratingKey
         * @property {Uint8Array|null} [moderatorKey] TransactionMetadata moderatorKey
         * @property {string|null} [listingTitle] TransactionMetadata listingTitle
         * @property {IImage|null} [thumbnail] TransactionMetadata thumbnail
         */

        /**
         * Constructs a new TransactionMetadata.
         * @memberof RatingSignature
         * @classdesc Represents a TransactionMetadata.
         * @implements ITransactionMetadata
         * @constructor
         * @param {RatingSignature.ITransactionMetadata=} [properties] Properties to set
         */
        function TransactionMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionMetadata listingSlug.
         * @member {string} listingSlug
         * @memberof RatingSignature.TransactionMetadata
         * @instance
         */
        TransactionMetadata.prototype.listingSlug = "";

        /**
         * TransactionMetadata ratingKey.
         * @member {Uint8Array} ratingKey
         * @memberof RatingSignature.TransactionMetadata
         * @instance
         */
        TransactionMetadata.prototype.ratingKey = $util.newBuffer([]);

        /**
         * TransactionMetadata moderatorKey.
         * @member {Uint8Array} moderatorKey
         * @memberof RatingSignature.TransactionMetadata
         * @instance
         */
        TransactionMetadata.prototype.moderatorKey = $util.newBuffer([]);

        /**
         * TransactionMetadata listingTitle.
         * @member {string} listingTitle
         * @memberof RatingSignature.TransactionMetadata
         * @instance
         */
        TransactionMetadata.prototype.listingTitle = "";

        /**
         * TransactionMetadata thumbnail.
         * @member {IImage|null|undefined} thumbnail
         * @memberof RatingSignature.TransactionMetadata
         * @instance
         */
        TransactionMetadata.prototype.thumbnail = null;

        /**
         * Creates a new TransactionMetadata instance using the specified properties.
         * @function create
         * @memberof RatingSignature.TransactionMetadata
         * @static
         * @param {RatingSignature.ITransactionMetadata=} [properties] Properties to set
         * @returns {RatingSignature.TransactionMetadata} TransactionMetadata instance
         */
        TransactionMetadata.create = function create(properties) {
            return new TransactionMetadata(properties);
        };

        /**
         * Encodes the specified TransactionMetadata message. Does not implicitly {@link RatingSignature.TransactionMetadata.verify|verify} messages.
         * @function encode
         * @memberof RatingSignature.TransactionMetadata
         * @static
         * @param {RatingSignature.ITransactionMetadata} message TransactionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.listingSlug != null && message.hasOwnProperty("listingSlug"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.listingSlug);
            if (message.ratingKey != null && message.hasOwnProperty("ratingKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ratingKey);
            if (message.moderatorKey != null && message.hasOwnProperty("moderatorKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.moderatorKey);
            if (message.listingTitle != null && message.hasOwnProperty("listingTitle"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.listingTitle);
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                $root.Image.encode(message.thumbnail, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionMetadata message, length delimited. Does not implicitly {@link RatingSignature.TransactionMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RatingSignature.TransactionMetadata
         * @static
         * @param {RatingSignature.ITransactionMetadata} message TransactionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof RatingSignature.TransactionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RatingSignature.TransactionMetadata} TransactionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RatingSignature.TransactionMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.listingSlug = reader.string();
                    break;
                case 2:
                    message.ratingKey = reader.bytes();
                    break;
                case 3:
                    message.moderatorKey = reader.bytes();
                    break;
                case 4:
                    message.listingTitle = reader.string();
                    break;
                case 5:
                    message.thumbnail = $root.Image.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RatingSignature.TransactionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RatingSignature.TransactionMetadata} TransactionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionMetadata message.
         * @function verify
         * @memberof RatingSignature.TransactionMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.listingSlug != null && message.hasOwnProperty("listingSlug"))
                if (!$util.isString(message.listingSlug))
                    return "listingSlug: string expected";
            if (message.ratingKey != null && message.hasOwnProperty("ratingKey"))
                if (!(message.ratingKey && typeof message.ratingKey.length === "number" || $util.isString(message.ratingKey)))
                    return "ratingKey: buffer expected";
            if (message.moderatorKey != null && message.hasOwnProperty("moderatorKey"))
                if (!(message.moderatorKey && typeof message.moderatorKey.length === "number" || $util.isString(message.moderatorKey)))
                    return "moderatorKey: buffer expected";
            if (message.listingTitle != null && message.hasOwnProperty("listingTitle"))
                if (!$util.isString(message.listingTitle))
                    return "listingTitle: string expected";
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail")) {
                var error = $root.Image.verify(message.thumbnail);
                if (error)
                    return "thumbnail." + error;
            }
            return null;
        };

        /**
         * Creates a TransactionMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RatingSignature.TransactionMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RatingSignature.TransactionMetadata} TransactionMetadata
         */
        TransactionMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.RatingSignature.TransactionMetadata)
                return object;
            var message = new $root.RatingSignature.TransactionMetadata();
            if (object.listingSlug != null)
                message.listingSlug = String(object.listingSlug);
            if (object.ratingKey != null)
                if (typeof object.ratingKey === "string")
                    $util.base64.decode(object.ratingKey, message.ratingKey = $util.newBuffer($util.base64.length(object.ratingKey)), 0);
                else if (object.ratingKey.length)
                    message.ratingKey = object.ratingKey;
            if (object.moderatorKey != null)
                if (typeof object.moderatorKey === "string")
                    $util.base64.decode(object.moderatorKey, message.moderatorKey = $util.newBuffer($util.base64.length(object.moderatorKey)), 0);
                else if (object.moderatorKey.length)
                    message.moderatorKey = object.moderatorKey;
            if (object.listingTitle != null)
                message.listingTitle = String(object.listingTitle);
            if (object.thumbnail != null) {
                if (typeof object.thumbnail !== "object")
                    throw TypeError(".RatingSignature.TransactionMetadata.thumbnail: object expected");
                message.thumbnail = $root.Image.fromObject(object.thumbnail);
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RatingSignature.TransactionMetadata
         * @static
         * @param {RatingSignature.TransactionMetadata} message TransactionMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.listingSlug = "";
                object.ratingKey = options.bytes === String ? "" : [];
                object.moderatorKey = options.bytes === String ? "" : [];
                object.listingTitle = "";
                object.thumbnail = null;
            }
            if (message.listingSlug != null && message.hasOwnProperty("listingSlug"))
                object.listingSlug = message.listingSlug;
            if (message.ratingKey != null && message.hasOwnProperty("ratingKey"))
                object.ratingKey = options.bytes === String ? $util.base64.encode(message.ratingKey, 0, message.ratingKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ratingKey) : message.ratingKey;
            if (message.moderatorKey != null && message.hasOwnProperty("moderatorKey"))
                object.moderatorKey = options.bytes === String ? $util.base64.encode(message.moderatorKey, 0, message.moderatorKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.moderatorKey) : message.moderatorKey;
            if (message.listingTitle != null && message.hasOwnProperty("listingTitle"))
                object.listingTitle = message.listingTitle;
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                object.thumbnail = $root.Image.toObject(message.thumbnail, options);
            return object;
        };

        /**
         * Converts this TransactionMetadata to JSON.
         * @function toJSON
         * @memberof RatingSignature.TransactionMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionMetadata;
    })();

    return RatingSignature;
})();

$root.BitcoinSignature = (function() {

    /**
     * Properties of a BitcoinSignature.
     * @exports IBitcoinSignature
     * @interface IBitcoinSignature
     * @property {number|null} [inputIndex] BitcoinSignature inputIndex
     * @property {Uint8Array|null} [signature] BitcoinSignature signature
     */

    /**
     * Constructs a new BitcoinSignature.
     * @exports BitcoinSignature
     * @classdesc Represents a BitcoinSignature.
     * @implements IBitcoinSignature
     * @constructor
     * @param {IBitcoinSignature=} [properties] Properties to set
     */
    function BitcoinSignature(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BitcoinSignature inputIndex.
     * @member {number} inputIndex
     * @memberof BitcoinSignature
     * @instance
     */
    BitcoinSignature.prototype.inputIndex = 0;

    /**
     * BitcoinSignature signature.
     * @member {Uint8Array} signature
     * @memberof BitcoinSignature
     * @instance
     */
    BitcoinSignature.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new BitcoinSignature instance using the specified properties.
     * @function create
     * @memberof BitcoinSignature
     * @static
     * @param {IBitcoinSignature=} [properties] Properties to set
     * @returns {BitcoinSignature} BitcoinSignature instance
     */
    BitcoinSignature.create = function create(properties) {
        return new BitcoinSignature(properties);
    };

    /**
     * Encodes the specified BitcoinSignature message. Does not implicitly {@link BitcoinSignature.verify|verify} messages.
     * @function encode
     * @memberof BitcoinSignature
     * @static
     * @param {IBitcoinSignature} message BitcoinSignature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BitcoinSignature.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.inputIndex != null && message.hasOwnProperty("inputIndex"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.inputIndex);
        if (message.signature != null && message.hasOwnProperty("signature"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
        return writer;
    };

    /**
     * Encodes the specified BitcoinSignature message, length delimited. Does not implicitly {@link BitcoinSignature.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BitcoinSignature
     * @static
     * @param {IBitcoinSignature} message BitcoinSignature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BitcoinSignature.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BitcoinSignature message from the specified reader or buffer.
     * @function decode
     * @memberof BitcoinSignature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BitcoinSignature} BitcoinSignature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BitcoinSignature.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BitcoinSignature();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.inputIndex = reader.uint32();
                break;
            case 2:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BitcoinSignature message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BitcoinSignature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BitcoinSignature} BitcoinSignature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BitcoinSignature.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BitcoinSignature message.
     * @function verify
     * @memberof BitcoinSignature
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BitcoinSignature.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.inputIndex != null && message.hasOwnProperty("inputIndex"))
            if (!$util.isInteger(message.inputIndex))
                return "inputIndex: integer expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates a BitcoinSignature message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BitcoinSignature
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BitcoinSignature} BitcoinSignature
     */
    BitcoinSignature.fromObject = function fromObject(object) {
        if (object instanceof $root.BitcoinSignature)
            return object;
        var message = new $root.BitcoinSignature();
        if (object.inputIndex != null)
            message.inputIndex = object.inputIndex >>> 0;
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from a BitcoinSignature message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BitcoinSignature
     * @static
     * @param {BitcoinSignature} message BitcoinSignature
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BitcoinSignature.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.inputIndex = 0;
            object.signature = options.bytes === String ? "" : [];
        }
        if (message.inputIndex != null && message.hasOwnProperty("inputIndex"))
            object.inputIndex = message.inputIndex;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        return object;
    };

    /**
     * Converts this BitcoinSignature to JSON.
     * @function toJSON
     * @memberof BitcoinSignature
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BitcoinSignature.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BitcoinSignature;
})();

$root.OrderFulfillment = (function() {

    /**
     * Properties of an OrderFulfillment.
     * @exports IOrderFulfillment
     * @interface IOrderFulfillment
     * @property {string|null} [orderId] OrderFulfillment orderId
     * @property {string|null} [slug] OrderFulfillment slug
     * @property {google.protobuf.ITimestamp|null} [timestamp] OrderFulfillment timestamp
     * @property {Array.<OrderFulfillment.IPhysicalDelivery>|null} [physicalDelivery] OrderFulfillment physicalDelivery
     * @property {Array.<OrderFulfillment.IDigitalDelivery>|null} [digitalDelivery] OrderFulfillment digitalDelivery
     * @property {OrderFulfillment.IPayout|null} [payout] OrderFulfillment payout
     * @property {IRatingSignature|null} [ratingSignature] OrderFulfillment ratingSignature
     * @property {string|null} [note] OrderFulfillment note
     * @property {Array.<OrderFulfillment.ICryptocurrencyDelivery>|null} [cryptocurrencyDelivery] OrderFulfillment cryptocurrencyDelivery
     */

    /**
     * Constructs a new OrderFulfillment.
     * @exports OrderFulfillment
     * @classdesc Represents an OrderFulfillment.
     * @implements IOrderFulfillment
     * @constructor
     * @param {IOrderFulfillment=} [properties] Properties to set
     */
    function OrderFulfillment(properties) {
        this.physicalDelivery = [];
        this.digitalDelivery = [];
        this.cryptocurrencyDelivery = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OrderFulfillment orderId.
     * @member {string} orderId
     * @memberof OrderFulfillment
     * @instance
     */
    OrderFulfillment.prototype.orderId = "";

    /**
     * OrderFulfillment slug.
     * @member {string} slug
     * @memberof OrderFulfillment
     * @instance
     */
    OrderFulfillment.prototype.slug = "";

    /**
     * OrderFulfillment timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof OrderFulfillment
     * @instance
     */
    OrderFulfillment.prototype.timestamp = null;

    /**
     * OrderFulfillment physicalDelivery.
     * @member {Array.<OrderFulfillment.IPhysicalDelivery>} physicalDelivery
     * @memberof OrderFulfillment
     * @instance
     */
    OrderFulfillment.prototype.physicalDelivery = $util.emptyArray;

    /**
     * OrderFulfillment digitalDelivery.
     * @member {Array.<OrderFulfillment.IDigitalDelivery>} digitalDelivery
     * @memberof OrderFulfillment
     * @instance
     */
    OrderFulfillment.prototype.digitalDelivery = $util.emptyArray;

    /**
     * OrderFulfillment payout.
     * @member {OrderFulfillment.IPayout|null|undefined} payout
     * @memberof OrderFulfillment
     * @instance
     */
    OrderFulfillment.prototype.payout = null;

    /**
     * OrderFulfillment ratingSignature.
     * @member {IRatingSignature|null|undefined} ratingSignature
     * @memberof OrderFulfillment
     * @instance
     */
    OrderFulfillment.prototype.ratingSignature = null;

    /**
     * OrderFulfillment note.
     * @member {string} note
     * @memberof OrderFulfillment
     * @instance
     */
    OrderFulfillment.prototype.note = "";

    /**
     * OrderFulfillment cryptocurrencyDelivery.
     * @member {Array.<OrderFulfillment.ICryptocurrencyDelivery>} cryptocurrencyDelivery
     * @memberof OrderFulfillment
     * @instance
     */
    OrderFulfillment.prototype.cryptocurrencyDelivery = $util.emptyArray;

    /**
     * Creates a new OrderFulfillment instance using the specified properties.
     * @function create
     * @memberof OrderFulfillment
     * @static
     * @param {IOrderFulfillment=} [properties] Properties to set
     * @returns {OrderFulfillment} OrderFulfillment instance
     */
    OrderFulfillment.create = function create(properties) {
        return new OrderFulfillment(properties);
    };

    /**
     * Encodes the specified OrderFulfillment message. Does not implicitly {@link OrderFulfillment.verify|verify} messages.
     * @function encode
     * @memberof OrderFulfillment
     * @static
     * @param {IOrderFulfillment} message OrderFulfillment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderFulfillment.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderId);
        if (message.slug != null && message.hasOwnProperty("slug"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.slug);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.physicalDelivery != null && message.physicalDelivery.length)
            for (var i = 0; i < message.physicalDelivery.length; ++i)
                $root.OrderFulfillment.PhysicalDelivery.encode(message.physicalDelivery[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.digitalDelivery != null && message.digitalDelivery.length)
            for (var i = 0; i < message.digitalDelivery.length; ++i)
                $root.OrderFulfillment.DigitalDelivery.encode(message.digitalDelivery[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.payout != null && message.hasOwnProperty("payout"))
            $root.OrderFulfillment.Payout.encode(message.payout, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.ratingSignature != null && message.hasOwnProperty("ratingSignature"))
            $root.RatingSignature.encode(message.ratingSignature, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.note != null && message.hasOwnProperty("note"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.note);
        if (message.cryptocurrencyDelivery != null && message.cryptocurrencyDelivery.length)
            for (var i = 0; i < message.cryptocurrencyDelivery.length; ++i)
                $root.OrderFulfillment.CryptocurrencyDelivery.encode(message.cryptocurrencyDelivery[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OrderFulfillment message, length delimited. Does not implicitly {@link OrderFulfillment.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OrderFulfillment
     * @static
     * @param {IOrderFulfillment} message OrderFulfillment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderFulfillment.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OrderFulfillment message from the specified reader or buffer.
     * @function decode
     * @memberof OrderFulfillment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OrderFulfillment} OrderFulfillment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderFulfillment.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderFulfillment();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.orderId = reader.string();
                break;
            case 2:
                message.slug = reader.string();
                break;
            case 3:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 4:
                if (!(message.physicalDelivery && message.physicalDelivery.length))
                    message.physicalDelivery = [];
                message.physicalDelivery.push($root.OrderFulfillment.PhysicalDelivery.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.digitalDelivery && message.digitalDelivery.length))
                    message.digitalDelivery = [];
                message.digitalDelivery.push($root.OrderFulfillment.DigitalDelivery.decode(reader, reader.uint32()));
                break;
            case 6:
                message.payout = $root.OrderFulfillment.Payout.decode(reader, reader.uint32());
                break;
            case 7:
                message.ratingSignature = $root.RatingSignature.decode(reader, reader.uint32());
                break;
            case 8:
                message.note = reader.string();
                break;
            case 9:
                if (!(message.cryptocurrencyDelivery && message.cryptocurrencyDelivery.length))
                    message.cryptocurrencyDelivery = [];
                message.cryptocurrencyDelivery.push($root.OrderFulfillment.CryptocurrencyDelivery.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OrderFulfillment message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OrderFulfillment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OrderFulfillment} OrderFulfillment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderFulfillment.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OrderFulfillment message.
     * @function verify
     * @memberof OrderFulfillment
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OrderFulfillment.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            if (!$util.isString(message.orderId))
                return "orderId: string expected";
        if (message.slug != null && message.hasOwnProperty("slug"))
            if (!$util.isString(message.slug))
                return "slug: string expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.physicalDelivery != null && message.hasOwnProperty("physicalDelivery")) {
            if (!Array.isArray(message.physicalDelivery))
                return "physicalDelivery: array expected";
            for (var i = 0; i < message.physicalDelivery.length; ++i) {
                var error = $root.OrderFulfillment.PhysicalDelivery.verify(message.physicalDelivery[i]);
                if (error)
                    return "physicalDelivery." + error;
            }
        }
        if (message.digitalDelivery != null && message.hasOwnProperty("digitalDelivery")) {
            if (!Array.isArray(message.digitalDelivery))
                return "digitalDelivery: array expected";
            for (var i = 0; i < message.digitalDelivery.length; ++i) {
                var error = $root.OrderFulfillment.DigitalDelivery.verify(message.digitalDelivery[i]);
                if (error)
                    return "digitalDelivery." + error;
            }
        }
        if (message.payout != null && message.hasOwnProperty("payout")) {
            var error = $root.OrderFulfillment.Payout.verify(message.payout);
            if (error)
                return "payout." + error;
        }
        if (message.ratingSignature != null && message.hasOwnProperty("ratingSignature")) {
            var error = $root.RatingSignature.verify(message.ratingSignature);
            if (error)
                return "ratingSignature." + error;
        }
        if (message.note != null && message.hasOwnProperty("note"))
            if (!$util.isString(message.note))
                return "note: string expected";
        if (message.cryptocurrencyDelivery != null && message.hasOwnProperty("cryptocurrencyDelivery")) {
            if (!Array.isArray(message.cryptocurrencyDelivery))
                return "cryptocurrencyDelivery: array expected";
            for (var i = 0; i < message.cryptocurrencyDelivery.length; ++i) {
                var error = $root.OrderFulfillment.CryptocurrencyDelivery.verify(message.cryptocurrencyDelivery[i]);
                if (error)
                    return "cryptocurrencyDelivery." + error;
            }
        }
        return null;
    };

    /**
     * Creates an OrderFulfillment message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OrderFulfillment
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OrderFulfillment} OrderFulfillment
     */
    OrderFulfillment.fromObject = function fromObject(object) {
        if (object instanceof $root.OrderFulfillment)
            return object;
        var message = new $root.OrderFulfillment();
        if (object.orderId != null)
            message.orderId = String(object.orderId);
        if (object.slug != null)
            message.slug = String(object.slug);
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".OrderFulfillment.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.physicalDelivery) {
            if (!Array.isArray(object.physicalDelivery))
                throw TypeError(".OrderFulfillment.physicalDelivery: array expected");
            message.physicalDelivery = [];
            for (var i = 0; i < object.physicalDelivery.length; ++i) {
                if (typeof object.physicalDelivery[i] !== "object")
                    throw TypeError(".OrderFulfillment.physicalDelivery: object expected");
                message.physicalDelivery[i] = $root.OrderFulfillment.PhysicalDelivery.fromObject(object.physicalDelivery[i]);
            }
        }
        if (object.digitalDelivery) {
            if (!Array.isArray(object.digitalDelivery))
                throw TypeError(".OrderFulfillment.digitalDelivery: array expected");
            message.digitalDelivery = [];
            for (var i = 0; i < object.digitalDelivery.length; ++i) {
                if (typeof object.digitalDelivery[i] !== "object")
                    throw TypeError(".OrderFulfillment.digitalDelivery: object expected");
                message.digitalDelivery[i] = $root.OrderFulfillment.DigitalDelivery.fromObject(object.digitalDelivery[i]);
            }
        }
        if (object.payout != null) {
            if (typeof object.payout !== "object")
                throw TypeError(".OrderFulfillment.payout: object expected");
            message.payout = $root.OrderFulfillment.Payout.fromObject(object.payout);
        }
        if (object.ratingSignature != null) {
            if (typeof object.ratingSignature !== "object")
                throw TypeError(".OrderFulfillment.ratingSignature: object expected");
            message.ratingSignature = $root.RatingSignature.fromObject(object.ratingSignature);
        }
        if (object.note != null)
            message.note = String(object.note);
        if (object.cryptocurrencyDelivery) {
            if (!Array.isArray(object.cryptocurrencyDelivery))
                throw TypeError(".OrderFulfillment.cryptocurrencyDelivery: array expected");
            message.cryptocurrencyDelivery = [];
            for (var i = 0; i < object.cryptocurrencyDelivery.length; ++i) {
                if (typeof object.cryptocurrencyDelivery[i] !== "object")
                    throw TypeError(".OrderFulfillment.cryptocurrencyDelivery: object expected");
                message.cryptocurrencyDelivery[i] = $root.OrderFulfillment.CryptocurrencyDelivery.fromObject(object.cryptocurrencyDelivery[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an OrderFulfillment message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OrderFulfillment
     * @static
     * @param {OrderFulfillment} message OrderFulfillment
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OrderFulfillment.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.physicalDelivery = [];
            object.digitalDelivery = [];
            object.cryptocurrencyDelivery = [];
        }
        if (options.defaults) {
            object.orderId = "";
            object.slug = "";
            object.timestamp = null;
            object.payout = null;
            object.ratingSignature = null;
            object.note = "";
        }
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            object.orderId = message.orderId;
        if (message.slug != null && message.hasOwnProperty("slug"))
            object.slug = message.slug;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.physicalDelivery && message.physicalDelivery.length) {
            object.physicalDelivery = [];
            for (var j = 0; j < message.physicalDelivery.length; ++j)
                object.physicalDelivery[j] = $root.OrderFulfillment.PhysicalDelivery.toObject(message.physicalDelivery[j], options);
        }
        if (message.digitalDelivery && message.digitalDelivery.length) {
            object.digitalDelivery = [];
            for (var j = 0; j < message.digitalDelivery.length; ++j)
                object.digitalDelivery[j] = $root.OrderFulfillment.DigitalDelivery.toObject(message.digitalDelivery[j], options);
        }
        if (message.payout != null && message.hasOwnProperty("payout"))
            object.payout = $root.OrderFulfillment.Payout.toObject(message.payout, options);
        if (message.ratingSignature != null && message.hasOwnProperty("ratingSignature"))
            object.ratingSignature = $root.RatingSignature.toObject(message.ratingSignature, options);
        if (message.note != null && message.hasOwnProperty("note"))
            object.note = message.note;
        if (message.cryptocurrencyDelivery && message.cryptocurrencyDelivery.length) {
            object.cryptocurrencyDelivery = [];
            for (var j = 0; j < message.cryptocurrencyDelivery.length; ++j)
                object.cryptocurrencyDelivery[j] = $root.OrderFulfillment.CryptocurrencyDelivery.toObject(message.cryptocurrencyDelivery[j], options);
        }
        return object;
    };

    /**
     * Converts this OrderFulfillment to JSON.
     * @function toJSON
     * @memberof OrderFulfillment
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OrderFulfillment.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    OrderFulfillment.PhysicalDelivery = (function() {

        /**
         * Properties of a PhysicalDelivery.
         * @memberof OrderFulfillment
         * @interface IPhysicalDelivery
         * @property {string|null} [shipper] PhysicalDelivery shipper
         * @property {string|null} [trackingNumber] PhysicalDelivery trackingNumber
         */

        /**
         * Constructs a new PhysicalDelivery.
         * @memberof OrderFulfillment
         * @classdesc Represents a PhysicalDelivery.
         * @implements IPhysicalDelivery
         * @constructor
         * @param {OrderFulfillment.IPhysicalDelivery=} [properties] Properties to set
         */
        function PhysicalDelivery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PhysicalDelivery shipper.
         * @member {string} shipper
         * @memberof OrderFulfillment.PhysicalDelivery
         * @instance
         */
        PhysicalDelivery.prototype.shipper = "";

        /**
         * PhysicalDelivery trackingNumber.
         * @member {string} trackingNumber
         * @memberof OrderFulfillment.PhysicalDelivery
         * @instance
         */
        PhysicalDelivery.prototype.trackingNumber = "";

        /**
         * Creates a new PhysicalDelivery instance using the specified properties.
         * @function create
         * @memberof OrderFulfillment.PhysicalDelivery
         * @static
         * @param {OrderFulfillment.IPhysicalDelivery=} [properties] Properties to set
         * @returns {OrderFulfillment.PhysicalDelivery} PhysicalDelivery instance
         */
        PhysicalDelivery.create = function create(properties) {
            return new PhysicalDelivery(properties);
        };

        /**
         * Encodes the specified PhysicalDelivery message. Does not implicitly {@link OrderFulfillment.PhysicalDelivery.verify|verify} messages.
         * @function encode
         * @memberof OrderFulfillment.PhysicalDelivery
         * @static
         * @param {OrderFulfillment.IPhysicalDelivery} message PhysicalDelivery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PhysicalDelivery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shipper != null && message.hasOwnProperty("shipper"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.shipper);
            if (message.trackingNumber != null && message.hasOwnProperty("trackingNumber"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.trackingNumber);
            return writer;
        };

        /**
         * Encodes the specified PhysicalDelivery message, length delimited. Does not implicitly {@link OrderFulfillment.PhysicalDelivery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof OrderFulfillment.PhysicalDelivery
         * @static
         * @param {OrderFulfillment.IPhysicalDelivery} message PhysicalDelivery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PhysicalDelivery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PhysicalDelivery message from the specified reader or buffer.
         * @function decode
         * @memberof OrderFulfillment.PhysicalDelivery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OrderFulfillment.PhysicalDelivery} PhysicalDelivery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PhysicalDelivery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderFulfillment.PhysicalDelivery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shipper = reader.string();
                    break;
                case 2:
                    message.trackingNumber = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PhysicalDelivery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof OrderFulfillment.PhysicalDelivery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {OrderFulfillment.PhysicalDelivery} PhysicalDelivery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PhysicalDelivery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PhysicalDelivery message.
         * @function verify
         * @memberof OrderFulfillment.PhysicalDelivery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PhysicalDelivery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shipper != null && message.hasOwnProperty("shipper"))
                if (!$util.isString(message.shipper))
                    return "shipper: string expected";
            if (message.trackingNumber != null && message.hasOwnProperty("trackingNumber"))
                if (!$util.isString(message.trackingNumber))
                    return "trackingNumber: string expected";
            return null;
        };

        /**
         * Creates a PhysicalDelivery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof OrderFulfillment.PhysicalDelivery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {OrderFulfillment.PhysicalDelivery} PhysicalDelivery
         */
        PhysicalDelivery.fromObject = function fromObject(object) {
            if (object instanceof $root.OrderFulfillment.PhysicalDelivery)
                return object;
            var message = new $root.OrderFulfillment.PhysicalDelivery();
            if (object.shipper != null)
                message.shipper = String(object.shipper);
            if (object.trackingNumber != null)
                message.trackingNumber = String(object.trackingNumber);
            return message;
        };

        /**
         * Creates a plain object from a PhysicalDelivery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof OrderFulfillment.PhysicalDelivery
         * @static
         * @param {OrderFulfillment.PhysicalDelivery} message PhysicalDelivery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PhysicalDelivery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.shipper = "";
                object.trackingNumber = "";
            }
            if (message.shipper != null && message.hasOwnProperty("shipper"))
                object.shipper = message.shipper;
            if (message.trackingNumber != null && message.hasOwnProperty("trackingNumber"))
                object.trackingNumber = message.trackingNumber;
            return object;
        };

        /**
         * Converts this PhysicalDelivery to JSON.
         * @function toJSON
         * @memberof OrderFulfillment.PhysicalDelivery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PhysicalDelivery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PhysicalDelivery;
    })();

    OrderFulfillment.DigitalDelivery = (function() {

        /**
         * Properties of a DigitalDelivery.
         * @memberof OrderFulfillment
         * @interface IDigitalDelivery
         * @property {string|null} [url] DigitalDelivery url
         * @property {string|null} [password] DigitalDelivery password
         */

        /**
         * Constructs a new DigitalDelivery.
         * @memberof OrderFulfillment
         * @classdesc Represents a DigitalDelivery.
         * @implements IDigitalDelivery
         * @constructor
         * @param {OrderFulfillment.IDigitalDelivery=} [properties] Properties to set
         */
        function DigitalDelivery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DigitalDelivery url.
         * @member {string} url
         * @memberof OrderFulfillment.DigitalDelivery
         * @instance
         */
        DigitalDelivery.prototype.url = "";

        /**
         * DigitalDelivery password.
         * @member {string} password
         * @memberof OrderFulfillment.DigitalDelivery
         * @instance
         */
        DigitalDelivery.prototype.password = "";

        /**
         * Creates a new DigitalDelivery instance using the specified properties.
         * @function create
         * @memberof OrderFulfillment.DigitalDelivery
         * @static
         * @param {OrderFulfillment.IDigitalDelivery=} [properties] Properties to set
         * @returns {OrderFulfillment.DigitalDelivery} DigitalDelivery instance
         */
        DigitalDelivery.create = function create(properties) {
            return new DigitalDelivery(properties);
        };

        /**
         * Encodes the specified DigitalDelivery message. Does not implicitly {@link OrderFulfillment.DigitalDelivery.verify|verify} messages.
         * @function encode
         * @memberof OrderFulfillment.DigitalDelivery
         * @static
         * @param {OrderFulfillment.IDigitalDelivery} message DigitalDelivery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DigitalDelivery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.password != null && message.hasOwnProperty("password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified DigitalDelivery message, length delimited. Does not implicitly {@link OrderFulfillment.DigitalDelivery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof OrderFulfillment.DigitalDelivery
         * @static
         * @param {OrderFulfillment.IDigitalDelivery} message DigitalDelivery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DigitalDelivery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DigitalDelivery message from the specified reader or buffer.
         * @function decode
         * @memberof OrderFulfillment.DigitalDelivery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OrderFulfillment.DigitalDelivery} DigitalDelivery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DigitalDelivery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderFulfillment.DigitalDelivery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DigitalDelivery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof OrderFulfillment.DigitalDelivery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {OrderFulfillment.DigitalDelivery} DigitalDelivery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DigitalDelivery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DigitalDelivery message.
         * @function verify
         * @memberof OrderFulfillment.DigitalDelivery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DigitalDelivery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates a DigitalDelivery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof OrderFulfillment.DigitalDelivery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {OrderFulfillment.DigitalDelivery} DigitalDelivery
         */
        DigitalDelivery.fromObject = function fromObject(object) {
            if (object instanceof $root.OrderFulfillment.DigitalDelivery)
                return object;
            var message = new $root.OrderFulfillment.DigitalDelivery();
            if (object.url != null)
                message.url = String(object.url);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from a DigitalDelivery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof OrderFulfillment.DigitalDelivery
         * @static
         * @param {OrderFulfillment.DigitalDelivery} message DigitalDelivery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DigitalDelivery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.url = "";
                object.password = "";
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this DigitalDelivery to JSON.
         * @function toJSON
         * @memberof OrderFulfillment.DigitalDelivery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DigitalDelivery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DigitalDelivery;
    })();

    OrderFulfillment.CryptocurrencyDelivery = (function() {

        /**
         * Properties of a CryptocurrencyDelivery.
         * @memberof OrderFulfillment
         * @interface ICryptocurrencyDelivery
         * @property {string|null} [transactionID] CryptocurrencyDelivery transactionID
         */

        /**
         * Constructs a new CryptocurrencyDelivery.
         * @memberof OrderFulfillment
         * @classdesc Represents a CryptocurrencyDelivery.
         * @implements ICryptocurrencyDelivery
         * @constructor
         * @param {OrderFulfillment.ICryptocurrencyDelivery=} [properties] Properties to set
         */
        function CryptocurrencyDelivery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CryptocurrencyDelivery transactionID.
         * @member {string} transactionID
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @instance
         */
        CryptocurrencyDelivery.prototype.transactionID = "";

        /**
         * Creates a new CryptocurrencyDelivery instance using the specified properties.
         * @function create
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @static
         * @param {OrderFulfillment.ICryptocurrencyDelivery=} [properties] Properties to set
         * @returns {OrderFulfillment.CryptocurrencyDelivery} CryptocurrencyDelivery instance
         */
        CryptocurrencyDelivery.create = function create(properties) {
            return new CryptocurrencyDelivery(properties);
        };

        /**
         * Encodes the specified CryptocurrencyDelivery message. Does not implicitly {@link OrderFulfillment.CryptocurrencyDelivery.verify|verify} messages.
         * @function encode
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @static
         * @param {OrderFulfillment.ICryptocurrencyDelivery} message CryptocurrencyDelivery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptocurrencyDelivery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactionID != null && message.hasOwnProperty("transactionID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.transactionID);
            return writer;
        };

        /**
         * Encodes the specified CryptocurrencyDelivery message, length delimited. Does not implicitly {@link OrderFulfillment.CryptocurrencyDelivery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @static
         * @param {OrderFulfillment.ICryptocurrencyDelivery} message CryptocurrencyDelivery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptocurrencyDelivery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CryptocurrencyDelivery message from the specified reader or buffer.
         * @function decode
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OrderFulfillment.CryptocurrencyDelivery} CryptocurrencyDelivery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptocurrencyDelivery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderFulfillment.CryptocurrencyDelivery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.transactionID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CryptocurrencyDelivery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {OrderFulfillment.CryptocurrencyDelivery} CryptocurrencyDelivery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptocurrencyDelivery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CryptocurrencyDelivery message.
         * @function verify
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CryptocurrencyDelivery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactionID != null && message.hasOwnProperty("transactionID"))
                if (!$util.isString(message.transactionID))
                    return "transactionID: string expected";
            return null;
        };

        /**
         * Creates a CryptocurrencyDelivery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {OrderFulfillment.CryptocurrencyDelivery} CryptocurrencyDelivery
         */
        CryptocurrencyDelivery.fromObject = function fromObject(object) {
            if (object instanceof $root.OrderFulfillment.CryptocurrencyDelivery)
                return object;
            var message = new $root.OrderFulfillment.CryptocurrencyDelivery();
            if (object.transactionID != null)
                message.transactionID = String(object.transactionID);
            return message;
        };

        /**
         * Creates a plain object from a CryptocurrencyDelivery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @static
         * @param {OrderFulfillment.CryptocurrencyDelivery} message CryptocurrencyDelivery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CryptocurrencyDelivery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.transactionID = "";
            if (message.transactionID != null && message.hasOwnProperty("transactionID"))
                object.transactionID = message.transactionID;
            return object;
        };

        /**
         * Converts this CryptocurrencyDelivery to JSON.
         * @function toJSON
         * @memberof OrderFulfillment.CryptocurrencyDelivery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CryptocurrencyDelivery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CryptocurrencyDelivery;
    })();

    OrderFulfillment.Payout = (function() {

        /**
         * Properties of a Payout.
         * @memberof OrderFulfillment
         * @interface IPayout
         * @property {Array.<IBitcoinSignature>|null} [sigs] Payout sigs
         * @property {string|null} [payoutAddress] Payout payoutAddress
         * @property {number|Long|null} [payoutFeePerByte] Payout payoutFeePerByte
         */

        /**
         * Constructs a new Payout.
         * @memberof OrderFulfillment
         * @classdesc Represents a Payout.
         * @implements IPayout
         * @constructor
         * @param {OrderFulfillment.IPayout=} [properties] Properties to set
         */
        function Payout(properties) {
            this.sigs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Payout sigs.
         * @member {Array.<IBitcoinSignature>} sigs
         * @memberof OrderFulfillment.Payout
         * @instance
         */
        Payout.prototype.sigs = $util.emptyArray;

        /**
         * Payout payoutAddress.
         * @member {string} payoutAddress
         * @memberof OrderFulfillment.Payout
         * @instance
         */
        Payout.prototype.payoutAddress = "";

        /**
         * Payout payoutFeePerByte.
         * @member {number|Long} payoutFeePerByte
         * @memberof OrderFulfillment.Payout
         * @instance
         */
        Payout.prototype.payoutFeePerByte = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Payout instance using the specified properties.
         * @function create
         * @memberof OrderFulfillment.Payout
         * @static
         * @param {OrderFulfillment.IPayout=} [properties] Properties to set
         * @returns {OrderFulfillment.Payout} Payout instance
         */
        Payout.create = function create(properties) {
            return new Payout(properties);
        };

        /**
         * Encodes the specified Payout message. Does not implicitly {@link OrderFulfillment.Payout.verify|verify} messages.
         * @function encode
         * @memberof OrderFulfillment.Payout
         * @static
         * @param {OrderFulfillment.IPayout} message Payout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payout.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sigs != null && message.sigs.length)
                for (var i = 0; i < message.sigs.length; ++i)
                    $root.BitcoinSignature.encode(message.sigs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.payoutAddress != null && message.hasOwnProperty("payoutAddress"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.payoutAddress);
            if (message.payoutFeePerByte != null && message.hasOwnProperty("payoutFeePerByte"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.payoutFeePerByte);
            return writer;
        };

        /**
         * Encodes the specified Payout message, length delimited. Does not implicitly {@link OrderFulfillment.Payout.verify|verify} messages.
         * @function encodeDelimited
         * @memberof OrderFulfillment.Payout
         * @static
         * @param {OrderFulfillment.IPayout} message Payout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payout.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Payout message from the specified reader or buffer.
         * @function decode
         * @memberof OrderFulfillment.Payout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OrderFulfillment.Payout} Payout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payout.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderFulfillment.Payout();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sigs && message.sigs.length))
                        message.sigs = [];
                    message.sigs.push($root.BitcoinSignature.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.payoutAddress = reader.string();
                    break;
                case 3:
                    message.payoutFeePerByte = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Payout message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof OrderFulfillment.Payout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {OrderFulfillment.Payout} Payout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payout.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Payout message.
         * @function verify
         * @memberof OrderFulfillment.Payout
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Payout.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sigs != null && message.hasOwnProperty("sigs")) {
                if (!Array.isArray(message.sigs))
                    return "sigs: array expected";
                for (var i = 0; i < message.sigs.length; ++i) {
                    var error = $root.BitcoinSignature.verify(message.sigs[i]);
                    if (error)
                        return "sigs." + error;
                }
            }
            if (message.payoutAddress != null && message.hasOwnProperty("payoutAddress"))
                if (!$util.isString(message.payoutAddress))
                    return "payoutAddress: string expected";
            if (message.payoutFeePerByte != null && message.hasOwnProperty("payoutFeePerByte"))
                if (!$util.isInteger(message.payoutFeePerByte) && !(message.payoutFeePerByte && $util.isInteger(message.payoutFeePerByte.low) && $util.isInteger(message.payoutFeePerByte.high)))
                    return "payoutFeePerByte: integer|Long expected";
            return null;
        };

        /**
         * Creates a Payout message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof OrderFulfillment.Payout
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {OrderFulfillment.Payout} Payout
         */
        Payout.fromObject = function fromObject(object) {
            if (object instanceof $root.OrderFulfillment.Payout)
                return object;
            var message = new $root.OrderFulfillment.Payout();
            if (object.sigs) {
                if (!Array.isArray(object.sigs))
                    throw TypeError(".OrderFulfillment.Payout.sigs: array expected");
                message.sigs = [];
                for (var i = 0; i < object.sigs.length; ++i) {
                    if (typeof object.sigs[i] !== "object")
                        throw TypeError(".OrderFulfillment.Payout.sigs: object expected");
                    message.sigs[i] = $root.BitcoinSignature.fromObject(object.sigs[i]);
                }
            }
            if (object.payoutAddress != null)
                message.payoutAddress = String(object.payoutAddress);
            if (object.payoutFeePerByte != null)
                if ($util.Long)
                    (message.payoutFeePerByte = $util.Long.fromValue(object.payoutFeePerByte)).unsigned = true;
                else if (typeof object.payoutFeePerByte === "string")
                    message.payoutFeePerByte = parseInt(object.payoutFeePerByte, 10);
                else if (typeof object.payoutFeePerByte === "number")
                    message.payoutFeePerByte = object.payoutFeePerByte;
                else if (typeof object.payoutFeePerByte === "object")
                    message.payoutFeePerByte = new $util.LongBits(object.payoutFeePerByte.low >>> 0, object.payoutFeePerByte.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a Payout message. Also converts values to other types if specified.
         * @function toObject
         * @memberof OrderFulfillment.Payout
         * @static
         * @param {OrderFulfillment.Payout} message Payout
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Payout.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sigs = [];
            if (options.defaults) {
                object.payoutAddress = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.payoutFeePerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.payoutFeePerByte = options.longs === String ? "0" : 0;
            }
            if (message.sigs && message.sigs.length) {
                object.sigs = [];
                for (var j = 0; j < message.sigs.length; ++j)
                    object.sigs[j] = $root.BitcoinSignature.toObject(message.sigs[j], options);
            }
            if (message.payoutAddress != null && message.hasOwnProperty("payoutAddress"))
                object.payoutAddress = message.payoutAddress;
            if (message.payoutFeePerByte != null && message.hasOwnProperty("payoutFeePerByte"))
                if (typeof message.payoutFeePerByte === "number")
                    object.payoutFeePerByte = options.longs === String ? String(message.payoutFeePerByte) : message.payoutFeePerByte;
                else
                    object.payoutFeePerByte = options.longs === String ? $util.Long.prototype.toString.call(message.payoutFeePerByte) : options.longs === Number ? new $util.LongBits(message.payoutFeePerByte.low >>> 0, message.payoutFeePerByte.high >>> 0).toNumber(true) : message.payoutFeePerByte;
            return object;
        };

        /**
         * Converts this Payout to JSON.
         * @function toJSON
         * @memberof OrderFulfillment.Payout
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Payout.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Payout;
    })();

    return OrderFulfillment;
})();

$root.OrderCompletion = (function() {

    /**
     * Properties of an OrderCompletion.
     * @exports IOrderCompletion
     * @interface IOrderCompletion
     * @property {string|null} [orderId] OrderCompletion orderId
     * @property {google.protobuf.ITimestamp|null} [timestamp] OrderCompletion timestamp
     * @property {Array.<IBitcoinSignature>|null} [payoutSigs] OrderCompletion payoutSigs
     * @property {Array.<IRating>|null} [ratings] OrderCompletion ratings
     */

    /**
     * Constructs a new OrderCompletion.
     * @exports OrderCompletion
     * @classdesc Represents an OrderCompletion.
     * @implements IOrderCompletion
     * @constructor
     * @param {IOrderCompletion=} [properties] Properties to set
     */
    function OrderCompletion(properties) {
        this.payoutSigs = [];
        this.ratings = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OrderCompletion orderId.
     * @member {string} orderId
     * @memberof OrderCompletion
     * @instance
     */
    OrderCompletion.prototype.orderId = "";

    /**
     * OrderCompletion timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof OrderCompletion
     * @instance
     */
    OrderCompletion.prototype.timestamp = null;

    /**
     * OrderCompletion payoutSigs.
     * @member {Array.<IBitcoinSignature>} payoutSigs
     * @memberof OrderCompletion
     * @instance
     */
    OrderCompletion.prototype.payoutSigs = $util.emptyArray;

    /**
     * OrderCompletion ratings.
     * @member {Array.<IRating>} ratings
     * @memberof OrderCompletion
     * @instance
     */
    OrderCompletion.prototype.ratings = $util.emptyArray;

    /**
     * Creates a new OrderCompletion instance using the specified properties.
     * @function create
     * @memberof OrderCompletion
     * @static
     * @param {IOrderCompletion=} [properties] Properties to set
     * @returns {OrderCompletion} OrderCompletion instance
     */
    OrderCompletion.create = function create(properties) {
        return new OrderCompletion(properties);
    };

    /**
     * Encodes the specified OrderCompletion message. Does not implicitly {@link OrderCompletion.verify|verify} messages.
     * @function encode
     * @memberof OrderCompletion
     * @static
     * @param {IOrderCompletion} message OrderCompletion message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderCompletion.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderId);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.payoutSigs != null && message.payoutSigs.length)
            for (var i = 0; i < message.payoutSigs.length; ++i)
                $root.BitcoinSignature.encode(message.payoutSigs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.ratings != null && message.ratings.length)
            for (var i = 0; i < message.ratings.length; ++i)
                $root.Rating.encode(message.ratings[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OrderCompletion message, length delimited. Does not implicitly {@link OrderCompletion.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OrderCompletion
     * @static
     * @param {IOrderCompletion} message OrderCompletion message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OrderCompletion.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OrderCompletion message from the specified reader or buffer.
     * @function decode
     * @memberof OrderCompletion
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OrderCompletion} OrderCompletion
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderCompletion.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OrderCompletion();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.orderId = reader.string();
                break;
            case 2:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.payoutSigs && message.payoutSigs.length))
                    message.payoutSigs = [];
                message.payoutSigs.push($root.BitcoinSignature.decode(reader, reader.uint32()));
                break;
            case 4:
                if (!(message.ratings && message.ratings.length))
                    message.ratings = [];
                message.ratings.push($root.Rating.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OrderCompletion message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OrderCompletion
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OrderCompletion} OrderCompletion
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OrderCompletion.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OrderCompletion message.
     * @function verify
     * @memberof OrderCompletion
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OrderCompletion.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            if (!$util.isString(message.orderId))
                return "orderId: string expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.payoutSigs != null && message.hasOwnProperty("payoutSigs")) {
            if (!Array.isArray(message.payoutSigs))
                return "payoutSigs: array expected";
            for (var i = 0; i < message.payoutSigs.length; ++i) {
                var error = $root.BitcoinSignature.verify(message.payoutSigs[i]);
                if (error)
                    return "payoutSigs." + error;
            }
        }
        if (message.ratings != null && message.hasOwnProperty("ratings")) {
            if (!Array.isArray(message.ratings))
                return "ratings: array expected";
            for (var i = 0; i < message.ratings.length; ++i) {
                var error = $root.Rating.verify(message.ratings[i]);
                if (error)
                    return "ratings." + error;
            }
        }
        return null;
    };

    /**
     * Creates an OrderCompletion message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OrderCompletion
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OrderCompletion} OrderCompletion
     */
    OrderCompletion.fromObject = function fromObject(object) {
        if (object instanceof $root.OrderCompletion)
            return object;
        var message = new $root.OrderCompletion();
        if (object.orderId != null)
            message.orderId = String(object.orderId);
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".OrderCompletion.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.payoutSigs) {
            if (!Array.isArray(object.payoutSigs))
                throw TypeError(".OrderCompletion.payoutSigs: array expected");
            message.payoutSigs = [];
            for (var i = 0; i < object.payoutSigs.length; ++i) {
                if (typeof object.payoutSigs[i] !== "object")
                    throw TypeError(".OrderCompletion.payoutSigs: object expected");
                message.payoutSigs[i] = $root.BitcoinSignature.fromObject(object.payoutSigs[i]);
            }
        }
        if (object.ratings) {
            if (!Array.isArray(object.ratings))
                throw TypeError(".OrderCompletion.ratings: array expected");
            message.ratings = [];
            for (var i = 0; i < object.ratings.length; ++i) {
                if (typeof object.ratings[i] !== "object")
                    throw TypeError(".OrderCompletion.ratings: object expected");
                message.ratings[i] = $root.Rating.fromObject(object.ratings[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an OrderCompletion message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OrderCompletion
     * @static
     * @param {OrderCompletion} message OrderCompletion
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OrderCompletion.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.payoutSigs = [];
            object.ratings = [];
        }
        if (options.defaults) {
            object.orderId = "";
            object.timestamp = null;
        }
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            object.orderId = message.orderId;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.payoutSigs && message.payoutSigs.length) {
            object.payoutSigs = [];
            for (var j = 0; j < message.payoutSigs.length; ++j)
                object.payoutSigs[j] = $root.BitcoinSignature.toObject(message.payoutSigs[j], options);
        }
        if (message.ratings && message.ratings.length) {
            object.ratings = [];
            for (var j = 0; j < message.ratings.length; ++j)
                object.ratings[j] = $root.Rating.toObject(message.ratings[j], options);
        }
        return object;
    };

    /**
     * Converts this OrderCompletion to JSON.
     * @function toJSON
     * @memberof OrderCompletion
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OrderCompletion.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OrderCompletion;
})();

$root.Rating = (function() {

    /**
     * Properties of a Rating.
     * @exports IRating
     * @interface IRating
     * @property {Rating.IRatingData|null} [ratingData] Rating ratingData
     * @property {Uint8Array|null} [signature] Rating signature
     */

    /**
     * Constructs a new Rating.
     * @exports Rating
     * @classdesc Represents a Rating.
     * @implements IRating
     * @constructor
     * @param {IRating=} [properties] Properties to set
     */
    function Rating(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Rating ratingData.
     * @member {Rating.IRatingData|null|undefined} ratingData
     * @memberof Rating
     * @instance
     */
    Rating.prototype.ratingData = null;

    /**
     * Rating signature.
     * @member {Uint8Array} signature
     * @memberof Rating
     * @instance
     */
    Rating.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new Rating instance using the specified properties.
     * @function create
     * @memberof Rating
     * @static
     * @param {IRating=} [properties] Properties to set
     * @returns {Rating} Rating instance
     */
    Rating.create = function create(properties) {
        return new Rating(properties);
    };

    /**
     * Encodes the specified Rating message. Does not implicitly {@link Rating.verify|verify} messages.
     * @function encode
     * @memberof Rating
     * @static
     * @param {IRating} message Rating message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Rating.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.ratingData != null && message.hasOwnProperty("ratingData"))
            $root.Rating.RatingData.encode(message.ratingData, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.signature != null && message.hasOwnProperty("signature"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
        return writer;
    };

    /**
     * Encodes the specified Rating message, length delimited. Does not implicitly {@link Rating.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Rating
     * @static
     * @param {IRating} message Rating message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Rating.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Rating message from the specified reader or buffer.
     * @function decode
     * @memberof Rating
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Rating} Rating
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Rating.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Rating();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.ratingData = $root.Rating.RatingData.decode(reader, reader.uint32());
                break;
            case 2:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Rating message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Rating
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Rating} Rating
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Rating.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Rating message.
     * @function verify
     * @memberof Rating
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Rating.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.ratingData != null && message.hasOwnProperty("ratingData")) {
            var error = $root.Rating.RatingData.verify(message.ratingData);
            if (error)
                return "ratingData." + error;
        }
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates a Rating message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Rating
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Rating} Rating
     */
    Rating.fromObject = function fromObject(object) {
        if (object instanceof $root.Rating)
            return object;
        var message = new $root.Rating();
        if (object.ratingData != null) {
            if (typeof object.ratingData !== "object")
                throw TypeError(".Rating.ratingData: object expected");
            message.ratingData = $root.Rating.RatingData.fromObject(object.ratingData);
        }
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from a Rating message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Rating
     * @static
     * @param {Rating} message Rating
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Rating.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.ratingData = null;
            object.signature = options.bytes === String ? "" : [];
        }
        if (message.ratingData != null && message.hasOwnProperty("ratingData"))
            object.ratingData = $root.Rating.RatingData.toObject(message.ratingData, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        return object;
    };

    /**
     * Converts this Rating to JSON.
     * @function toJSON
     * @memberof Rating
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Rating.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Rating.RatingData = (function() {

        /**
         * Properties of a RatingData.
         * @memberof Rating
         * @interface IRatingData
         * @property {Uint8Array|null} [ratingKey] RatingData ratingKey
         * @property {IID|null} [vendorID] RatingData vendorID
         * @property {IRatingSignature|null} [vendorSig] RatingData vendorSig
         * @property {IID|null} [buyerID] RatingData buyerID
         * @property {string|null} [buyerName] RatingData buyerName
         * @property {Uint8Array|null} [buyerSig] RatingData buyerSig
         * @property {Uint8Array|null} [moderatorSig] RatingData moderatorSig
         * @property {google.protobuf.ITimestamp|null} [timestamp] RatingData timestamp
         * @property {number|null} [overall] RatingData overall
         * @property {number|null} [quality] RatingData quality
         * @property {number|null} [description] RatingData description
         * @property {number|null} [deliverySpeed] RatingData deliverySpeed
         * @property {number|null} [customerService] RatingData customerService
         * @property {string|null} [review] RatingData review
         */

        /**
         * Constructs a new RatingData.
         * @memberof Rating
         * @classdesc Represents a RatingData.
         * @implements IRatingData
         * @constructor
         * @param {Rating.IRatingData=} [properties] Properties to set
         */
        function RatingData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RatingData ratingKey.
         * @member {Uint8Array} ratingKey
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.ratingKey = $util.newBuffer([]);

        /**
         * RatingData vendorID.
         * @member {IID|null|undefined} vendorID
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.vendorID = null;

        /**
         * RatingData vendorSig.
         * @member {IRatingSignature|null|undefined} vendorSig
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.vendorSig = null;

        /**
         * RatingData buyerID.
         * @member {IID|null|undefined} buyerID
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.buyerID = null;

        /**
         * RatingData buyerName.
         * @member {string} buyerName
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.buyerName = "";

        /**
         * RatingData buyerSig.
         * @member {Uint8Array} buyerSig
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.buyerSig = $util.newBuffer([]);

        /**
         * RatingData moderatorSig.
         * @member {Uint8Array} moderatorSig
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.moderatorSig = $util.newBuffer([]);

        /**
         * RatingData timestamp.
         * @member {google.protobuf.ITimestamp|null|undefined} timestamp
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.timestamp = null;

        /**
         * RatingData overall.
         * @member {number} overall
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.overall = 0;

        /**
         * RatingData quality.
         * @member {number} quality
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.quality = 0;

        /**
         * RatingData description.
         * @member {number} description
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.description = 0;

        /**
         * RatingData deliverySpeed.
         * @member {number} deliverySpeed
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.deliverySpeed = 0;

        /**
         * RatingData customerService.
         * @member {number} customerService
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.customerService = 0;

        /**
         * RatingData review.
         * @member {string} review
         * @memberof Rating.RatingData
         * @instance
         */
        RatingData.prototype.review = "";

        /**
         * Creates a new RatingData instance using the specified properties.
         * @function create
         * @memberof Rating.RatingData
         * @static
         * @param {Rating.IRatingData=} [properties] Properties to set
         * @returns {Rating.RatingData} RatingData instance
         */
        RatingData.create = function create(properties) {
            return new RatingData(properties);
        };

        /**
         * Encodes the specified RatingData message. Does not implicitly {@link Rating.RatingData.verify|verify} messages.
         * @function encode
         * @memberof Rating.RatingData
         * @static
         * @param {Rating.IRatingData} message RatingData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RatingData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ratingKey != null && message.hasOwnProperty("ratingKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ratingKey);
            if (message.vendorID != null && message.hasOwnProperty("vendorID"))
                $root.ID.encode(message.vendorID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.vendorSig != null && message.hasOwnProperty("vendorSig"))
                $root.RatingSignature.encode(message.vendorSig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.buyerID != null && message.hasOwnProperty("buyerID"))
                $root.ID.encode(message.buyerID, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.buyerName != null && message.hasOwnProperty("buyerName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.buyerName);
            if (message.buyerSig != null && message.hasOwnProperty("buyerSig"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.buyerSig);
            if (message.moderatorSig != null && message.hasOwnProperty("moderatorSig"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.moderatorSig);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.overall != null && message.hasOwnProperty("overall"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.overall);
            if (message.quality != null && message.hasOwnProperty("quality"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.quality);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.description);
            if (message.deliverySpeed != null && message.hasOwnProperty("deliverySpeed"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.deliverySpeed);
            if (message.customerService != null && message.hasOwnProperty("customerService"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.customerService);
            if (message.review != null && message.hasOwnProperty("review"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.review);
            return writer;
        };

        /**
         * Encodes the specified RatingData message, length delimited. Does not implicitly {@link Rating.RatingData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Rating.RatingData
         * @static
         * @param {Rating.IRatingData} message RatingData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RatingData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RatingData message from the specified reader or buffer.
         * @function decode
         * @memberof Rating.RatingData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Rating.RatingData} RatingData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RatingData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Rating.RatingData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ratingKey = reader.bytes();
                    break;
                case 2:
                    message.vendorID = $root.ID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.vendorSig = $root.RatingSignature.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.buyerID = $root.ID.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.buyerName = reader.string();
                    break;
                case 6:
                    message.buyerSig = reader.bytes();
                    break;
                case 7:
                    message.moderatorSig = reader.bytes();
                    break;
                case 8:
                    message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.overall = reader.uint32();
                    break;
                case 10:
                    message.quality = reader.uint32();
                    break;
                case 11:
                    message.description = reader.uint32();
                    break;
                case 12:
                    message.deliverySpeed = reader.uint32();
                    break;
                case 13:
                    message.customerService = reader.uint32();
                    break;
                case 14:
                    message.review = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RatingData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Rating.RatingData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Rating.RatingData} RatingData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RatingData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RatingData message.
         * @function verify
         * @memberof Rating.RatingData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RatingData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ratingKey != null && message.hasOwnProperty("ratingKey"))
                if (!(message.ratingKey && typeof message.ratingKey.length === "number" || $util.isString(message.ratingKey)))
                    return "ratingKey: buffer expected";
            if (message.vendorID != null && message.hasOwnProperty("vendorID")) {
                var error = $root.ID.verify(message.vendorID);
                if (error)
                    return "vendorID." + error;
            }
            if (message.vendorSig != null && message.hasOwnProperty("vendorSig")) {
                var error = $root.RatingSignature.verify(message.vendorSig);
                if (error)
                    return "vendorSig." + error;
            }
            if (message.buyerID != null && message.hasOwnProperty("buyerID")) {
                var error = $root.ID.verify(message.buyerID);
                if (error)
                    return "buyerID." + error;
            }
            if (message.buyerName != null && message.hasOwnProperty("buyerName"))
                if (!$util.isString(message.buyerName))
                    return "buyerName: string expected";
            if (message.buyerSig != null && message.hasOwnProperty("buyerSig"))
                if (!(message.buyerSig && typeof message.buyerSig.length === "number" || $util.isString(message.buyerSig)))
                    return "buyerSig: buffer expected";
            if (message.moderatorSig != null && message.hasOwnProperty("moderatorSig"))
                if (!(message.moderatorSig && typeof message.moderatorSig.length === "number" || $util.isString(message.moderatorSig)))
                    return "moderatorSig: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                if (error)
                    return "timestamp." + error;
            }
            if (message.overall != null && message.hasOwnProperty("overall"))
                if (!$util.isInteger(message.overall))
                    return "overall: integer expected";
            if (message.quality != null && message.hasOwnProperty("quality"))
                if (!$util.isInteger(message.quality))
                    return "quality: integer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isInteger(message.description))
                    return "description: integer expected";
            if (message.deliverySpeed != null && message.hasOwnProperty("deliverySpeed"))
                if (!$util.isInteger(message.deliverySpeed))
                    return "deliverySpeed: integer expected";
            if (message.customerService != null && message.hasOwnProperty("customerService"))
                if (!$util.isInteger(message.customerService))
                    return "customerService: integer expected";
            if (message.review != null && message.hasOwnProperty("review"))
                if (!$util.isString(message.review))
                    return "review: string expected";
            return null;
        };

        /**
         * Creates a RatingData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Rating.RatingData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Rating.RatingData} RatingData
         */
        RatingData.fromObject = function fromObject(object) {
            if (object instanceof $root.Rating.RatingData)
                return object;
            var message = new $root.Rating.RatingData();
            if (object.ratingKey != null)
                if (typeof object.ratingKey === "string")
                    $util.base64.decode(object.ratingKey, message.ratingKey = $util.newBuffer($util.base64.length(object.ratingKey)), 0);
                else if (object.ratingKey.length)
                    message.ratingKey = object.ratingKey;
            if (object.vendorID != null) {
                if (typeof object.vendorID !== "object")
                    throw TypeError(".Rating.RatingData.vendorID: object expected");
                message.vendorID = $root.ID.fromObject(object.vendorID);
            }
            if (object.vendorSig != null) {
                if (typeof object.vendorSig !== "object")
                    throw TypeError(".Rating.RatingData.vendorSig: object expected");
                message.vendorSig = $root.RatingSignature.fromObject(object.vendorSig);
            }
            if (object.buyerID != null) {
                if (typeof object.buyerID !== "object")
                    throw TypeError(".Rating.RatingData.buyerID: object expected");
                message.buyerID = $root.ID.fromObject(object.buyerID);
            }
            if (object.buyerName != null)
                message.buyerName = String(object.buyerName);
            if (object.buyerSig != null)
                if (typeof object.buyerSig === "string")
                    $util.base64.decode(object.buyerSig, message.buyerSig = $util.newBuffer($util.base64.length(object.buyerSig)), 0);
                else if (object.buyerSig.length)
                    message.buyerSig = object.buyerSig;
            if (object.moderatorSig != null)
                if (typeof object.moderatorSig === "string")
                    $util.base64.decode(object.moderatorSig, message.moderatorSig = $util.newBuffer($util.base64.length(object.moderatorSig)), 0);
                else if (object.moderatorSig.length)
                    message.moderatorSig = object.moderatorSig;
            if (object.timestamp != null) {
                if (typeof object.timestamp !== "object")
                    throw TypeError(".Rating.RatingData.timestamp: object expected");
                message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
            }
            if (object.overall != null)
                message.overall = object.overall >>> 0;
            if (object.quality != null)
                message.quality = object.quality >>> 0;
            if (object.description != null)
                message.description = object.description >>> 0;
            if (object.deliverySpeed != null)
                message.deliverySpeed = object.deliverySpeed >>> 0;
            if (object.customerService != null)
                message.customerService = object.customerService >>> 0;
            if (object.review != null)
                message.review = String(object.review);
            return message;
        };

        /**
         * Creates a plain object from a RatingData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Rating.RatingData
         * @static
         * @param {Rating.RatingData} message RatingData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RatingData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ratingKey = options.bytes === String ? "" : [];
                object.vendorID = null;
                object.vendorSig = null;
                object.buyerID = null;
                object.buyerName = "";
                object.buyerSig = options.bytes === String ? "" : [];
                object.moderatorSig = options.bytes === String ? "" : [];
                object.timestamp = null;
                object.overall = 0;
                object.quality = 0;
                object.description = 0;
                object.deliverySpeed = 0;
                object.customerService = 0;
                object.review = "";
            }
            if (message.ratingKey != null && message.hasOwnProperty("ratingKey"))
                object.ratingKey = options.bytes === String ? $util.base64.encode(message.ratingKey, 0, message.ratingKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ratingKey) : message.ratingKey;
            if (message.vendorID != null && message.hasOwnProperty("vendorID"))
                object.vendorID = $root.ID.toObject(message.vendorID, options);
            if (message.vendorSig != null && message.hasOwnProperty("vendorSig"))
                object.vendorSig = $root.RatingSignature.toObject(message.vendorSig, options);
            if (message.buyerID != null && message.hasOwnProperty("buyerID"))
                object.buyerID = $root.ID.toObject(message.buyerID, options);
            if (message.buyerName != null && message.hasOwnProperty("buyerName"))
                object.buyerName = message.buyerName;
            if (message.buyerSig != null && message.hasOwnProperty("buyerSig"))
                object.buyerSig = options.bytes === String ? $util.base64.encode(message.buyerSig, 0, message.buyerSig.length) : options.bytes === Array ? Array.prototype.slice.call(message.buyerSig) : message.buyerSig;
            if (message.moderatorSig != null && message.hasOwnProperty("moderatorSig"))
                object.moderatorSig = options.bytes === String ? $util.base64.encode(message.moderatorSig, 0, message.moderatorSig.length) : options.bytes === Array ? Array.prototype.slice.call(message.moderatorSig) : message.moderatorSig;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
            if (message.overall != null && message.hasOwnProperty("overall"))
                object.overall = message.overall;
            if (message.quality != null && message.hasOwnProperty("quality"))
                object.quality = message.quality;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.deliverySpeed != null && message.hasOwnProperty("deliverySpeed"))
                object.deliverySpeed = message.deliverySpeed;
            if (message.customerService != null && message.hasOwnProperty("customerService"))
                object.customerService = message.customerService;
            if (message.review != null && message.hasOwnProperty("review"))
                object.review = message.review;
            return object;
        };

        /**
         * Converts this RatingData to JSON.
         * @function toJSON
         * @memberof Rating.RatingData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RatingData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RatingData;
    })();

    return Rating;
})();

$root.Dispute = (function() {

    /**
     * Properties of a Dispute.
     * @exports IDispute
     * @interface IDispute
     * @property {google.protobuf.ITimestamp|null} [timestamp] Dispute timestamp
     * @property {string|null} [claim] Dispute claim
     * @property {string|null} [payoutAddress] Dispute payoutAddress
     * @property {Array.<IOutpoint>|null} [outpoints] Dispute outpoints
     * @property {Uint8Array|null} [serializedContract] Dispute serializedContract
     */

    /**
     * Constructs a new Dispute.
     * @exports Dispute
     * @classdesc Represents a Dispute.
     * @implements IDispute
     * @constructor
     * @param {IDispute=} [properties] Properties to set
     */
    function Dispute(properties) {
        this.outpoints = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Dispute timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof Dispute
     * @instance
     */
    Dispute.prototype.timestamp = null;

    /**
     * Dispute claim.
     * @member {string} claim
     * @memberof Dispute
     * @instance
     */
    Dispute.prototype.claim = "";

    /**
     * Dispute payoutAddress.
     * @member {string} payoutAddress
     * @memberof Dispute
     * @instance
     */
    Dispute.prototype.payoutAddress = "";

    /**
     * Dispute outpoints.
     * @member {Array.<IOutpoint>} outpoints
     * @memberof Dispute
     * @instance
     */
    Dispute.prototype.outpoints = $util.emptyArray;

    /**
     * Dispute serializedContract.
     * @member {Uint8Array} serializedContract
     * @memberof Dispute
     * @instance
     */
    Dispute.prototype.serializedContract = $util.newBuffer([]);

    /**
     * Creates a new Dispute instance using the specified properties.
     * @function create
     * @memberof Dispute
     * @static
     * @param {IDispute=} [properties] Properties to set
     * @returns {Dispute} Dispute instance
     */
    Dispute.create = function create(properties) {
        return new Dispute(properties);
    };

    /**
     * Encodes the specified Dispute message. Does not implicitly {@link Dispute.verify|verify} messages.
     * @function encode
     * @memberof Dispute
     * @static
     * @param {IDispute} message Dispute message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Dispute.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.claim != null && message.hasOwnProperty("claim"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.claim);
        if (message.payoutAddress != null && message.hasOwnProperty("payoutAddress"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.payoutAddress);
        if (message.outpoints != null && message.outpoints.length)
            for (var i = 0; i < message.outpoints.length; ++i)
                $root.Outpoint.encode(message.outpoints[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.serializedContract != null && message.hasOwnProperty("serializedContract"))
            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.serializedContract);
        return writer;
    };

    /**
     * Encodes the specified Dispute message, length delimited. Does not implicitly {@link Dispute.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Dispute
     * @static
     * @param {IDispute} message Dispute message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Dispute.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Dispute message from the specified reader or buffer.
     * @function decode
     * @memberof Dispute
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Dispute} Dispute
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Dispute.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Dispute();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 2:
                message.claim = reader.string();
                break;
            case 3:
                message.payoutAddress = reader.string();
                break;
            case 4:
                if (!(message.outpoints && message.outpoints.length))
                    message.outpoints = [];
                message.outpoints.push($root.Outpoint.decode(reader, reader.uint32()));
                break;
            case 5:
                message.serializedContract = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Dispute message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Dispute
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Dispute} Dispute
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Dispute.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Dispute message.
     * @function verify
     * @memberof Dispute
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Dispute.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.claim != null && message.hasOwnProperty("claim"))
            if (!$util.isString(message.claim))
                return "claim: string expected";
        if (message.payoutAddress != null && message.hasOwnProperty("payoutAddress"))
            if (!$util.isString(message.payoutAddress))
                return "payoutAddress: string expected";
        if (message.outpoints != null && message.hasOwnProperty("outpoints")) {
            if (!Array.isArray(message.outpoints))
                return "outpoints: array expected";
            for (var i = 0; i < message.outpoints.length; ++i) {
                var error = $root.Outpoint.verify(message.outpoints[i]);
                if (error)
                    return "outpoints." + error;
            }
        }
        if (message.serializedContract != null && message.hasOwnProperty("serializedContract"))
            if (!(message.serializedContract && typeof message.serializedContract.length === "number" || $util.isString(message.serializedContract)))
                return "serializedContract: buffer expected";
        return null;
    };

    /**
     * Creates a Dispute message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Dispute
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Dispute} Dispute
     */
    Dispute.fromObject = function fromObject(object) {
        if (object instanceof $root.Dispute)
            return object;
        var message = new $root.Dispute();
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".Dispute.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.claim != null)
            message.claim = String(object.claim);
        if (object.payoutAddress != null)
            message.payoutAddress = String(object.payoutAddress);
        if (object.outpoints) {
            if (!Array.isArray(object.outpoints))
                throw TypeError(".Dispute.outpoints: array expected");
            message.outpoints = [];
            for (var i = 0; i < object.outpoints.length; ++i) {
                if (typeof object.outpoints[i] !== "object")
                    throw TypeError(".Dispute.outpoints: object expected");
                message.outpoints[i] = $root.Outpoint.fromObject(object.outpoints[i]);
            }
        }
        if (object.serializedContract != null)
            if (typeof object.serializedContract === "string")
                $util.base64.decode(object.serializedContract, message.serializedContract = $util.newBuffer($util.base64.length(object.serializedContract)), 0);
            else if (object.serializedContract.length)
                message.serializedContract = object.serializedContract;
        return message;
    };

    /**
     * Creates a plain object from a Dispute message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Dispute
     * @static
     * @param {Dispute} message Dispute
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Dispute.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.outpoints = [];
        if (options.defaults) {
            object.timestamp = null;
            object.claim = "";
            object.payoutAddress = "";
            object.serializedContract = options.bytes === String ? "" : [];
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.claim != null && message.hasOwnProperty("claim"))
            object.claim = message.claim;
        if (message.payoutAddress != null && message.hasOwnProperty("payoutAddress"))
            object.payoutAddress = message.payoutAddress;
        if (message.outpoints && message.outpoints.length) {
            object.outpoints = [];
            for (var j = 0; j < message.outpoints.length; ++j)
                object.outpoints[j] = $root.Outpoint.toObject(message.outpoints[j], options);
        }
        if (message.serializedContract != null && message.hasOwnProperty("serializedContract"))
            object.serializedContract = options.bytes === String ? $util.base64.encode(message.serializedContract, 0, message.serializedContract.length) : options.bytes === Array ? Array.prototype.slice.call(message.serializedContract) : message.serializedContract;
        return object;
    };

    /**
     * Converts this Dispute to JSON.
     * @function toJSON
     * @memberof Dispute
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Dispute.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Dispute;
})();

$root.DisputeResolution = (function() {

    /**
     * Properties of a DisputeResolution.
     * @exports IDisputeResolution
     * @interface IDisputeResolution
     * @property {google.protobuf.ITimestamp|null} [timestamp] DisputeResolution timestamp
     * @property {string|null} [orderId] DisputeResolution orderId
     * @property {string|null} [proposedBy] DisputeResolution proposedBy
     * @property {string|null} [resolution] DisputeResolution resolution
     * @property {DisputeResolution.IPayout|null} [payout] DisputeResolution payout
     * @property {Array.<Uint8Array>|null} [moderatorRatingSigs] DisputeResolution moderatorRatingSigs
     */

    /**
     * Constructs a new DisputeResolution.
     * @exports DisputeResolution
     * @classdesc Represents a DisputeResolution.
     * @implements IDisputeResolution
     * @constructor
     * @param {IDisputeResolution=} [properties] Properties to set
     */
    function DisputeResolution(properties) {
        this.moderatorRatingSigs = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DisputeResolution timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof DisputeResolution
     * @instance
     */
    DisputeResolution.prototype.timestamp = null;

    /**
     * DisputeResolution orderId.
     * @member {string} orderId
     * @memberof DisputeResolution
     * @instance
     */
    DisputeResolution.prototype.orderId = "";

    /**
     * DisputeResolution proposedBy.
     * @member {string} proposedBy
     * @memberof DisputeResolution
     * @instance
     */
    DisputeResolution.prototype.proposedBy = "";

    /**
     * DisputeResolution resolution.
     * @member {string} resolution
     * @memberof DisputeResolution
     * @instance
     */
    DisputeResolution.prototype.resolution = "";

    /**
     * DisputeResolution payout.
     * @member {DisputeResolution.IPayout|null|undefined} payout
     * @memberof DisputeResolution
     * @instance
     */
    DisputeResolution.prototype.payout = null;

    /**
     * DisputeResolution moderatorRatingSigs.
     * @member {Array.<Uint8Array>} moderatorRatingSigs
     * @memberof DisputeResolution
     * @instance
     */
    DisputeResolution.prototype.moderatorRatingSigs = $util.emptyArray;

    /**
     * Creates a new DisputeResolution instance using the specified properties.
     * @function create
     * @memberof DisputeResolution
     * @static
     * @param {IDisputeResolution=} [properties] Properties to set
     * @returns {DisputeResolution} DisputeResolution instance
     */
    DisputeResolution.create = function create(properties) {
        return new DisputeResolution(properties);
    };

    /**
     * Encodes the specified DisputeResolution message. Does not implicitly {@link DisputeResolution.verify|verify} messages.
     * @function encode
     * @memberof DisputeResolution
     * @static
     * @param {IDisputeResolution} message DisputeResolution message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DisputeResolution.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.orderId);
        if (message.proposedBy != null && message.hasOwnProperty("proposedBy"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.proposedBy);
        if (message.resolution != null && message.hasOwnProperty("resolution"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.resolution);
        if (message.payout != null && message.hasOwnProperty("payout"))
            $root.DisputeResolution.Payout.encode(message.payout, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.moderatorRatingSigs != null && message.moderatorRatingSigs.length)
            for (var i = 0; i < message.moderatorRatingSigs.length; ++i)
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.moderatorRatingSigs[i]);
        return writer;
    };

    /**
     * Encodes the specified DisputeResolution message, length delimited. Does not implicitly {@link DisputeResolution.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DisputeResolution
     * @static
     * @param {IDisputeResolution} message DisputeResolution message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DisputeResolution.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DisputeResolution message from the specified reader or buffer.
     * @function decode
     * @memberof DisputeResolution
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DisputeResolution} DisputeResolution
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DisputeResolution.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisputeResolution();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 2:
                message.orderId = reader.string();
                break;
            case 3:
                message.proposedBy = reader.string();
                break;
            case 4:
                message.resolution = reader.string();
                break;
            case 5:
                message.payout = $root.DisputeResolution.Payout.decode(reader, reader.uint32());
                break;
            case 6:
                if (!(message.moderatorRatingSigs && message.moderatorRatingSigs.length))
                    message.moderatorRatingSigs = [];
                message.moderatorRatingSigs.push(reader.bytes());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DisputeResolution message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DisputeResolution
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DisputeResolution} DisputeResolution
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DisputeResolution.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DisputeResolution message.
     * @function verify
     * @memberof DisputeResolution
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DisputeResolution.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            if (!$util.isString(message.orderId))
                return "orderId: string expected";
        if (message.proposedBy != null && message.hasOwnProperty("proposedBy"))
            if (!$util.isString(message.proposedBy))
                return "proposedBy: string expected";
        if (message.resolution != null && message.hasOwnProperty("resolution"))
            if (!$util.isString(message.resolution))
                return "resolution: string expected";
        if (message.payout != null && message.hasOwnProperty("payout")) {
            var error = $root.DisputeResolution.Payout.verify(message.payout);
            if (error)
                return "payout." + error;
        }
        if (message.moderatorRatingSigs != null && message.hasOwnProperty("moderatorRatingSigs")) {
            if (!Array.isArray(message.moderatorRatingSigs))
                return "moderatorRatingSigs: array expected";
            for (var i = 0; i < message.moderatorRatingSigs.length; ++i)
                if (!(message.moderatorRatingSigs[i] && typeof message.moderatorRatingSigs[i].length === "number" || $util.isString(message.moderatorRatingSigs[i])))
                    return "moderatorRatingSigs: buffer[] expected";
        }
        return null;
    };

    /**
     * Creates a DisputeResolution message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DisputeResolution
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DisputeResolution} DisputeResolution
     */
    DisputeResolution.fromObject = function fromObject(object) {
        if (object instanceof $root.DisputeResolution)
            return object;
        var message = new $root.DisputeResolution();
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".DisputeResolution.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.orderId != null)
            message.orderId = String(object.orderId);
        if (object.proposedBy != null)
            message.proposedBy = String(object.proposedBy);
        if (object.resolution != null)
            message.resolution = String(object.resolution);
        if (object.payout != null) {
            if (typeof object.payout !== "object")
                throw TypeError(".DisputeResolution.payout: object expected");
            message.payout = $root.DisputeResolution.Payout.fromObject(object.payout);
        }
        if (object.moderatorRatingSigs) {
            if (!Array.isArray(object.moderatorRatingSigs))
                throw TypeError(".DisputeResolution.moderatorRatingSigs: array expected");
            message.moderatorRatingSigs = [];
            for (var i = 0; i < object.moderatorRatingSigs.length; ++i)
                if (typeof object.moderatorRatingSigs[i] === "string")
                    $util.base64.decode(object.moderatorRatingSigs[i], message.moderatorRatingSigs[i] = $util.newBuffer($util.base64.length(object.moderatorRatingSigs[i])), 0);
                else if (object.moderatorRatingSigs[i].length)
                    message.moderatorRatingSigs[i] = object.moderatorRatingSigs[i];
        }
        return message;
    };

    /**
     * Creates a plain object from a DisputeResolution message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DisputeResolution
     * @static
     * @param {DisputeResolution} message DisputeResolution
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DisputeResolution.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.moderatorRatingSigs = [];
        if (options.defaults) {
            object.timestamp = null;
            object.orderId = "";
            object.proposedBy = "";
            object.resolution = "";
            object.payout = null;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            object.orderId = message.orderId;
        if (message.proposedBy != null && message.hasOwnProperty("proposedBy"))
            object.proposedBy = message.proposedBy;
        if (message.resolution != null && message.hasOwnProperty("resolution"))
            object.resolution = message.resolution;
        if (message.payout != null && message.hasOwnProperty("payout"))
            object.payout = $root.DisputeResolution.Payout.toObject(message.payout, options);
        if (message.moderatorRatingSigs && message.moderatorRatingSigs.length) {
            object.moderatorRatingSigs = [];
            for (var j = 0; j < message.moderatorRatingSigs.length; ++j)
                object.moderatorRatingSigs[j] = options.bytes === String ? $util.base64.encode(message.moderatorRatingSigs[j], 0, message.moderatorRatingSigs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.moderatorRatingSigs[j]) : message.moderatorRatingSigs[j];
        }
        return object;
    };

    /**
     * Converts this DisputeResolution to JSON.
     * @function toJSON
     * @memberof DisputeResolution
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DisputeResolution.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    DisputeResolution.Payout = (function() {

        /**
         * Properties of a Payout.
         * @memberof DisputeResolution
         * @interface IPayout
         * @property {Array.<IBitcoinSignature>|null} [sigs] Payout sigs
         * @property {Array.<IOutpoint>|null} [inputs] Payout inputs
         * @property {DisputeResolution.Payout.IOutput|null} [buyerOutput] Payout buyerOutput
         * @property {DisputeResolution.Payout.IOutput|null} [vendorOutput] Payout vendorOutput
         * @property {DisputeResolution.Payout.IOutput|null} [moderatorOutput] Payout moderatorOutput
         */

        /**
         * Constructs a new Payout.
         * @memberof DisputeResolution
         * @classdesc Represents a Payout.
         * @implements IPayout
         * @constructor
         * @param {DisputeResolution.IPayout=} [properties] Properties to set
         */
        function Payout(properties) {
            this.sigs = [];
            this.inputs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Payout sigs.
         * @member {Array.<IBitcoinSignature>} sigs
         * @memberof DisputeResolution.Payout
         * @instance
         */
        Payout.prototype.sigs = $util.emptyArray;

        /**
         * Payout inputs.
         * @member {Array.<IOutpoint>} inputs
         * @memberof DisputeResolution.Payout
         * @instance
         */
        Payout.prototype.inputs = $util.emptyArray;

        /**
         * Payout buyerOutput.
         * @member {DisputeResolution.Payout.IOutput|null|undefined} buyerOutput
         * @memberof DisputeResolution.Payout
         * @instance
         */
        Payout.prototype.buyerOutput = null;

        /**
         * Payout vendorOutput.
         * @member {DisputeResolution.Payout.IOutput|null|undefined} vendorOutput
         * @memberof DisputeResolution.Payout
         * @instance
         */
        Payout.prototype.vendorOutput = null;

        /**
         * Payout moderatorOutput.
         * @member {DisputeResolution.Payout.IOutput|null|undefined} moderatorOutput
         * @memberof DisputeResolution.Payout
         * @instance
         */
        Payout.prototype.moderatorOutput = null;

        /**
         * Creates a new Payout instance using the specified properties.
         * @function create
         * @memberof DisputeResolution.Payout
         * @static
         * @param {DisputeResolution.IPayout=} [properties] Properties to set
         * @returns {DisputeResolution.Payout} Payout instance
         */
        Payout.create = function create(properties) {
            return new Payout(properties);
        };

        /**
         * Encodes the specified Payout message. Does not implicitly {@link DisputeResolution.Payout.verify|verify} messages.
         * @function encode
         * @memberof DisputeResolution.Payout
         * @static
         * @param {DisputeResolution.IPayout} message Payout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payout.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sigs != null && message.sigs.length)
                for (var i = 0; i < message.sigs.length; ++i)
                    $root.BitcoinSignature.encode(message.sigs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.inputs != null && message.inputs.length)
                for (var i = 0; i < message.inputs.length; ++i)
                    $root.Outpoint.encode(message.inputs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.buyerOutput != null && message.hasOwnProperty("buyerOutput"))
                $root.DisputeResolution.Payout.Output.encode(message.buyerOutput, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.vendorOutput != null && message.hasOwnProperty("vendorOutput"))
                $root.DisputeResolution.Payout.Output.encode(message.vendorOutput, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.moderatorOutput != null && message.hasOwnProperty("moderatorOutput"))
                $root.DisputeResolution.Payout.Output.encode(message.moderatorOutput, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Payout message, length delimited. Does not implicitly {@link DisputeResolution.Payout.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DisputeResolution.Payout
         * @static
         * @param {DisputeResolution.IPayout} message Payout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payout.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Payout message from the specified reader or buffer.
         * @function decode
         * @memberof DisputeResolution.Payout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DisputeResolution.Payout} Payout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payout.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisputeResolution.Payout();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sigs && message.sigs.length))
                        message.sigs = [];
                    message.sigs.push($root.BitcoinSignature.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.inputs && message.inputs.length))
                        message.inputs = [];
                    message.inputs.push($root.Outpoint.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.buyerOutput = $root.DisputeResolution.Payout.Output.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.vendorOutput = $root.DisputeResolution.Payout.Output.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.moderatorOutput = $root.DisputeResolution.Payout.Output.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Payout message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DisputeResolution.Payout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DisputeResolution.Payout} Payout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payout.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Payout message.
         * @function verify
         * @memberof DisputeResolution.Payout
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Payout.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sigs != null && message.hasOwnProperty("sigs")) {
                if (!Array.isArray(message.sigs))
                    return "sigs: array expected";
                for (var i = 0; i < message.sigs.length; ++i) {
                    var error = $root.BitcoinSignature.verify(message.sigs[i]);
                    if (error)
                        return "sigs." + error;
                }
            }
            if (message.inputs != null && message.hasOwnProperty("inputs")) {
                if (!Array.isArray(message.inputs))
                    return "inputs: array expected";
                for (var i = 0; i < message.inputs.length; ++i) {
                    var error = $root.Outpoint.verify(message.inputs[i]);
                    if (error)
                        return "inputs." + error;
                }
            }
            if (message.buyerOutput != null && message.hasOwnProperty("buyerOutput")) {
                var error = $root.DisputeResolution.Payout.Output.verify(message.buyerOutput);
                if (error)
                    return "buyerOutput." + error;
            }
            if (message.vendorOutput != null && message.hasOwnProperty("vendorOutput")) {
                var error = $root.DisputeResolution.Payout.Output.verify(message.vendorOutput);
                if (error)
                    return "vendorOutput." + error;
            }
            if (message.moderatorOutput != null && message.hasOwnProperty("moderatorOutput")) {
                var error = $root.DisputeResolution.Payout.Output.verify(message.moderatorOutput);
                if (error)
                    return "moderatorOutput." + error;
            }
            return null;
        };

        /**
         * Creates a Payout message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DisputeResolution.Payout
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DisputeResolution.Payout} Payout
         */
        Payout.fromObject = function fromObject(object) {
            if (object instanceof $root.DisputeResolution.Payout)
                return object;
            var message = new $root.DisputeResolution.Payout();
            if (object.sigs) {
                if (!Array.isArray(object.sigs))
                    throw TypeError(".DisputeResolution.Payout.sigs: array expected");
                message.sigs = [];
                for (var i = 0; i < object.sigs.length; ++i) {
                    if (typeof object.sigs[i] !== "object")
                        throw TypeError(".DisputeResolution.Payout.sigs: object expected");
                    message.sigs[i] = $root.BitcoinSignature.fromObject(object.sigs[i]);
                }
            }
            if (object.inputs) {
                if (!Array.isArray(object.inputs))
                    throw TypeError(".DisputeResolution.Payout.inputs: array expected");
                message.inputs = [];
                for (var i = 0; i < object.inputs.length; ++i) {
                    if (typeof object.inputs[i] !== "object")
                        throw TypeError(".DisputeResolution.Payout.inputs: object expected");
                    message.inputs[i] = $root.Outpoint.fromObject(object.inputs[i]);
                }
            }
            if (object.buyerOutput != null) {
                if (typeof object.buyerOutput !== "object")
                    throw TypeError(".DisputeResolution.Payout.buyerOutput: object expected");
                message.buyerOutput = $root.DisputeResolution.Payout.Output.fromObject(object.buyerOutput);
            }
            if (object.vendorOutput != null) {
                if (typeof object.vendorOutput !== "object")
                    throw TypeError(".DisputeResolution.Payout.vendorOutput: object expected");
                message.vendorOutput = $root.DisputeResolution.Payout.Output.fromObject(object.vendorOutput);
            }
            if (object.moderatorOutput != null) {
                if (typeof object.moderatorOutput !== "object")
                    throw TypeError(".DisputeResolution.Payout.moderatorOutput: object expected");
                message.moderatorOutput = $root.DisputeResolution.Payout.Output.fromObject(object.moderatorOutput);
            }
            return message;
        };

        /**
         * Creates a plain object from a Payout message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DisputeResolution.Payout
         * @static
         * @param {DisputeResolution.Payout} message Payout
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Payout.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.sigs = [];
                object.inputs = [];
            }
            if (options.defaults) {
                object.buyerOutput = null;
                object.vendorOutput = null;
                object.moderatorOutput = null;
            }
            if (message.sigs && message.sigs.length) {
                object.sigs = [];
                for (var j = 0; j < message.sigs.length; ++j)
                    object.sigs[j] = $root.BitcoinSignature.toObject(message.sigs[j], options);
            }
            if (message.inputs && message.inputs.length) {
                object.inputs = [];
                for (var j = 0; j < message.inputs.length; ++j)
                    object.inputs[j] = $root.Outpoint.toObject(message.inputs[j], options);
            }
            if (message.buyerOutput != null && message.hasOwnProperty("buyerOutput"))
                object.buyerOutput = $root.DisputeResolution.Payout.Output.toObject(message.buyerOutput, options);
            if (message.vendorOutput != null && message.hasOwnProperty("vendorOutput"))
                object.vendorOutput = $root.DisputeResolution.Payout.Output.toObject(message.vendorOutput, options);
            if (message.moderatorOutput != null && message.hasOwnProperty("moderatorOutput"))
                object.moderatorOutput = $root.DisputeResolution.Payout.Output.toObject(message.moderatorOutput, options);
            return object;
        };

        /**
         * Converts this Payout to JSON.
         * @function toJSON
         * @memberof DisputeResolution.Payout
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Payout.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Payout.Output = (function() {

            /**
             * Properties of an Output.
             * @memberof DisputeResolution.Payout
             * @interface IOutput
             * @property {string|null} [script] Output script
             * @property {number|Long|null} [amount] Output amount
             */

            /**
             * Constructs a new Output.
             * @memberof DisputeResolution.Payout
             * @classdesc Represents an Output.
             * @implements IOutput
             * @constructor
             * @param {DisputeResolution.Payout.IOutput=} [properties] Properties to set
             */
            function Output(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Output script.
             * @member {string} script
             * @memberof DisputeResolution.Payout.Output
             * @instance
             */
            Output.prototype.script = "";

            /**
             * Output amount.
             * @member {number|Long} amount
             * @memberof DisputeResolution.Payout.Output
             * @instance
             */
            Output.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Output instance using the specified properties.
             * @function create
             * @memberof DisputeResolution.Payout.Output
             * @static
             * @param {DisputeResolution.Payout.IOutput=} [properties] Properties to set
             * @returns {DisputeResolution.Payout.Output} Output instance
             */
            Output.create = function create(properties) {
                return new Output(properties);
            };

            /**
             * Encodes the specified Output message. Does not implicitly {@link DisputeResolution.Payout.Output.verify|verify} messages.
             * @function encode
             * @memberof DisputeResolution.Payout.Output
             * @static
             * @param {DisputeResolution.Payout.IOutput} message Output message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Output.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.script != null && message.hasOwnProperty("script"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.script);
                if (message.amount != null && message.hasOwnProperty("amount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount);
                return writer;
            };

            /**
             * Encodes the specified Output message, length delimited. Does not implicitly {@link DisputeResolution.Payout.Output.verify|verify} messages.
             * @function encodeDelimited
             * @memberof DisputeResolution.Payout.Output
             * @static
             * @param {DisputeResolution.Payout.IOutput} message Output message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Output.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Output message from the specified reader or buffer.
             * @function decode
             * @memberof DisputeResolution.Payout.Output
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {DisputeResolution.Payout.Output} Output
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Output.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisputeResolution.Payout.Output();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.script = reader.string();
                        break;
                    case 2:
                        message.amount = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Output message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof DisputeResolution.Payout.Output
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {DisputeResolution.Payout.Output} Output
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Output.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Output message.
             * @function verify
             * @memberof DisputeResolution.Payout.Output
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Output.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.script != null && message.hasOwnProperty("script"))
                    if (!$util.isString(message.script))
                        return "script: string expected";
                if (message.amount != null && message.hasOwnProperty("amount"))
                    if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                        return "amount: integer|Long expected";
                return null;
            };

            /**
             * Creates an Output message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof DisputeResolution.Payout.Output
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {DisputeResolution.Payout.Output} Output
             */
            Output.fromObject = function fromObject(object) {
                if (object instanceof $root.DisputeResolution.Payout.Output)
                    return object;
                var message = new $root.DisputeResolution.Payout.Output();
                if (object.script != null)
                    message.script = String(object.script);
                if (object.amount != null)
                    if ($util.Long)
                        (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                    else if (typeof object.amount === "string")
                        message.amount = parseInt(object.amount, 10);
                    else if (typeof object.amount === "number")
                        message.amount = object.amount;
                    else if (typeof object.amount === "object")
                        message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an Output message. Also converts values to other types if specified.
             * @function toObject
             * @memberof DisputeResolution.Payout.Output
             * @static
             * @param {DisputeResolution.Payout.Output} message Output
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Output.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.script = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.amount = options.longs === String ? "0" : 0;
                }
                if (message.script != null && message.hasOwnProperty("script"))
                    object.script = message.script;
                if (message.amount != null && message.hasOwnProperty("amount"))
                    if (typeof message.amount === "number")
                        object.amount = options.longs === String ? String(message.amount) : message.amount;
                    else
                        object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                return object;
            };

            /**
             * Converts this Output to JSON.
             * @function toJSON
             * @memberof DisputeResolution.Payout.Output
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Output.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Output;
        })();

        return Payout;
    })();

    return DisputeResolution;
})();

$root.DisputeAcceptance = (function() {

    /**
     * Properties of a DisputeAcceptance.
     * @exports IDisputeAcceptance
     * @interface IDisputeAcceptance
     * @property {google.protobuf.ITimestamp|null} [timestamp] DisputeAcceptance timestamp
     * @property {string|null} [closedBy] DisputeAcceptance closedBy
     */

    /**
     * Constructs a new DisputeAcceptance.
     * @exports DisputeAcceptance
     * @classdesc Represents a DisputeAcceptance.
     * @implements IDisputeAcceptance
     * @constructor
     * @param {IDisputeAcceptance=} [properties] Properties to set
     */
    function DisputeAcceptance(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DisputeAcceptance timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof DisputeAcceptance
     * @instance
     */
    DisputeAcceptance.prototype.timestamp = null;

    /**
     * DisputeAcceptance closedBy.
     * @member {string} closedBy
     * @memberof DisputeAcceptance
     * @instance
     */
    DisputeAcceptance.prototype.closedBy = "";

    /**
     * Creates a new DisputeAcceptance instance using the specified properties.
     * @function create
     * @memberof DisputeAcceptance
     * @static
     * @param {IDisputeAcceptance=} [properties] Properties to set
     * @returns {DisputeAcceptance} DisputeAcceptance instance
     */
    DisputeAcceptance.create = function create(properties) {
        return new DisputeAcceptance(properties);
    };

    /**
     * Encodes the specified DisputeAcceptance message. Does not implicitly {@link DisputeAcceptance.verify|verify} messages.
     * @function encode
     * @memberof DisputeAcceptance
     * @static
     * @param {IDisputeAcceptance} message DisputeAcceptance message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DisputeAcceptance.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.closedBy != null && message.hasOwnProperty("closedBy"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.closedBy);
        return writer;
    };

    /**
     * Encodes the specified DisputeAcceptance message, length delimited. Does not implicitly {@link DisputeAcceptance.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DisputeAcceptance
     * @static
     * @param {IDisputeAcceptance} message DisputeAcceptance message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DisputeAcceptance.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DisputeAcceptance message from the specified reader or buffer.
     * @function decode
     * @memberof DisputeAcceptance
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DisputeAcceptance} DisputeAcceptance
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DisputeAcceptance.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisputeAcceptance();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 2:
                message.closedBy = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DisputeAcceptance message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DisputeAcceptance
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DisputeAcceptance} DisputeAcceptance
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DisputeAcceptance.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DisputeAcceptance message.
     * @function verify
     * @memberof DisputeAcceptance
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DisputeAcceptance.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.closedBy != null && message.hasOwnProperty("closedBy"))
            if (!$util.isString(message.closedBy))
                return "closedBy: string expected";
        return null;
    };

    /**
     * Creates a DisputeAcceptance message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DisputeAcceptance
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DisputeAcceptance} DisputeAcceptance
     */
    DisputeAcceptance.fromObject = function fromObject(object) {
        if (object instanceof $root.DisputeAcceptance)
            return object;
        var message = new $root.DisputeAcceptance();
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".DisputeAcceptance.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.closedBy != null)
            message.closedBy = String(object.closedBy);
        return message;
    };

    /**
     * Creates a plain object from a DisputeAcceptance message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DisputeAcceptance
     * @static
     * @param {DisputeAcceptance} message DisputeAcceptance
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DisputeAcceptance.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.timestamp = null;
            object.closedBy = "";
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.closedBy != null && message.hasOwnProperty("closedBy"))
            object.closedBy = message.closedBy;
        return object;
    };

    /**
     * Converts this DisputeAcceptance to JSON.
     * @function toJSON
     * @memberof DisputeAcceptance
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DisputeAcceptance.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DisputeAcceptance;
})();

$root.Outpoint = (function() {

    /**
     * Properties of an Outpoint.
     * @exports IOutpoint
     * @interface IOutpoint
     * @property {string|null} [hash] Outpoint hash
     * @property {number|null} [index] Outpoint index
     * @property {number|Long|null} [value] Outpoint value
     */

    /**
     * Constructs a new Outpoint.
     * @exports Outpoint
     * @classdesc Represents an Outpoint.
     * @implements IOutpoint
     * @constructor
     * @param {IOutpoint=} [properties] Properties to set
     */
    function Outpoint(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Outpoint hash.
     * @member {string} hash
     * @memberof Outpoint
     * @instance
     */
    Outpoint.prototype.hash = "";

    /**
     * Outpoint index.
     * @member {number} index
     * @memberof Outpoint
     * @instance
     */
    Outpoint.prototype.index = 0;

    /**
     * Outpoint value.
     * @member {number|Long} value
     * @memberof Outpoint
     * @instance
     */
    Outpoint.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new Outpoint instance using the specified properties.
     * @function create
     * @memberof Outpoint
     * @static
     * @param {IOutpoint=} [properties] Properties to set
     * @returns {Outpoint} Outpoint instance
     */
    Outpoint.create = function create(properties) {
        return new Outpoint(properties);
    };

    /**
     * Encodes the specified Outpoint message. Does not implicitly {@link Outpoint.verify|verify} messages.
     * @function encode
     * @memberof Outpoint
     * @static
     * @param {IOutpoint} message Outpoint message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Outpoint.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
        if (message.index != null && message.hasOwnProperty("index"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
        if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.value);
        return writer;
    };

    /**
     * Encodes the specified Outpoint message, length delimited. Does not implicitly {@link Outpoint.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Outpoint
     * @static
     * @param {IOutpoint} message Outpoint message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Outpoint.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Outpoint message from the specified reader or buffer.
     * @function decode
     * @memberof Outpoint
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Outpoint} Outpoint
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Outpoint.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Outpoint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.hash = reader.string();
                break;
            case 2:
                message.index = reader.uint32();
                break;
            case 3:
                message.value = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Outpoint message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Outpoint
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Outpoint} Outpoint
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Outpoint.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Outpoint message.
     * @function verify
     * @memberof Outpoint
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Outpoint.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.hash != null && message.hasOwnProperty("hash"))
            if (!$util.isString(message.hash))
                return "hash: string expected";
        if (message.index != null && message.hasOwnProperty("index"))
            if (!$util.isInteger(message.index))
                return "index: integer expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                return "value: integer|Long expected";
        return null;
    };

    /**
     * Creates an Outpoint message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Outpoint
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Outpoint} Outpoint
     */
    Outpoint.fromObject = function fromObject(object) {
        if (object instanceof $root.Outpoint)
            return object;
        var message = new $root.Outpoint();
        if (object.hash != null)
            message.hash = String(object.hash);
        if (object.index != null)
            message.index = object.index >>> 0;
        if (object.value != null)
            if ($util.Long)
                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
            else if (typeof object.value === "string")
                message.value = parseInt(object.value, 10);
            else if (typeof object.value === "number")
                message.value = object.value;
            else if (typeof object.value === "object")
                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from an Outpoint message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Outpoint
     * @static
     * @param {Outpoint} message Outpoint
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Outpoint.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.hash = "";
            object.index = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.value = options.longs === String ? "0" : 0;
        }
        if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = message.hash;
        if (message.index != null && message.hasOwnProperty("index"))
            object.index = message.index;
        if (message.value != null && message.hasOwnProperty("value"))
            if (typeof message.value === "number")
                object.value = options.longs === String ? String(message.value) : message.value;
            else
                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
        return object;
    };

    /**
     * Converts this Outpoint to JSON.
     * @function toJSON
     * @memberof Outpoint
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Outpoint.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Outpoint;
})();

$root.Refund = (function() {

    /**
     * Properties of a Refund.
     * @exports IRefund
     * @interface IRefund
     * @property {string|null} [orderID] Refund orderID
     * @property {google.protobuf.ITimestamp|null} [timestamp] Refund timestamp
     * @property {Array.<IBitcoinSignature>|null} [sigs] Refund sigs
     * @property {Refund.ITransactionInfo|null} [refundTransaction] Refund refundTransaction
     * @property {string|null} [memo] Refund memo
     */

    /**
     * Constructs a new Refund.
     * @exports Refund
     * @classdesc Represents a Refund.
     * @implements IRefund
     * @constructor
     * @param {IRefund=} [properties] Properties to set
     */
    function Refund(properties) {
        this.sigs = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Refund orderID.
     * @member {string} orderID
     * @memberof Refund
     * @instance
     */
    Refund.prototype.orderID = "";

    /**
     * Refund timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof Refund
     * @instance
     */
    Refund.prototype.timestamp = null;

    /**
     * Refund sigs.
     * @member {Array.<IBitcoinSignature>} sigs
     * @memberof Refund
     * @instance
     */
    Refund.prototype.sigs = $util.emptyArray;

    /**
     * Refund refundTransaction.
     * @member {Refund.ITransactionInfo|null|undefined} refundTransaction
     * @memberof Refund
     * @instance
     */
    Refund.prototype.refundTransaction = null;

    /**
     * Refund memo.
     * @member {string} memo
     * @memberof Refund
     * @instance
     */
    Refund.prototype.memo = "";

    /**
     * Creates a new Refund instance using the specified properties.
     * @function create
     * @memberof Refund
     * @static
     * @param {IRefund=} [properties] Properties to set
     * @returns {Refund} Refund instance
     */
    Refund.create = function create(properties) {
        return new Refund(properties);
    };

    /**
     * Encodes the specified Refund message. Does not implicitly {@link Refund.verify|verify} messages.
     * @function encode
     * @memberof Refund
     * @static
     * @param {IRefund} message Refund message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Refund.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderID);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.sigs != null && message.sigs.length)
            for (var i = 0; i < message.sigs.length; ++i)
                $root.BitcoinSignature.encode(message.sigs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.refundTransaction != null && message.hasOwnProperty("refundTransaction"))
            $root.Refund.TransactionInfo.encode(message.refundTransaction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.memo != null && message.hasOwnProperty("memo"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.memo);
        return writer;
    };

    /**
     * Encodes the specified Refund message, length delimited. Does not implicitly {@link Refund.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Refund
     * @static
     * @param {IRefund} message Refund message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Refund.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Refund message from the specified reader or buffer.
     * @function decode
     * @memberof Refund
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Refund} Refund
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Refund.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Refund();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.orderID = reader.string();
                break;
            case 2:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.sigs && message.sigs.length))
                    message.sigs = [];
                message.sigs.push($root.BitcoinSignature.decode(reader, reader.uint32()));
                break;
            case 4:
                message.refundTransaction = $root.Refund.TransactionInfo.decode(reader, reader.uint32());
                break;
            case 5:
                message.memo = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Refund message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Refund
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Refund} Refund
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Refund.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Refund message.
     * @function verify
     * @memberof Refund
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Refund.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            if (!$util.isString(message.orderID))
                return "orderID: string expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.sigs != null && message.hasOwnProperty("sigs")) {
            if (!Array.isArray(message.sigs))
                return "sigs: array expected";
            for (var i = 0; i < message.sigs.length; ++i) {
                var error = $root.BitcoinSignature.verify(message.sigs[i]);
                if (error)
                    return "sigs." + error;
            }
        }
        if (message.refundTransaction != null && message.hasOwnProperty("refundTransaction")) {
            var error = $root.Refund.TransactionInfo.verify(message.refundTransaction);
            if (error)
                return "refundTransaction." + error;
        }
        if (message.memo != null && message.hasOwnProperty("memo"))
            if (!$util.isString(message.memo))
                return "memo: string expected";
        return null;
    };

    /**
     * Creates a Refund message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Refund
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Refund} Refund
     */
    Refund.fromObject = function fromObject(object) {
        if (object instanceof $root.Refund)
            return object;
        var message = new $root.Refund();
        if (object.orderID != null)
            message.orderID = String(object.orderID);
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".Refund.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        if (object.sigs) {
            if (!Array.isArray(object.sigs))
                throw TypeError(".Refund.sigs: array expected");
            message.sigs = [];
            for (var i = 0; i < object.sigs.length; ++i) {
                if (typeof object.sigs[i] !== "object")
                    throw TypeError(".Refund.sigs: object expected");
                message.sigs[i] = $root.BitcoinSignature.fromObject(object.sigs[i]);
            }
        }
        if (object.refundTransaction != null) {
            if (typeof object.refundTransaction !== "object")
                throw TypeError(".Refund.refundTransaction: object expected");
            message.refundTransaction = $root.Refund.TransactionInfo.fromObject(object.refundTransaction);
        }
        if (object.memo != null)
            message.memo = String(object.memo);
        return message;
    };

    /**
     * Creates a plain object from a Refund message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Refund
     * @static
     * @param {Refund} message Refund
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Refund.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.sigs = [];
        if (options.defaults) {
            object.orderID = "";
            object.timestamp = null;
            object.refundTransaction = null;
            object.memo = "";
        }
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            object.orderID = message.orderID;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.sigs && message.sigs.length) {
            object.sigs = [];
            for (var j = 0; j < message.sigs.length; ++j)
                object.sigs[j] = $root.BitcoinSignature.toObject(message.sigs[j], options);
        }
        if (message.refundTransaction != null && message.hasOwnProperty("refundTransaction"))
            object.refundTransaction = $root.Refund.TransactionInfo.toObject(message.refundTransaction, options);
        if (message.memo != null && message.hasOwnProperty("memo"))
            object.memo = message.memo;
        return object;
    };

    /**
     * Converts this Refund to JSON.
     * @function toJSON
     * @memberof Refund
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Refund.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Refund.TransactionInfo = (function() {

        /**
         * Properties of a TransactionInfo.
         * @memberof Refund
         * @interface ITransactionInfo
         * @property {string|null} [txid] TransactionInfo txid
         * @property {number|Long|null} [value] TransactionInfo value
         */

        /**
         * Constructs a new TransactionInfo.
         * @memberof Refund
         * @classdesc Represents a TransactionInfo.
         * @implements ITransactionInfo
         * @constructor
         * @param {Refund.ITransactionInfo=} [properties] Properties to set
         */
        function TransactionInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionInfo txid.
         * @member {string} txid
         * @memberof Refund.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.txid = "";

        /**
         * TransactionInfo value.
         * @member {number|Long} value
         * @memberof Refund.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TransactionInfo instance using the specified properties.
         * @function create
         * @memberof Refund.TransactionInfo
         * @static
         * @param {Refund.ITransactionInfo=} [properties] Properties to set
         * @returns {Refund.TransactionInfo} TransactionInfo instance
         */
        TransactionInfo.create = function create(properties) {
            return new TransactionInfo(properties);
        };

        /**
         * Encodes the specified TransactionInfo message. Does not implicitly {@link Refund.TransactionInfo.verify|verify} messages.
         * @function encode
         * @memberof Refund.TransactionInfo
         * @static
         * @param {Refund.ITransactionInfo} message TransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && message.hasOwnProperty("txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
            return writer;
        };

        /**
         * Encodes the specified TransactionInfo message, length delimited. Does not implicitly {@link Refund.TransactionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Refund.TransactionInfo
         * @static
         * @param {Refund.ITransactionInfo} message TransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Refund.TransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Refund.TransactionInfo} TransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Refund.TransactionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.string();
                    break;
                case 2:
                    message.value = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Refund.TransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Refund.TransactionInfo} TransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionInfo message.
         * @function verify
         * @memberof Refund.TransactionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!$util.isString(message.txid))
                    return "txid: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            return null;
        };

        /**
         * Creates a TransactionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Refund.TransactionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Refund.TransactionInfo} TransactionInfo
         */
        TransactionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Refund.TransactionInfo)
                return object;
            var message = new $root.Refund.TransactionInfo();
            if (object.txid != null)
                message.txid = String(object.txid);
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a TransactionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Refund.TransactionInfo
         * @static
         * @param {Refund.TransactionInfo} message TransactionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.txid = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
            }
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = message.txid;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
            return object;
        };

        /**
         * Converts this TransactionInfo to JSON.
         * @function toJSON
         * @memberof Refund.TransactionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionInfo;
    })();

    return Refund;
})();

$root.ID = (function() {

    /**
     * Properties of a ID.
     * @exports IID
     * @interface IID
     * @property {string|null} [peerID] ID peerID
     * @property {string|null} [handle] ID handle
     * @property {ID.IPubkeys|null} [pubkeys] ID pubkeys
     * @property {Uint8Array|null} [bitcoinSig] ID bitcoinSig
     */

    /**
     * Constructs a new ID.
     * @exports ID
     * @classdesc Represents a ID.
     * @implements IID
     * @constructor
     * @param {IID=} [properties] Properties to set
     */
    function ID(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ID peerID.
     * @member {string} peerID
     * @memberof ID
     * @instance
     */
    ID.prototype.peerID = "";

    /**
     * ID handle.
     * @member {string} handle
     * @memberof ID
     * @instance
     */
    ID.prototype.handle = "";

    /**
     * ID pubkeys.
     * @member {ID.IPubkeys|null|undefined} pubkeys
     * @memberof ID
     * @instance
     */
    ID.prototype.pubkeys = null;

    /**
     * ID bitcoinSig.
     * @member {Uint8Array} bitcoinSig
     * @memberof ID
     * @instance
     */
    ID.prototype.bitcoinSig = $util.newBuffer([]);

    /**
     * Creates a new ID instance using the specified properties.
     * @function create
     * @memberof ID
     * @static
     * @param {IID=} [properties] Properties to set
     * @returns {ID} ID instance
     */
    ID.create = function create(properties) {
        return new ID(properties);
    };

    /**
     * Encodes the specified ID message. Does not implicitly {@link ID.verify|verify} messages.
     * @function encode
     * @memberof ID
     * @static
     * @param {IID} message ID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ID.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.peerID != null && message.hasOwnProperty("peerID"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerID);
        if (message.handle != null && message.hasOwnProperty("handle"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.handle);
        if (message.pubkeys != null && message.hasOwnProperty("pubkeys"))
            $root.ID.Pubkeys.encode(message.pubkeys, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.bitcoinSig != null && message.hasOwnProperty("bitcoinSig"))
            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bitcoinSig);
        return writer;
    };

    /**
     * Encodes the specified ID message, length delimited. Does not implicitly {@link ID.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ID
     * @static
     * @param {IID} message ID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ID.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ID message from the specified reader or buffer.
     * @function decode
     * @memberof ID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ID} ID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ID.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ID();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.peerID = reader.string();
                break;
            case 2:
                message.handle = reader.string();
                break;
            case 3:
                message.pubkeys = $root.ID.Pubkeys.decode(reader, reader.uint32());
                break;
            case 4:
                message.bitcoinSig = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ID message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ID} ID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ID.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ID message.
     * @function verify
     * @memberof ID
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ID.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.peerID != null && message.hasOwnProperty("peerID"))
            if (!$util.isString(message.peerID))
                return "peerID: string expected";
        if (message.handle != null && message.hasOwnProperty("handle"))
            if (!$util.isString(message.handle))
                return "handle: string expected";
        if (message.pubkeys != null && message.hasOwnProperty("pubkeys")) {
            var error = $root.ID.Pubkeys.verify(message.pubkeys);
            if (error)
                return "pubkeys." + error;
        }
        if (message.bitcoinSig != null && message.hasOwnProperty("bitcoinSig"))
            if (!(message.bitcoinSig && typeof message.bitcoinSig.length === "number" || $util.isString(message.bitcoinSig)))
                return "bitcoinSig: buffer expected";
        return null;
    };

    /**
     * Creates a ID message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ID
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ID} ID
     */
    ID.fromObject = function fromObject(object) {
        if (object instanceof $root.ID)
            return object;
        var message = new $root.ID();
        if (object.peerID != null)
            message.peerID = String(object.peerID);
        if (object.handle != null)
            message.handle = String(object.handle);
        if (object.pubkeys != null) {
            if (typeof object.pubkeys !== "object")
                throw TypeError(".ID.pubkeys: object expected");
            message.pubkeys = $root.ID.Pubkeys.fromObject(object.pubkeys);
        }
        if (object.bitcoinSig != null)
            if (typeof object.bitcoinSig === "string")
                $util.base64.decode(object.bitcoinSig, message.bitcoinSig = $util.newBuffer($util.base64.length(object.bitcoinSig)), 0);
            else if (object.bitcoinSig.length)
                message.bitcoinSig = object.bitcoinSig;
        return message;
    };

    /**
     * Creates a plain object from a ID message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ID
     * @static
     * @param {ID} message ID
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ID.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.peerID = "";
            object.handle = "";
            object.pubkeys = null;
            object.bitcoinSig = options.bytes === String ? "" : [];
        }
        if (message.peerID != null && message.hasOwnProperty("peerID"))
            object.peerID = message.peerID;
        if (message.handle != null && message.hasOwnProperty("handle"))
            object.handle = message.handle;
        if (message.pubkeys != null && message.hasOwnProperty("pubkeys"))
            object.pubkeys = $root.ID.Pubkeys.toObject(message.pubkeys, options);
        if (message.bitcoinSig != null && message.hasOwnProperty("bitcoinSig"))
            object.bitcoinSig = options.bytes === String ? $util.base64.encode(message.bitcoinSig, 0, message.bitcoinSig.length) : options.bytes === Array ? Array.prototype.slice.call(message.bitcoinSig) : message.bitcoinSig;
        return object;
    };

    /**
     * Converts this ID to JSON.
     * @function toJSON
     * @memberof ID
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ID.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    ID.Pubkeys = (function() {

        /**
         * Properties of a Pubkeys.
         * @memberof ID
         * @interface IPubkeys
         * @property {Uint8Array|null} [identity] Pubkeys identity
         * @property {Uint8Array|null} [bitcoin] Pubkeys bitcoin
         */

        /**
         * Constructs a new Pubkeys.
         * @memberof ID
         * @classdesc Represents a Pubkeys.
         * @implements IPubkeys
         * @constructor
         * @param {ID.IPubkeys=} [properties] Properties to set
         */
        function Pubkeys(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Pubkeys identity.
         * @member {Uint8Array} identity
         * @memberof ID.Pubkeys
         * @instance
         */
        Pubkeys.prototype.identity = $util.newBuffer([]);

        /**
         * Pubkeys bitcoin.
         * @member {Uint8Array} bitcoin
         * @memberof ID.Pubkeys
         * @instance
         */
        Pubkeys.prototype.bitcoin = $util.newBuffer([]);

        /**
         * Creates a new Pubkeys instance using the specified properties.
         * @function create
         * @memberof ID.Pubkeys
         * @static
         * @param {ID.IPubkeys=} [properties] Properties to set
         * @returns {ID.Pubkeys} Pubkeys instance
         */
        Pubkeys.create = function create(properties) {
            return new Pubkeys(properties);
        };

        /**
         * Encodes the specified Pubkeys message. Does not implicitly {@link ID.Pubkeys.verify|verify} messages.
         * @function encode
         * @memberof ID.Pubkeys
         * @static
         * @param {ID.IPubkeys} message Pubkeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pubkeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && message.hasOwnProperty("identity"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.identity);
            if (message.bitcoin != null && message.hasOwnProperty("bitcoin"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bitcoin);
            return writer;
        };

        /**
         * Encodes the specified Pubkeys message, length delimited. Does not implicitly {@link ID.Pubkeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ID.Pubkeys
         * @static
         * @param {ID.IPubkeys} message Pubkeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pubkeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Pubkeys message from the specified reader or buffer.
         * @function decode
         * @memberof ID.Pubkeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ID.Pubkeys} Pubkeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pubkeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ID.Pubkeys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = reader.bytes();
                    break;
                case 2:
                    message.bitcoin = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Pubkeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ID.Pubkeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ID.Pubkeys} Pubkeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pubkeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Pubkeys message.
         * @function verify
         * @memberof ID.Pubkeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Pubkeys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity"))
                if (!(message.identity && typeof message.identity.length === "number" || $util.isString(message.identity)))
                    return "identity: buffer expected";
            if (message.bitcoin != null && message.hasOwnProperty("bitcoin"))
                if (!(message.bitcoin && typeof message.bitcoin.length === "number" || $util.isString(message.bitcoin)))
                    return "bitcoin: buffer expected";
            return null;
        };

        /**
         * Creates a Pubkeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ID.Pubkeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ID.Pubkeys} Pubkeys
         */
        Pubkeys.fromObject = function fromObject(object) {
            if (object instanceof $root.ID.Pubkeys)
                return object;
            var message = new $root.ID.Pubkeys();
            if (object.identity != null)
                if (typeof object.identity === "string")
                    $util.base64.decode(object.identity, message.identity = $util.newBuffer($util.base64.length(object.identity)), 0);
                else if (object.identity.length)
                    message.identity = object.identity;
            if (object.bitcoin != null)
                if (typeof object.bitcoin === "string")
                    $util.base64.decode(object.bitcoin, message.bitcoin = $util.newBuffer($util.base64.length(object.bitcoin)), 0);
                else if (object.bitcoin.length)
                    message.bitcoin = object.bitcoin;
            return message;
        };

        /**
         * Creates a plain object from a Pubkeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ID.Pubkeys
         * @static
         * @param {ID.Pubkeys} message Pubkeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Pubkeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.identity = options.bytes === String ? "" : [];
                object.bitcoin = options.bytes === String ? "" : [];
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = options.bytes === String ? $util.base64.encode(message.identity, 0, message.identity.length) : options.bytes === Array ? Array.prototype.slice.call(message.identity) : message.identity;
            if (message.bitcoin != null && message.hasOwnProperty("bitcoin"))
                object.bitcoin = options.bytes === String ? $util.base64.encode(message.bitcoin, 0, message.bitcoin.length) : options.bytes === Array ? Array.prototype.slice.call(message.bitcoin) : message.bitcoin;
            return object;
        };

        /**
         * Converts this Pubkeys to JSON.
         * @function toJSON
         * @memberof ID.Pubkeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Pubkeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Pubkeys;
    })();

    return ID;
})();

$root.Signature = (function() {

    /**
     * Properties of a Signature.
     * @exports ISignature
     * @interface ISignature
     * @property {Signature.Section|null} [section] Signature section
     * @property {Uint8Array|null} [signatureBytes] Signature signatureBytes
     */

    /**
     * Constructs a new Signature.
     * @exports Signature
     * @classdesc Represents a Signature.
     * @implements ISignature
     * @constructor
     * @param {ISignature=} [properties] Properties to set
     */
    function Signature(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Signature section.
     * @member {Signature.Section} section
     * @memberof Signature
     * @instance
     */
    Signature.prototype.section = 0;

    /**
     * Signature signatureBytes.
     * @member {Uint8Array} signatureBytes
     * @memberof Signature
     * @instance
     */
    Signature.prototype.signatureBytes = $util.newBuffer([]);

    /**
     * Creates a new Signature instance using the specified properties.
     * @function create
     * @memberof Signature
     * @static
     * @param {ISignature=} [properties] Properties to set
     * @returns {Signature} Signature instance
     */
    Signature.create = function create(properties) {
        return new Signature(properties);
    };

    /**
     * Encodes the specified Signature message. Does not implicitly {@link Signature.verify|verify} messages.
     * @function encode
     * @memberof Signature
     * @static
     * @param {ISignature} message Signature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Signature.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.section != null && message.hasOwnProperty("section"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.section);
        if (message.signatureBytes != null && message.hasOwnProperty("signatureBytes"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signatureBytes);
        return writer;
    };

    /**
     * Encodes the specified Signature message, length delimited. Does not implicitly {@link Signature.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Signature
     * @static
     * @param {ISignature} message Signature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Signature.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Signature message from the specified reader or buffer.
     * @function decode
     * @memberof Signature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Signature} Signature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Signature.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Signature();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.section = reader.int32();
                break;
            case 2:
                message.signatureBytes = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Signature message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Signature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Signature} Signature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Signature.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Signature message.
     * @function verify
     * @memberof Signature
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Signature.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.section != null && message.hasOwnProperty("section"))
            switch (message.section) {
            default:
                return "section: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                break;
            }
        if (message.signatureBytes != null && message.hasOwnProperty("signatureBytes"))
            if (!(message.signatureBytes && typeof message.signatureBytes.length === "number" || $util.isString(message.signatureBytes)))
                return "signatureBytes: buffer expected";
        return null;
    };

    /**
     * Creates a Signature message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Signature
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Signature} Signature
     */
    Signature.fromObject = function fromObject(object) {
        if (object instanceof $root.Signature)
            return object;
        var message = new $root.Signature();
        switch (object.section) {
        case "LISTING":
        case 0:
            message.section = 0;
            break;
        case "ORDER":
        case 1:
            message.section = 1;
            break;
        case "ORDER_CONFIRMATION":
        case 2:
            message.section = 2;
            break;
        case "ORDER_FULFILLMENT":
        case 3:
            message.section = 3;
            break;
        case "ORDER_COMPLETION":
        case 4:
            message.section = 4;
            break;
        case "DISPUTE":
        case 5:
            message.section = 5;
            break;
        case "DISPUTE_RESOLUTION":
        case 6:
            message.section = 6;
            break;
        case "REFUND":
        case 7:
            message.section = 7;
            break;
        }
        if (object.signatureBytes != null)
            if (typeof object.signatureBytes === "string")
                $util.base64.decode(object.signatureBytes, message.signatureBytes = $util.newBuffer($util.base64.length(object.signatureBytes)), 0);
            else if (object.signatureBytes.length)
                message.signatureBytes = object.signatureBytes;
        return message;
    };

    /**
     * Creates a plain object from a Signature message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Signature
     * @static
     * @param {Signature} message Signature
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Signature.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.section = options.enums === String ? "LISTING" : 0;
            object.signatureBytes = options.bytes === String ? "" : [];
        }
        if (message.section != null && message.hasOwnProperty("section"))
            object.section = options.enums === String ? $root.Signature.Section[message.section] : message.section;
        if (message.signatureBytes != null && message.hasOwnProperty("signatureBytes"))
            object.signatureBytes = options.bytes === String ? $util.base64.encode(message.signatureBytes, 0, message.signatureBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.signatureBytes) : message.signatureBytes;
        return object;
    };

    /**
     * Converts this Signature to JSON.
     * @function toJSON
     * @memberof Signature
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Signature.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Section enum.
     * @name Signature.Section
     * @enum {string}
     * @property {number} LISTING=0 LISTING value
     * @property {number} ORDER=1 ORDER value
     * @property {number} ORDER_CONFIRMATION=2 ORDER_CONFIRMATION value
     * @property {number} ORDER_FULFILLMENT=3 ORDER_FULFILLMENT value
     * @property {number} ORDER_COMPLETION=4 ORDER_COMPLETION value
     * @property {number} DISPUTE=5 DISPUTE value
     * @property {number} DISPUTE_RESOLUTION=6 DISPUTE_RESOLUTION value
     * @property {number} REFUND=7 REFUND value
     */
    Signature.Section = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LISTING"] = 0;
        values[valuesById[1] = "ORDER"] = 1;
        values[valuesById[2] = "ORDER_CONFIRMATION"] = 2;
        values[valuesById[3] = "ORDER_FULFILLMENT"] = 3;
        values[valuesById[4] = "ORDER_COMPLETION"] = 4;
        values[valuesById[5] = "DISPUTE"] = 5;
        values[valuesById[6] = "DISPUTE_RESOLUTION"] = 6;
        values[valuesById[7] = "REFUND"] = 7;
        return values;
    })();

    return Signature;
})();

$root.SignedListing = (function() {

    /**
     * Properties of a SignedListing.
     * @exports ISignedListing
     * @interface ISignedListing
     * @property {IListing|null} [listing] SignedListing listing
     * @property {string|null} [hash] SignedListing hash
     * @property {Uint8Array|null} [signature] SignedListing signature
     */

    /**
     * Constructs a new SignedListing.
     * @exports SignedListing
     * @classdesc Represents a SignedListing.
     * @implements ISignedListing
     * @constructor
     * @param {ISignedListing=} [properties] Properties to set
     */
    function SignedListing(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SignedListing listing.
     * @member {IListing|null|undefined} listing
     * @memberof SignedListing
     * @instance
     */
    SignedListing.prototype.listing = null;

    /**
     * SignedListing hash.
     * @member {string} hash
     * @memberof SignedListing
     * @instance
     */
    SignedListing.prototype.hash = "";

    /**
     * SignedListing signature.
     * @member {Uint8Array} signature
     * @memberof SignedListing
     * @instance
     */
    SignedListing.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new SignedListing instance using the specified properties.
     * @function create
     * @memberof SignedListing
     * @static
     * @param {ISignedListing=} [properties] Properties to set
     * @returns {SignedListing} SignedListing instance
     */
    SignedListing.create = function create(properties) {
        return new SignedListing(properties);
    };

    /**
     * Encodes the specified SignedListing message. Does not implicitly {@link SignedListing.verify|verify} messages.
     * @function encode
     * @memberof SignedListing
     * @static
     * @param {ISignedListing} message SignedListing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignedListing.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.listing != null && message.hasOwnProperty("listing"))
            $root.Listing.encode(message.listing, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.hash);
        if (message.signature != null && message.hasOwnProperty("signature"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
        return writer;
    };

    /**
     * Encodes the specified SignedListing message, length delimited. Does not implicitly {@link SignedListing.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SignedListing
     * @static
     * @param {ISignedListing} message SignedListing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignedListing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SignedListing message from the specified reader or buffer.
     * @function decode
     * @memberof SignedListing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SignedListing} SignedListing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignedListing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SignedListing();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.listing = $root.Listing.decode(reader, reader.uint32());
                break;
            case 2:
                message.hash = reader.string();
                break;
            case 3:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SignedListing message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SignedListing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SignedListing} SignedListing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignedListing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SignedListing message.
     * @function verify
     * @memberof SignedListing
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SignedListing.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.listing != null && message.hasOwnProperty("listing")) {
            var error = $root.Listing.verify(message.listing);
            if (error)
                return "listing." + error;
        }
        if (message.hash != null && message.hasOwnProperty("hash"))
            if (!$util.isString(message.hash))
                return "hash: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates a SignedListing message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SignedListing
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SignedListing} SignedListing
     */
    SignedListing.fromObject = function fromObject(object) {
        if (object instanceof $root.SignedListing)
            return object;
        var message = new $root.SignedListing();
        if (object.listing != null) {
            if (typeof object.listing !== "object")
                throw TypeError(".SignedListing.listing: object expected");
            message.listing = $root.Listing.fromObject(object.listing);
        }
        if (object.hash != null)
            message.hash = String(object.hash);
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from a SignedListing message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SignedListing
     * @static
     * @param {SignedListing} message SignedListing
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SignedListing.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.listing = null;
            object.hash = "";
            object.signature = options.bytes === String ? "" : [];
        }
        if (message.listing != null && message.hasOwnProperty("listing"))
            object.listing = $root.Listing.toObject(message.listing, options);
        if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = message.hash;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        return object;
    };

    /**
     * Converts this SignedListing to JSON.
     * @function toJSON
     * @memberof SignedListing
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SignedListing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SignedListing;
})();

/**
 * CountryCode enum.
 * @exports CountryCode
 * @enum {string}
 * @property {number} NA=0 NA value
 * @property {number} AFGHANISTAN=1 AFGHANISTAN value
 * @property {number} ALAND_ISLANDS=2 ALAND_ISLANDS value
 * @property {number} ALBANIA=3 ALBANIA value
 * @property {number} ALGERIA=4 ALGERIA value
 * @property {number} AMERICAN_SAMOA=5 AMERICAN_SAMOA value
 * @property {number} ANDORRA=6 ANDORRA value
 * @property {number} ANGOLA=7 ANGOLA value
 * @property {number} ANGUILLA=8 ANGUILLA value
 * @property {number} ANTIGUA=9 ANTIGUA value
 * @property {number} ARGENTINA=10 ARGENTINA value
 * @property {number} ARMENIA=11 ARMENIA value
 * @property {number} ARUBA=12 ARUBA value
 * @property {number} AUSTRALIA=13 AUSTRALIA value
 * @property {number} AUSTRIA=14 AUSTRIA value
 * @property {number} AZERBAIJAN=15 AZERBAIJAN value
 * @property {number} BAHAMAS=16 BAHAMAS value
 * @property {number} BAHRAIN=17 BAHRAIN value
 * @property {number} BANGLADESH=18 BANGLADESH value
 * @property {number} BARBADOS=19 BARBADOS value
 * @property {number} BELARUS=20 BELARUS value
 * @property {number} BELGIUM=21 BELGIUM value
 * @property {number} BELIZE=22 BELIZE value
 * @property {number} BENIN=23 BENIN value
 * @property {number} BERMUDA=24 BERMUDA value
 * @property {number} BHUTAN=25 BHUTAN value
 * @property {number} BOLIVIA=26 BOLIVIA value
 * @property {number} BONAIRE_SINT_EUSTATIUS_SABA=27 BONAIRE_SINT_EUSTATIUS_SABA value
 * @property {number} BOSNIA=28 BOSNIA value
 * @property {number} BOTSWANA=29 BOTSWANA value
 * @property {number} BOUVET_ISLAND=30 BOUVET_ISLAND value
 * @property {number} BRAZIL=31 BRAZIL value
 * @property {number} BRITISH_INDIAN_OCEAN_TERRITORY=32 BRITISH_INDIAN_OCEAN_TERRITORY value
 * @property {number} BRUNEI_DARUSSALAM=33 BRUNEI_DARUSSALAM value
 * @property {number} BULGARIA=34 BULGARIA value
 * @property {number} BURKINA_FASO=35 BURKINA_FASO value
 * @property {number} BURUNDI=36 BURUNDI value
 * @property {number} CABO_VERDE=37 CABO_VERDE value
 * @property {number} CAMBODIA=38 CAMBODIA value
 * @property {number} CAMEROON=39 CAMEROON value
 * @property {number} CANADA=40 CANADA value
 * @property {number} CAYMAN_ISLANDS=41 CAYMAN_ISLANDS value
 * @property {number} CENTRAL_AFRICAN_REPUBLIC=42 CENTRAL_AFRICAN_REPUBLIC value
 * @property {number} CHAD=43 CHAD value
 * @property {number} CHILE=44 CHILE value
 * @property {number} CHINA=45 CHINA value
 * @property {number} CHRISTMAS_ISLAND=46 CHRISTMAS_ISLAND value
 * @property {number} COCOS_ISLANDS=47 COCOS_ISLANDS value
 * @property {number} COLOMBIA=48 COLOMBIA value
 * @property {number} COMOROS=49 COMOROS value
 * @property {number} CONGO_REPUBLIC=50 CONGO_REPUBLIC value
 * @property {number} CONGO=51 CONGO value
 * @property {number} COOK_ISLANDS=52 COOK_ISLANDS value
 * @property {number} COSTA_RICA=53 COSTA_RICA value
 * @property {number} COTE_DIVOIRE=54 COTE_DIVOIRE value
 * @property {number} CROATIA=55 CROATIA value
 * @property {number} CUBA=56 CUBA value
 * @property {number} CURACAO=57 CURACAO value
 * @property {number} CYPRUS=58 CYPRUS value
 * @property {number} CZECH_REPUBLIC=59 CZECH_REPUBLIC value
 * @property {number} DENMARK=60 DENMARK value
 * @property {number} DJIBOUTI=61 DJIBOUTI value
 * @property {number} DOMINICA=62 DOMINICA value
 * @property {number} DOMINICAN_REPUBLIC=63 DOMINICAN_REPUBLIC value
 * @property {number} ECUADOR=64 ECUADOR value
 * @property {number} EGYPT=65 EGYPT value
 * @property {number} EL_SALVADOR=66 EL_SALVADOR value
 * @property {number} EQUATORIAL_GUINEA=67 EQUATORIAL_GUINEA value
 * @property {number} ERITREA=68 ERITREA value
 * @property {number} ESTONIA=69 ESTONIA value
 * @property {number} ETHIOPIA=70 ETHIOPIA value
 * @property {number} FALKLAND_ISLANDS=71 FALKLAND_ISLANDS value
 * @property {number} FAROE_ISLANDS=72 FAROE_ISLANDS value
 * @property {number} FIJI=73 FIJI value
 * @property {number} FINLAND=74 FINLAND value
 * @property {number} FRANCE=75 FRANCE value
 * @property {number} FRENCH_GUIANA=76 FRENCH_GUIANA value
 * @property {number} FRENCH_POLYNESIA=77 FRENCH_POLYNESIA value
 * @property {number} FRENCH_SOUTHERN_TERRITORIES=78 FRENCH_SOUTHERN_TERRITORIES value
 * @property {number} GABON=79 GABON value
 * @property {number} GAMBIA=80 GAMBIA value
 * @property {number} GEORGIA=81 GEORGIA value
 * @property {number} GERMANY=82 GERMANY value
 * @property {number} GHANA=83 GHANA value
 * @property {number} GIBRALTAR=84 GIBRALTAR value
 * @property {number} GREECE=85 GREECE value
 * @property {number} GREENLAND=86 GREENLAND value
 * @property {number} GRENADA=87 GRENADA value
 * @property {number} GUADELOUPE=88 GUADELOUPE value
 * @property {number} GUAM=89 GUAM value
 * @property {number} GUATEMALA=90 GUATEMALA value
 * @property {number} GUERNSEY=91 GUERNSEY value
 * @property {number} GUINEA=92 GUINEA value
 * @property {number} GUINEA_BISSAU=93 GUINEA_BISSAU value
 * @property {number} GUYANA=94 GUYANA value
 * @property {number} HAITI=95 HAITI value
 * @property {number} HEARD_ISLAND=96 HEARD_ISLAND value
 * @property {number} HOLY_SEE=97 HOLY_SEE value
 * @property {number} HONDURAS=98 HONDURAS value
 * @property {number} HONG_KONG=99 HONG_KONG value
 * @property {number} HUNGARY=100 HUNGARY value
 * @property {number} ICELAND=101 ICELAND value
 * @property {number} INDIA=102 INDIA value
 * @property {number} INDONESIA=103 INDONESIA value
 * @property {number} IRAN=104 IRAN value
 * @property {number} IRAQ=105 IRAQ value
 * @property {number} IRELAND=106 IRELAND value
 * @property {number} ISLE_OF_MAN=107 ISLE_OF_MAN value
 * @property {number} ISRAEL=108 ISRAEL value
 * @property {number} ITALY=109 ITALY value
 * @property {number} JAMAICA=110 JAMAICA value
 * @property {number} JAPAN=111 JAPAN value
 * @property {number} JERSEY=112 JERSEY value
 * @property {number} JORDAN=113 JORDAN value
 * @property {number} KAZAKHSTAN=114 KAZAKHSTAN value
 * @property {number} KENYA=115 KENYA value
 * @property {number} KIRIBATI=116 KIRIBATI value
 * @property {number} NORTH_KOREA=117 NORTH_KOREA value
 * @property {number} SOUTH_KOREA=118 SOUTH_KOREA value
 * @property {number} KUWAIT=119 KUWAIT value
 * @property {number} KYRGYZSTAN=120 KYRGYZSTAN value
 * @property {number} LAO=121 LAO value
 * @property {number} LATVIA=122 LATVIA value
 * @property {number} LEBANON=123 LEBANON value
 * @property {number} LESOTHO=124 LESOTHO value
 * @property {number} LIBERIA=125 LIBERIA value
 * @property {number} LIBYA=126 LIBYA value
 * @property {number} LIECHTENSTEIN=127 LIECHTENSTEIN value
 * @property {number} LITHUANIA=128 LITHUANIA value
 * @property {number} LUXEMBOURG=129 LUXEMBOURG value
 * @property {number} MACAO=130 MACAO value
 * @property {number} MACEDONIA=131 MACEDONIA value
 * @property {number} MADAGASCAR=132 MADAGASCAR value
 * @property {number} MALAWI=133 MALAWI value
 * @property {number} MALAYSIA=134 MALAYSIA value
 * @property {number} MALDIVES=135 MALDIVES value
 * @property {number} MALI=136 MALI value
 * @property {number} MALTA=137 MALTA value
 * @property {number} MARSHALL_ISLANDS=138 MARSHALL_ISLANDS value
 * @property {number} MARTINIQUE=139 MARTINIQUE value
 * @property {number} MAURITANIA=140 MAURITANIA value
 * @property {number} MAURITIUS=141 MAURITIUS value
 * @property {number} MAYOTTE=142 MAYOTTE value
 * @property {number} MEXICO=143 MEXICO value
 * @property {number} MICRONESIA=144 MICRONESIA value
 * @property {number} MOLDOVA=145 MOLDOVA value
 * @property {number} MONACO=146 MONACO value
 * @property {number} MONGOLIA=147 MONGOLIA value
 * @property {number} MONTENEGRO=148 MONTENEGRO value
 * @property {number} MONTSERRAT=149 MONTSERRAT value
 * @property {number} MOROCCO=150 MOROCCO value
 * @property {number} MOZAMBIQUE=151 MOZAMBIQUE value
 * @property {number} MYANMAR=152 MYANMAR value
 * @property {number} NAMIBIA=153 NAMIBIA value
 * @property {number} NAURU=154 NAURU value
 * @property {number} NEPAL=155 NEPAL value
 * @property {number} NETHERLANDS=156 NETHERLANDS value
 * @property {number} NEW_CALEDONIA=157 NEW_CALEDONIA value
 * @property {number} NEW_ZEALAND=158 NEW_ZEALAND value
 * @property {number} NICARAGUA=159 NICARAGUA value
 * @property {number} NIGER=160 NIGER value
 * @property {number} NIGERIA=161 NIGERIA value
 * @property {number} NIUE=162 NIUE value
 * @property {number} NORFOLK_ISLAND=163 NORFOLK_ISLAND value
 * @property {number} NORTHERN_MARIANA_ISLANDS=164 NORTHERN_MARIANA_ISLANDS value
 * @property {number} NORWAY=165 NORWAY value
 * @property {number} OMAN=166 OMAN value
 * @property {number} PAKISTAN=167 PAKISTAN value
 * @property {number} PALAU=168 PALAU value
 * @property {number} PANAMA=169 PANAMA value
 * @property {number} PAPUA_NEW_GUINEA=170 PAPUA_NEW_GUINEA value
 * @property {number} PARAGUAY=171 PARAGUAY value
 * @property {number} PERU=172 PERU value
 * @property {number} PHILIPPINES=173 PHILIPPINES value
 * @property {number} PITCAIRN=174 PITCAIRN value
 * @property {number} POLAND=175 POLAND value
 * @property {number} PORTUGAL=176 PORTUGAL value
 * @property {number} PUERTO_RICO=177 PUERTO_RICO value
 * @property {number} QATAR=178 QATAR value
 * @property {number} REUNION=179 REUNION value
 * @property {number} ROMANIA=180 ROMANIA value
 * @property {number} RUSSIA=181 RUSSIA value
 * @property {number} RWANDA=182 RWANDA value
 * @property {number} SAINT_BARTHELEMY=183 SAINT_BARTHELEMY value
 * @property {number} SAINT_HELENA=184 SAINT_HELENA value
 * @property {number} SAINT_KITTS=185 SAINT_KITTS value
 * @property {number} SAINT_LUCIA=186 SAINT_LUCIA value
 * @property {number} SAINT_MARTIN=187 SAINT_MARTIN value
 * @property {number} SAINT_PIERRE=188 SAINT_PIERRE value
 * @property {number} SAINT_VINCENT=189 SAINT_VINCENT value
 * @property {number} SAMOA=190 SAMOA value
 * @property {number} SAN_MARINO=191 SAN_MARINO value
 * @property {number} SAO_TOME=192 SAO_TOME value
 * @property {number} SAUDI_ARABIA=193 SAUDI_ARABIA value
 * @property {number} SENEGAL=194 SENEGAL value
 * @property {number} SERBIA=195 SERBIA value
 * @property {number} SEYCHELLES=196 SEYCHELLES value
 * @property {number} SIERRA_LEONE=197 SIERRA_LEONE value
 * @property {number} SINGAPORE=198 SINGAPORE value
 * @property {number} SINT_MAARTEN=199 SINT_MAARTEN value
 * @property {number} SUCRE=200 SUCRE value
 * @property {number} SLOVAKIA=201 SLOVAKIA value
 * @property {number} SLOVENIA=202 SLOVENIA value
 * @property {number} SOLOMON_ISLANDS=203 SOLOMON_ISLANDS value
 * @property {number} SOMALIA=204 SOMALIA value
 * @property {number} SOUTH_AFRICA=205 SOUTH_AFRICA value
 * @property {number} SOUTH_SUDAN=206 SOUTH_SUDAN value
 * @property {number} SPAIN=207 SPAIN value
 * @property {number} SRI_LANKA=208 SRI_LANKA value
 * @property {number} SUDAN=209 SUDAN value
 * @property {number} SURINAME=210 SURINAME value
 * @property {number} SVALBARD=211 SVALBARD value
 * @property {number} SWAZILAND=212 SWAZILAND value
 * @property {number} SWEDEN=213 SWEDEN value
 * @property {number} SWITZERLAND=214 SWITZERLAND value
 * @property {number} SYRIAN_ARAB_REPUBLIC=215 SYRIAN_ARAB_REPUBLIC value
 * @property {number} TAIWAN=216 TAIWAN value
 * @property {number} TAJIKISTAN=217 TAJIKISTAN value
 * @property {number} TANZANIA=218 TANZANIA value
 * @property {number} THAILAND=219 THAILAND value
 * @property {number} TIMOR_LESTE=220 TIMOR_LESTE value
 * @property {number} TOGO=221 TOGO value
 * @property {number} TOKELAU=222 TOKELAU value
 * @property {number} TONGA=223 TONGA value
 * @property {number} TRINIDAD=224 TRINIDAD value
 * @property {number} TUNISIA=225 TUNISIA value
 * @property {number} TURKEY=226 TURKEY value
 * @property {number} TURKMENISTAN=227 TURKMENISTAN value
 * @property {number} TURKS_AND_CAICOS_ISLANDS=228 TURKS_AND_CAICOS_ISLANDS value
 * @property {number} TUVALU=229 TUVALU value
 * @property {number} UGANDA=230 UGANDA value
 * @property {number} UKRAINE=231 UKRAINE value
 * @property {number} UNITED_ARAB_EMIRATES=232 UNITED_ARAB_EMIRATES value
 * @property {number} UNITED_KINGDOM=233 UNITED_KINGDOM value
 * @property {number} UNITED_STATES=234 UNITED_STATES value
 * @property {number} URUGUAY=235 URUGUAY value
 * @property {number} UZBEKISTAN=236 UZBEKISTAN value
 * @property {number} VANUATU=237 VANUATU value
 * @property {number} VENEZUELA=238 VENEZUELA value
 * @property {number} VIETNAM=239 VIETNAM value
 * @property {number} VIRGIN_ISLANDS_BRITISH=240 VIRGIN_ISLANDS_BRITISH value
 * @property {number} VIRGIN_ISLANDS_US=241 VIRGIN_ISLANDS_US value
 * @property {number} WALLIS_AND_FUTUNA=242 WALLIS_AND_FUTUNA value
 * @property {number} WESTERN_SAHARA=243 WESTERN_SAHARA value
 * @property {number} YEMEN=244 YEMEN value
 * @property {number} ZAMBIA=245 ZAMBIA value
 * @property {number} ZIMBABWE=246 ZIMBABWE value
 * @property {number} ALL=500 ALL value
 * @property {number} AFRICA=501 AFRICA value
 * @property {number} ASIA=502 ASIA value
 * @property {number} CENTRAL_AMERICA=503 CENTRAL_AMERICA value
 * @property {number} EUROPE=504 EUROPE value
 * @property {number} MIDDLE_EAST=505 MIDDLE_EAST value
 * @property {number} NORTH_AMERICA=506 NORTH_AMERICA value
 * @property {number} SOUTH_AMERICA=507 SOUTH_AMERICA value
 * @property {number} OCEANIA=508 OCEANIA value
 */
$root.CountryCode = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "NA"] = 0;
    values[valuesById[1] = "AFGHANISTAN"] = 1;
    values[valuesById[2] = "ALAND_ISLANDS"] = 2;
    values[valuesById[3] = "ALBANIA"] = 3;
    values[valuesById[4] = "ALGERIA"] = 4;
    values[valuesById[5] = "AMERICAN_SAMOA"] = 5;
    values[valuesById[6] = "ANDORRA"] = 6;
    values[valuesById[7] = "ANGOLA"] = 7;
    values[valuesById[8] = "ANGUILLA"] = 8;
    values[valuesById[9] = "ANTIGUA"] = 9;
    values[valuesById[10] = "ARGENTINA"] = 10;
    values[valuesById[11] = "ARMENIA"] = 11;
    values[valuesById[12] = "ARUBA"] = 12;
    values[valuesById[13] = "AUSTRALIA"] = 13;
    values[valuesById[14] = "AUSTRIA"] = 14;
    values[valuesById[15] = "AZERBAIJAN"] = 15;
    values[valuesById[16] = "BAHAMAS"] = 16;
    values[valuesById[17] = "BAHRAIN"] = 17;
    values[valuesById[18] = "BANGLADESH"] = 18;
    values[valuesById[19] = "BARBADOS"] = 19;
    values[valuesById[20] = "BELARUS"] = 20;
    values[valuesById[21] = "BELGIUM"] = 21;
    values[valuesById[22] = "BELIZE"] = 22;
    values[valuesById[23] = "BENIN"] = 23;
    values[valuesById[24] = "BERMUDA"] = 24;
    values[valuesById[25] = "BHUTAN"] = 25;
    values[valuesById[26] = "BOLIVIA"] = 26;
    values[valuesById[27] = "BONAIRE_SINT_EUSTATIUS_SABA"] = 27;
    values[valuesById[28] = "BOSNIA"] = 28;
    values[valuesById[29] = "BOTSWANA"] = 29;
    values[valuesById[30] = "BOUVET_ISLAND"] = 30;
    values[valuesById[31] = "BRAZIL"] = 31;
    values[valuesById[32] = "BRITISH_INDIAN_OCEAN_TERRITORY"] = 32;
    values[valuesById[33] = "BRUNEI_DARUSSALAM"] = 33;
    values[valuesById[34] = "BULGARIA"] = 34;
    values[valuesById[35] = "BURKINA_FASO"] = 35;
    values[valuesById[36] = "BURUNDI"] = 36;
    values[valuesById[37] = "CABO_VERDE"] = 37;
    values[valuesById[38] = "CAMBODIA"] = 38;
    values[valuesById[39] = "CAMEROON"] = 39;
    values[valuesById[40] = "CANADA"] = 40;
    values[valuesById[41] = "CAYMAN_ISLANDS"] = 41;
    values[valuesById[42] = "CENTRAL_AFRICAN_REPUBLIC"] = 42;
    values[valuesById[43] = "CHAD"] = 43;
    values[valuesById[44] = "CHILE"] = 44;
    values[valuesById[45] = "CHINA"] = 45;
    values[valuesById[46] = "CHRISTMAS_ISLAND"] = 46;
    values[valuesById[47] = "COCOS_ISLANDS"] = 47;
    values[valuesById[48] = "COLOMBIA"] = 48;
    values[valuesById[49] = "COMOROS"] = 49;
    values[valuesById[50] = "CONGO_REPUBLIC"] = 50;
    values[valuesById[51] = "CONGO"] = 51;
    values[valuesById[52] = "COOK_ISLANDS"] = 52;
    values[valuesById[53] = "COSTA_RICA"] = 53;
    values[valuesById[54] = "COTE_DIVOIRE"] = 54;
    values[valuesById[55] = "CROATIA"] = 55;
    values[valuesById[56] = "CUBA"] = 56;
    values[valuesById[57] = "CURACAO"] = 57;
    values[valuesById[58] = "CYPRUS"] = 58;
    values[valuesById[59] = "CZECH_REPUBLIC"] = 59;
    values[valuesById[60] = "DENMARK"] = 60;
    values[valuesById[61] = "DJIBOUTI"] = 61;
    values[valuesById[62] = "DOMINICA"] = 62;
    values[valuesById[63] = "DOMINICAN_REPUBLIC"] = 63;
    values[valuesById[64] = "ECUADOR"] = 64;
    values[valuesById[65] = "EGYPT"] = 65;
    values[valuesById[66] = "EL_SALVADOR"] = 66;
    values[valuesById[67] = "EQUATORIAL_GUINEA"] = 67;
    values[valuesById[68] = "ERITREA"] = 68;
    values[valuesById[69] = "ESTONIA"] = 69;
    values[valuesById[70] = "ETHIOPIA"] = 70;
    values[valuesById[71] = "FALKLAND_ISLANDS"] = 71;
    values[valuesById[72] = "FAROE_ISLANDS"] = 72;
    values[valuesById[73] = "FIJI"] = 73;
    values[valuesById[74] = "FINLAND"] = 74;
    values[valuesById[75] = "FRANCE"] = 75;
    values[valuesById[76] = "FRENCH_GUIANA"] = 76;
    values[valuesById[77] = "FRENCH_POLYNESIA"] = 77;
    values[valuesById[78] = "FRENCH_SOUTHERN_TERRITORIES"] = 78;
    values[valuesById[79] = "GABON"] = 79;
    values[valuesById[80] = "GAMBIA"] = 80;
    values[valuesById[81] = "GEORGIA"] = 81;
    values[valuesById[82] = "GERMANY"] = 82;
    values[valuesById[83] = "GHANA"] = 83;
    values[valuesById[84] = "GIBRALTAR"] = 84;
    values[valuesById[85] = "GREECE"] = 85;
    values[valuesById[86] = "GREENLAND"] = 86;
    values[valuesById[87] = "GRENADA"] = 87;
    values[valuesById[88] = "GUADELOUPE"] = 88;
    values[valuesById[89] = "GUAM"] = 89;
    values[valuesById[90] = "GUATEMALA"] = 90;
    values[valuesById[91] = "GUERNSEY"] = 91;
    values[valuesById[92] = "GUINEA"] = 92;
    values[valuesById[93] = "GUINEA_BISSAU"] = 93;
    values[valuesById[94] = "GUYANA"] = 94;
    values[valuesById[95] = "HAITI"] = 95;
    values[valuesById[96] = "HEARD_ISLAND"] = 96;
    values[valuesById[97] = "HOLY_SEE"] = 97;
    values[valuesById[98] = "HONDURAS"] = 98;
    values[valuesById[99] = "HONG_KONG"] = 99;
    values[valuesById[100] = "HUNGARY"] = 100;
    values[valuesById[101] = "ICELAND"] = 101;
    values[valuesById[102] = "INDIA"] = 102;
    values[valuesById[103] = "INDONESIA"] = 103;
    values[valuesById[104] = "IRAN"] = 104;
    values[valuesById[105] = "IRAQ"] = 105;
    values[valuesById[106] = "IRELAND"] = 106;
    values[valuesById[107] = "ISLE_OF_MAN"] = 107;
    values[valuesById[108] = "ISRAEL"] = 108;
    values[valuesById[109] = "ITALY"] = 109;
    values[valuesById[110] = "JAMAICA"] = 110;
    values[valuesById[111] = "JAPAN"] = 111;
    values[valuesById[112] = "JERSEY"] = 112;
    values[valuesById[113] = "JORDAN"] = 113;
    values[valuesById[114] = "KAZAKHSTAN"] = 114;
    values[valuesById[115] = "KENYA"] = 115;
    values[valuesById[116] = "KIRIBATI"] = 116;
    values[valuesById[117] = "NORTH_KOREA"] = 117;
    values[valuesById[118] = "SOUTH_KOREA"] = 118;
    values[valuesById[119] = "KUWAIT"] = 119;
    values[valuesById[120] = "KYRGYZSTAN"] = 120;
    values[valuesById[121] = "LAO"] = 121;
    values[valuesById[122] = "LATVIA"] = 122;
    values[valuesById[123] = "LEBANON"] = 123;
    values[valuesById[124] = "LESOTHO"] = 124;
    values[valuesById[125] = "LIBERIA"] = 125;
    values[valuesById[126] = "LIBYA"] = 126;
    values[valuesById[127] = "LIECHTENSTEIN"] = 127;
    values[valuesById[128] = "LITHUANIA"] = 128;
    values[valuesById[129] = "LUXEMBOURG"] = 129;
    values[valuesById[130] = "MACAO"] = 130;
    values[valuesById[131] = "MACEDONIA"] = 131;
    values[valuesById[132] = "MADAGASCAR"] = 132;
    values[valuesById[133] = "MALAWI"] = 133;
    values[valuesById[134] = "MALAYSIA"] = 134;
    values[valuesById[135] = "MALDIVES"] = 135;
    values[valuesById[136] = "MALI"] = 136;
    values[valuesById[137] = "MALTA"] = 137;
    values[valuesById[138] = "MARSHALL_ISLANDS"] = 138;
    values[valuesById[139] = "MARTINIQUE"] = 139;
    values[valuesById[140] = "MAURITANIA"] = 140;
    values[valuesById[141] = "MAURITIUS"] = 141;
    values[valuesById[142] = "MAYOTTE"] = 142;
    values[valuesById[143] = "MEXICO"] = 143;
    values[valuesById[144] = "MICRONESIA"] = 144;
    values[valuesById[145] = "MOLDOVA"] = 145;
    values[valuesById[146] = "MONACO"] = 146;
    values[valuesById[147] = "MONGOLIA"] = 147;
    values[valuesById[148] = "MONTENEGRO"] = 148;
    values[valuesById[149] = "MONTSERRAT"] = 149;
    values[valuesById[150] = "MOROCCO"] = 150;
    values[valuesById[151] = "MOZAMBIQUE"] = 151;
    values[valuesById[152] = "MYANMAR"] = 152;
    values[valuesById[153] = "NAMIBIA"] = 153;
    values[valuesById[154] = "NAURU"] = 154;
    values[valuesById[155] = "NEPAL"] = 155;
    values[valuesById[156] = "NETHERLANDS"] = 156;
    values[valuesById[157] = "NEW_CALEDONIA"] = 157;
    values[valuesById[158] = "NEW_ZEALAND"] = 158;
    values[valuesById[159] = "NICARAGUA"] = 159;
    values[valuesById[160] = "NIGER"] = 160;
    values[valuesById[161] = "NIGERIA"] = 161;
    values[valuesById[162] = "NIUE"] = 162;
    values[valuesById[163] = "NORFOLK_ISLAND"] = 163;
    values[valuesById[164] = "NORTHERN_MARIANA_ISLANDS"] = 164;
    values[valuesById[165] = "NORWAY"] = 165;
    values[valuesById[166] = "OMAN"] = 166;
    values[valuesById[167] = "PAKISTAN"] = 167;
    values[valuesById[168] = "PALAU"] = 168;
    values[valuesById[169] = "PANAMA"] = 169;
    values[valuesById[170] = "PAPUA_NEW_GUINEA"] = 170;
    values[valuesById[171] = "PARAGUAY"] = 171;
    values[valuesById[172] = "PERU"] = 172;
    values[valuesById[173] = "PHILIPPINES"] = 173;
    values[valuesById[174] = "PITCAIRN"] = 174;
    values[valuesById[175] = "POLAND"] = 175;
    values[valuesById[176] = "PORTUGAL"] = 176;
    values[valuesById[177] = "PUERTO_RICO"] = 177;
    values[valuesById[178] = "QATAR"] = 178;
    values[valuesById[179] = "REUNION"] = 179;
    values[valuesById[180] = "ROMANIA"] = 180;
    values[valuesById[181] = "RUSSIA"] = 181;
    values[valuesById[182] = "RWANDA"] = 182;
    values[valuesById[183] = "SAINT_BARTHELEMY"] = 183;
    values[valuesById[184] = "SAINT_HELENA"] = 184;
    values[valuesById[185] = "SAINT_KITTS"] = 185;
    values[valuesById[186] = "SAINT_LUCIA"] = 186;
    values[valuesById[187] = "SAINT_MARTIN"] = 187;
    values[valuesById[188] = "SAINT_PIERRE"] = 188;
    values[valuesById[189] = "SAINT_VINCENT"] = 189;
    values[valuesById[190] = "SAMOA"] = 190;
    values[valuesById[191] = "SAN_MARINO"] = 191;
    values[valuesById[192] = "SAO_TOME"] = 192;
    values[valuesById[193] = "SAUDI_ARABIA"] = 193;
    values[valuesById[194] = "SENEGAL"] = 194;
    values[valuesById[195] = "SERBIA"] = 195;
    values[valuesById[196] = "SEYCHELLES"] = 196;
    values[valuesById[197] = "SIERRA_LEONE"] = 197;
    values[valuesById[198] = "SINGAPORE"] = 198;
    values[valuesById[199] = "SINT_MAARTEN"] = 199;
    values[valuesById[200] = "SUCRE"] = 200;
    values[valuesById[201] = "SLOVAKIA"] = 201;
    values[valuesById[202] = "SLOVENIA"] = 202;
    values[valuesById[203] = "SOLOMON_ISLANDS"] = 203;
    values[valuesById[204] = "SOMALIA"] = 204;
    values[valuesById[205] = "SOUTH_AFRICA"] = 205;
    values[valuesById[206] = "SOUTH_SUDAN"] = 206;
    values[valuesById[207] = "SPAIN"] = 207;
    values[valuesById[208] = "SRI_LANKA"] = 208;
    values[valuesById[209] = "SUDAN"] = 209;
    values[valuesById[210] = "SURINAME"] = 210;
    values[valuesById[211] = "SVALBARD"] = 211;
    values[valuesById[212] = "SWAZILAND"] = 212;
    values[valuesById[213] = "SWEDEN"] = 213;
    values[valuesById[214] = "SWITZERLAND"] = 214;
    values[valuesById[215] = "SYRIAN_ARAB_REPUBLIC"] = 215;
    values[valuesById[216] = "TAIWAN"] = 216;
    values[valuesById[217] = "TAJIKISTAN"] = 217;
    values[valuesById[218] = "TANZANIA"] = 218;
    values[valuesById[219] = "THAILAND"] = 219;
    values[valuesById[220] = "TIMOR_LESTE"] = 220;
    values[valuesById[221] = "TOGO"] = 221;
    values[valuesById[222] = "TOKELAU"] = 222;
    values[valuesById[223] = "TONGA"] = 223;
    values[valuesById[224] = "TRINIDAD"] = 224;
    values[valuesById[225] = "TUNISIA"] = 225;
    values[valuesById[226] = "TURKEY"] = 226;
    values[valuesById[227] = "TURKMENISTAN"] = 227;
    values[valuesById[228] = "TURKS_AND_CAICOS_ISLANDS"] = 228;
    values[valuesById[229] = "TUVALU"] = 229;
    values[valuesById[230] = "UGANDA"] = 230;
    values[valuesById[231] = "UKRAINE"] = 231;
    values[valuesById[232] = "UNITED_ARAB_EMIRATES"] = 232;
    values[valuesById[233] = "UNITED_KINGDOM"] = 233;
    values[valuesById[234] = "UNITED_STATES"] = 234;
    values[valuesById[235] = "URUGUAY"] = 235;
    values[valuesById[236] = "UZBEKISTAN"] = 236;
    values[valuesById[237] = "VANUATU"] = 237;
    values[valuesById[238] = "VENEZUELA"] = 238;
    values[valuesById[239] = "VIETNAM"] = 239;
    values[valuesById[240] = "VIRGIN_ISLANDS_BRITISH"] = 240;
    values[valuesById[241] = "VIRGIN_ISLANDS_US"] = 241;
    values[valuesById[242] = "WALLIS_AND_FUTUNA"] = 242;
    values[valuesById[243] = "WESTERN_SAHARA"] = 243;
    values[valuesById[244] = "YEMEN"] = 244;
    values[valuesById[245] = "ZAMBIA"] = 245;
    values[valuesById[246] = "ZIMBABWE"] = 246;
    values[valuesById[500] = "ALL"] = 500;
    values[valuesById[501] = "AFRICA"] = 501;
    values[valuesById[502] = "ASIA"] = 502;
    values[valuesById[503] = "CENTRAL_AMERICA"] = 503;
    values[valuesById[504] = "EUROPE"] = 504;
    values[valuesById[505] = "MIDDLE_EAST"] = 505;
    values[valuesById[506] = "NORTH_AMERICA"] = 506;
    values[valuesById[507] = "SOUTH_AMERICA"] = 507;
    values[valuesById[508] = "OCEANIA"] = 508;
    return values;
})();

$root.Image = (function() {

    /**
     * Properties of an Image.
     * @exports IImage
     * @interface IImage
     * @property {string|null} [tiny] Image tiny
     * @property {string|null} [small] Image resource at smallest size, given by CIDv1 hash
     * @property {string|null} [medium] The CIDv1 hash of the image resource with double the dimensions of tiny version.
     * @property {string|null} [large] Double the size of small image
     */

    /**
     * Constructs a new Image.
     * @exports Image
     * @classdesc Represents an Image.
     * @implements IImage
     * @constructor
     * @param {IImage=} [properties] Properties to set
     */
    function Image(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Image tiny.
     * @member {string} tiny
     * @memberof Image
     * @instance
     */
    Image.prototype.tiny = "";

    /**
     * Image resource at smallest size, given by CIDv1 hash
     * @member {string} small
     * @memberof Image
     * @instance
     */
    Image.prototype.small = "";

    /**
     * The CIDv1 hash of the image resource with double the dimensions of tiny version.
     * @member {string} medium
     * @memberof Image
     * @instance
     */
    Image.prototype.medium = "";

    /**
     * Double the size of small image
     * @member {string} large
     * @memberof Image
     * @instance
     */
    Image.prototype.large = "";

    /**
     * Creates a new Image instance using the specified properties.
     * @function create
     * @memberof Image
     * @static
     * @param {IImage=} [properties] Properties to set
     * @returns {Image} Image instance
     */
    Image.create = function create(properties) {
        return new Image(properties);
    };

    /**
     * Encodes the specified Image message. Does not implicitly {@link Image.verify|verify} messages.
     * @function encode
     * @memberof Image
     * @static
     * @param {IImage} message Image message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Image.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.tiny != null && message.hasOwnProperty("tiny"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.tiny);
        if (message.small != null && message.hasOwnProperty("small"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.small);
        if (message.medium != null && message.hasOwnProperty("medium"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.medium);
        if (message.large != null && message.hasOwnProperty("large"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.large);
        return writer;
    };

    /**
     * Encodes the specified Image message, length delimited. Does not implicitly {@link Image.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Image
     * @static
     * @param {IImage} message Image message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Image.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Image message from the specified reader or buffer.
     * @function decode
     * @memberof Image
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Image} Image
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Image.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Image();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.tiny = reader.string();
                break;
            case 2:
                message.small = reader.string();
                break;
            case 3:
                message.medium = reader.string();
                break;
            case 4:
                message.large = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Image message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Image
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Image} Image
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Image.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Image message.
     * @function verify
     * @memberof Image
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Image.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.tiny != null && message.hasOwnProperty("tiny"))
            if (!$util.isString(message.tiny))
                return "tiny: string expected";
        if (message.small != null && message.hasOwnProperty("small"))
            if (!$util.isString(message.small))
                return "small: string expected";
        if (message.medium != null && message.hasOwnProperty("medium"))
            if (!$util.isString(message.medium))
                return "medium: string expected";
        if (message.large != null && message.hasOwnProperty("large"))
            if (!$util.isString(message.large))
                return "large: string expected";
        return null;
    };

    /**
     * Creates an Image message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Image
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Image} Image
     */
    Image.fromObject = function fromObject(object) {
        if (object instanceof $root.Image)
            return object;
        var message = new $root.Image();
        if (object.tiny != null)
            message.tiny = String(object.tiny);
        if (object.small != null)
            message.small = String(object.small);
        if (object.medium != null)
            message.medium = String(object.medium);
        if (object.large != null)
            message.large = String(object.large);
        return message;
    };

    /**
     * Creates a plain object from an Image message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Image
     * @static
     * @param {Image} message Image
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Image.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.tiny = "";
            object.small = "";
            object.medium = "";
            object.large = "";
        }
        if (message.tiny != null && message.hasOwnProperty("tiny"))
            object.tiny = message.tiny;
        if (message.small != null && message.hasOwnProperty("small"))
            object.small = message.small;
        if (message.medium != null && message.hasOwnProperty("medium"))
            object.medium = message.medium;
        if (message.large != null && message.hasOwnProperty("large"))
            object.large = message.large;
        return object;
    };

    /**
     * Converts this Image to JSON.
     * @function toJSON
     * @memberof Image
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Image.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Image;
})();

$root.Message = (function() {

    /**
     * Properties of a Message.
     * @exports IMessage
     * @interface IMessage
     * @property {Message.MessageType|null} [messageType] Message messageType
     * @property {google.protobuf.IAny|null} [payload] Message payload
     * @property {number|null} [requestId] Message requestId
     * @property {boolean|null} [isResponse] Message isResponse
     */

    /**
     * Constructs a new Message.
     * @exports Message
     * @classdesc Represents a Message.
     * @implements IMessage
     * @constructor
     * @param {IMessage=} [properties] Properties to set
     */
    function Message(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Message messageType.
     * @member {Message.MessageType} messageType
     * @memberof Message
     * @instance
     */
    Message.prototype.messageType = 0;

    /**
     * Message payload.
     * @member {google.protobuf.IAny|null|undefined} payload
     * @memberof Message
     * @instance
     */
    Message.prototype.payload = null;

    /**
     * Message requestId.
     * @member {number} requestId
     * @memberof Message
     * @instance
     */
    Message.prototype.requestId = 0;

    /**
     * Message isResponse.
     * @member {boolean} isResponse
     * @memberof Message
     * @instance
     */
    Message.prototype.isResponse = false;

    /**
     * Creates a new Message instance using the specified properties.
     * @function create
     * @memberof Message
     * @static
     * @param {IMessage=} [properties] Properties to set
     * @returns {Message} Message instance
     */
    Message.create = function create(properties) {
        return new Message(properties);
    };

    /**
     * Encodes the specified Message message. Does not implicitly {@link Message.verify|verify} messages.
     * @function encode
     * @memberof Message
     * @static
     * @param {IMessage} message Message message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Message.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.messageType != null && message.hasOwnProperty("messageType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.messageType);
        if (message.payload != null && message.hasOwnProperty("payload"))
            $root.google.protobuf.Any.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.requestId != null && message.hasOwnProperty("requestId"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.requestId);
        if (message.isResponse != null && message.hasOwnProperty("isResponse"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isResponse);
        return writer;
    };

    /**
     * Encodes the specified Message message, length delimited. Does not implicitly {@link Message.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Message
     * @static
     * @param {IMessage} message Message message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Message.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Message message from the specified reader or buffer.
     * @function decode
     * @memberof Message
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Message} Message
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Message.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.messageType = reader.int32();
                break;
            case 2:
                message.payload = $root.google.protobuf.Any.decode(reader, reader.uint32());
                break;
            case 3:
                message.requestId = reader.int32();
                break;
            case 4:
                message.isResponse = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Message message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Message
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Message} Message
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Message.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Message message.
     * @function verify
     * @memberof Message
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Message.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.messageType != null && message.hasOwnProperty("messageType"))
            switch (message.messageType) {
            default:
                return "messageType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 500:
                break;
            }
        if (message.payload != null && message.hasOwnProperty("payload")) {
            var error = $root.google.protobuf.Any.verify(message.payload);
            if (error)
                return "payload." + error;
        }
        if (message.requestId != null && message.hasOwnProperty("requestId"))
            if (!$util.isInteger(message.requestId))
                return "requestId: integer expected";
        if (message.isResponse != null && message.hasOwnProperty("isResponse"))
            if (typeof message.isResponse !== "boolean")
                return "isResponse: boolean expected";
        return null;
    };

    /**
     * Creates a Message message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Message
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Message} Message
     */
    Message.fromObject = function fromObject(object) {
        if (object instanceof $root.Message)
            return object;
        var message = new $root.Message();
        switch (object.messageType) {
        case "PING":
        case 0:
            message.messageType = 0;
            break;
        case "CHAT":
        case 1:
            message.messageType = 1;
            break;
        case "FOLLOW":
        case 2:
            message.messageType = 2;
            break;
        case "UNFOLLOW":
        case 3:
            message.messageType = 3;
            break;
        case "ORDER":
        case 4:
            message.messageType = 4;
            break;
        case "ORDER_REJECT":
        case 5:
            message.messageType = 5;
            break;
        case "ORDER_CANCEL":
        case 6:
            message.messageType = 6;
            break;
        case "ORDER_CONFIRMATION":
        case 7:
            message.messageType = 7;
            break;
        case "ORDER_FULFILLMENT":
        case 8:
            message.messageType = 8;
            break;
        case "ORDER_COMPLETION":
        case 9:
            message.messageType = 9;
            break;
        case "DISPUTE_OPEN":
        case 10:
            message.messageType = 10;
            break;
        case "DISPUTE_UPDATE":
        case 11:
            message.messageType = 11;
            break;
        case "DISPUTE_CLOSE":
        case 12:
            message.messageType = 12;
            break;
        case "REFUND":
        case 13:
            message.messageType = 13;
            break;
        case "OFFLINE_ACK":
        case 14:
            message.messageType = 14;
            break;
        case "OFFLINE_RELAY":
        case 15:
            message.messageType = 15;
            break;
        case "MODERATOR_ADD":
        case 16:
            message.messageType = 16;
            break;
        case "MODERATOR_REMOVE":
        case 17:
            message.messageType = 17;
            break;
        case "STORE":
        case 18:
            message.messageType = 18;
            break;
        case "BLOCK":
        case 19:
            message.messageType = 19;
            break;
        case "ERROR":
        case 500:
            message.messageType = 500;
            break;
        }
        if (object.payload != null) {
            if (typeof object.payload !== "object")
                throw TypeError(".Message.payload: object expected");
            message.payload = $root.google.protobuf.Any.fromObject(object.payload);
        }
        if (object.requestId != null)
            message.requestId = object.requestId | 0;
        if (object.isResponse != null)
            message.isResponse = Boolean(object.isResponse);
        return message;
    };

    /**
     * Creates a plain object from a Message message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Message
     * @static
     * @param {Message} message Message
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Message.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.messageType = options.enums === String ? "PING" : 0;
            object.payload = null;
            object.requestId = 0;
            object.isResponse = false;
        }
        if (message.messageType != null && message.hasOwnProperty("messageType"))
            object.messageType = options.enums === String ? $root.Message.MessageType[message.messageType] : message.messageType;
        if (message.payload != null && message.hasOwnProperty("payload"))
            object.payload = $root.google.protobuf.Any.toObject(message.payload, options);
        if (message.requestId != null && message.hasOwnProperty("requestId"))
            object.requestId = message.requestId;
        if (message.isResponse != null && message.hasOwnProperty("isResponse"))
            object.isResponse = message.isResponse;
        return object;
    };

    /**
     * Converts this Message to JSON.
     * @function toJSON
     * @memberof Message
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Message.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * MessageType enum.
     * @name Message.MessageType
     * @enum {string}
     * @property {number} PING=0 PING value
     * @property {number} CHAT=1 CHAT value
     * @property {number} FOLLOW=2 FOLLOW value
     * @property {number} UNFOLLOW=3 UNFOLLOW value
     * @property {number} ORDER=4 ORDER value
     * @property {number} ORDER_REJECT=5 ORDER_REJECT value
     * @property {number} ORDER_CANCEL=6 ORDER_CANCEL value
     * @property {number} ORDER_CONFIRMATION=7 ORDER_CONFIRMATION value
     * @property {number} ORDER_FULFILLMENT=8 ORDER_FULFILLMENT value
     * @property {number} ORDER_COMPLETION=9 ORDER_COMPLETION value
     * @property {number} DISPUTE_OPEN=10 DISPUTE_OPEN value
     * @property {number} DISPUTE_UPDATE=11 DISPUTE_UPDATE value
     * @property {number} DISPUTE_CLOSE=12 DISPUTE_CLOSE value
     * @property {number} REFUND=13 REFUND value
     * @property {number} OFFLINE_ACK=14 OFFLINE_ACK value
     * @property {number} OFFLINE_RELAY=15 OFFLINE_RELAY value
     * @property {number} MODERATOR_ADD=16 MODERATOR_ADD value
     * @property {number} MODERATOR_REMOVE=17 MODERATOR_REMOVE value
     * @property {number} STORE=18 STORE value
     * @property {number} BLOCK=19 BLOCK value
     * @property {number} ERROR=500 ERROR value
     */
    Message.MessageType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PING"] = 0;
        values[valuesById[1] = "CHAT"] = 1;
        values[valuesById[2] = "FOLLOW"] = 2;
        values[valuesById[3] = "UNFOLLOW"] = 3;
        values[valuesById[4] = "ORDER"] = 4;
        values[valuesById[5] = "ORDER_REJECT"] = 5;
        values[valuesById[6] = "ORDER_CANCEL"] = 6;
        values[valuesById[7] = "ORDER_CONFIRMATION"] = 7;
        values[valuesById[8] = "ORDER_FULFILLMENT"] = 8;
        values[valuesById[9] = "ORDER_COMPLETION"] = 9;
        values[valuesById[10] = "DISPUTE_OPEN"] = 10;
        values[valuesById[11] = "DISPUTE_UPDATE"] = 11;
        values[valuesById[12] = "DISPUTE_CLOSE"] = 12;
        values[valuesById[13] = "REFUND"] = 13;
        values[valuesById[14] = "OFFLINE_ACK"] = 14;
        values[valuesById[15] = "OFFLINE_RELAY"] = 15;
        values[valuesById[16] = "MODERATOR_ADD"] = 16;
        values[valuesById[17] = "MODERATOR_REMOVE"] = 17;
        values[valuesById[18] = "STORE"] = 18;
        values[valuesById[19] = "BLOCK"] = 19;
        values[valuesById[500] = "ERROR"] = 500;
        return values;
    })();

    return Message;
})();

$root.Envelope = (function() {

    /**
     * Properties of an Envelope.
     * @exports IEnvelope
     * @interface IEnvelope
     * @property {IMessage|null} [message] Envelope message
     * @property {Uint8Array|null} [pubkey] Envelope pubkey
     * @property {Uint8Array|null} [signature] Envelope signature
     */

    /**
     * Constructs a new Envelope.
     * @exports Envelope
     * @classdesc Represents an Envelope.
     * @implements IEnvelope
     * @constructor
     * @param {IEnvelope=} [properties] Properties to set
     */
    function Envelope(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Envelope message.
     * @member {IMessage|null|undefined} message
     * @memberof Envelope
     * @instance
     */
    Envelope.prototype.message = null;

    /**
     * Envelope pubkey.
     * @member {Uint8Array} pubkey
     * @memberof Envelope
     * @instance
     */
    Envelope.prototype.pubkey = $util.newBuffer([]);

    /**
     * Envelope signature.
     * @member {Uint8Array} signature
     * @memberof Envelope
     * @instance
     */
    Envelope.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new Envelope instance using the specified properties.
     * @function create
     * @memberof Envelope
     * @static
     * @param {IEnvelope=} [properties] Properties to set
     * @returns {Envelope} Envelope instance
     */
    Envelope.create = function create(properties) {
        return new Envelope(properties);
    };

    /**
     * Encodes the specified Envelope message. Does not implicitly {@link Envelope.verify|verify} messages.
     * @function encode
     * @memberof Envelope
     * @static
     * @param {IEnvelope} message Envelope message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Envelope.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.message != null && message.hasOwnProperty("message"))
            $root.Message.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.pubkey != null && message.hasOwnProperty("pubkey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.pubkey);
        if (message.signature != null && message.hasOwnProperty("signature"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
        return writer;
    };

    /**
     * Encodes the specified Envelope message, length delimited. Does not implicitly {@link Envelope.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Envelope
     * @static
     * @param {IEnvelope} message Envelope message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Envelope.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Envelope message from the specified reader or buffer.
     * @function decode
     * @memberof Envelope
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Envelope} Envelope
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Envelope.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Envelope();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.message = $root.Message.decode(reader, reader.uint32());
                break;
            case 2:
                message.pubkey = reader.bytes();
                break;
            case 3:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Envelope message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Envelope
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Envelope} Envelope
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Envelope.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Envelope message.
     * @function verify
     * @memberof Envelope
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Envelope.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.message != null && message.hasOwnProperty("message")) {
            var error = $root.Message.verify(message.message);
            if (error)
                return "message." + error;
        }
        if (message.pubkey != null && message.hasOwnProperty("pubkey"))
            if (!(message.pubkey && typeof message.pubkey.length === "number" || $util.isString(message.pubkey)))
                return "pubkey: buffer expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Envelope
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Envelope} Envelope
     */
    Envelope.fromObject = function fromObject(object) {
        if (object instanceof $root.Envelope)
            return object;
        var message = new $root.Envelope();
        if (object.message != null) {
            if (typeof object.message !== "object")
                throw TypeError(".Envelope.message: object expected");
            message.message = $root.Message.fromObject(object.message);
        }
        if (object.pubkey != null)
            if (typeof object.pubkey === "string")
                $util.base64.decode(object.pubkey, message.pubkey = $util.newBuffer($util.base64.length(object.pubkey)), 0);
            else if (object.pubkey.length)
                message.pubkey = object.pubkey;
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from an Envelope message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Envelope
     * @static
     * @param {Envelope} message Envelope
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Envelope.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.message = null;
            object.pubkey = options.bytes === String ? "" : [];
            object.signature = options.bytes === String ? "" : [];
        }
        if (message.message != null && message.hasOwnProperty("message"))
            object.message = $root.Message.toObject(message.message, options);
        if (message.pubkey != null && message.hasOwnProperty("pubkey"))
            object.pubkey = options.bytes === String ? $util.base64.encode(message.pubkey, 0, message.pubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubkey) : message.pubkey;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        return object;
    };

    /**
     * Converts this Envelope to JSON.
     * @function toJSON
     * @memberof Envelope
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Envelope.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Envelope;
})();

$root.Chat = (function() {

    /**
     * Properties of a Chat.
     * @exports IChat
     * @interface IChat
     * @property {string|null} [messageId] Chat messageId
     * @property {string|null} [subject] Chat subject
     * @property {string|null} [message] Chat message
     * @property {google.protobuf.ITimestamp|null} [timestamp] Chat timestamp
     * @property {Chat.Flag|null} [flag] Chat flag
     */

    /**
     * Constructs a new Chat.
     * @exports Chat
     * @classdesc Represents a Chat.
     * @implements IChat
     * @constructor
     * @param {IChat=} [properties] Properties to set
     */
    function Chat(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Chat messageId.
     * @member {string} messageId
     * @memberof Chat
     * @instance
     */
    Chat.prototype.messageId = "";

    /**
     * Chat subject.
     * @member {string} subject
     * @memberof Chat
     * @instance
     */
    Chat.prototype.subject = "";

    /**
     * Chat message.
     * @member {string} message
     * @memberof Chat
     * @instance
     */
    Chat.prototype.message = "";

    /**
     * Chat timestamp.
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof Chat
     * @instance
     */
    Chat.prototype.timestamp = null;

    /**
     * Chat flag.
     * @member {Chat.Flag} flag
     * @memberof Chat
     * @instance
     */
    Chat.prototype.flag = 0;

    /**
     * Creates a new Chat instance using the specified properties.
     * @function create
     * @memberof Chat
     * @static
     * @param {IChat=} [properties] Properties to set
     * @returns {Chat} Chat instance
     */
    Chat.create = function create(properties) {
        return new Chat(properties);
    };

    /**
     * Encodes the specified Chat message. Does not implicitly {@link Chat.verify|verify} messages.
     * @function encode
     * @memberof Chat
     * @static
     * @param {IChat} message Chat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Chat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.messageId != null && message.hasOwnProperty("messageId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
        if (message.subject != null && message.hasOwnProperty("subject"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.subject);
        if (message.message != null && message.hasOwnProperty("message"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.flag != null && message.hasOwnProperty("flag"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.flag);
        return writer;
    };

    /**
     * Encodes the specified Chat message, length delimited. Does not implicitly {@link Chat.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Chat
     * @static
     * @param {IChat} message Chat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Chat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Chat message from the specified reader or buffer.
     * @function decode
     * @memberof Chat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Chat} Chat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Chat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Chat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.messageId = reader.string();
                break;
            case 2:
                message.subject = reader.string();
                break;
            case 3:
                message.message = reader.string();
                break;
            case 4:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 5:
                message.flag = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Chat message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Chat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Chat} Chat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Chat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Chat message.
     * @function verify
     * @memberof Chat
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Chat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.messageId != null && message.hasOwnProperty("messageId"))
            if (!$util.isString(message.messageId))
                return "messageId: string expected";
        if (message.subject != null && message.hasOwnProperty("subject"))
            if (!$util.isString(message.subject))
                return "subject: string expected";
        if (message.message != null && message.hasOwnProperty("message"))
            if (!$util.isString(message.message))
                return "message: string expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        if (message.flag != null && message.hasOwnProperty("flag"))
            switch (message.flag) {
            default:
                return "flag: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a Chat message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Chat
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Chat} Chat
     */
    Chat.fromObject = function fromObject(object) {
        if (object instanceof $root.Chat)
            return object;
        var message = new $root.Chat();
        if (object.messageId != null)
            message.messageId = String(object.messageId);
        if (object.subject != null)
            message.subject = String(object.subject);
        if (object.message != null)
            message.message = String(object.message);
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".Chat.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        switch (object.flag) {
        case "MESSAGE":
        case 0:
            message.flag = 0;
            break;
        case "TYPING":
        case 1:
            message.flag = 1;
            break;
        case "READ":
        case 2:
            message.flag = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a Chat message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Chat
     * @static
     * @param {Chat} message Chat
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Chat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.messageId = "";
            object.subject = "";
            object.message = "";
            object.timestamp = null;
            object.flag = options.enums === String ? "MESSAGE" : 0;
        }
        if (message.messageId != null && message.hasOwnProperty("messageId"))
            object.messageId = message.messageId;
        if (message.subject != null && message.hasOwnProperty("subject"))
            object.subject = message.subject;
        if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        if (message.flag != null && message.hasOwnProperty("flag"))
            object.flag = options.enums === String ? $root.Chat.Flag[message.flag] : message.flag;
        return object;
    };

    /**
     * Converts this Chat to JSON.
     * @function toJSON
     * @memberof Chat
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Chat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Flag enum.
     * @name Chat.Flag
     * @enum {string}
     * @property {number} MESSAGE=0 MESSAGE value
     * @property {number} TYPING=1 TYPING value
     * @property {number} READ=2 READ value
     */
    Chat.Flag = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MESSAGE"] = 0;
        values[valuesById[1] = "TYPING"] = 1;
        values[valuesById[2] = "READ"] = 2;
        return values;
    })();

    return Chat;
})();

$root.SignedData = (function() {

    /**
     * Properties of a SignedData.
     * @exports ISignedData
     * @interface ISignedData
     * @property {Uint8Array|null} [senderPubkey] SignedData senderPubkey
     * @property {Uint8Array|null} [serializedData] SignedData serializedData
     * @property {Uint8Array|null} [signature] SignedData signature
     */

    /**
     * Constructs a new SignedData.
     * @exports SignedData
     * @classdesc Represents a SignedData.
     * @implements ISignedData
     * @constructor
     * @param {ISignedData=} [properties] Properties to set
     */
    function SignedData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SignedData senderPubkey.
     * @member {Uint8Array} senderPubkey
     * @memberof SignedData
     * @instance
     */
    SignedData.prototype.senderPubkey = $util.newBuffer([]);

    /**
     * SignedData serializedData.
     * @member {Uint8Array} serializedData
     * @memberof SignedData
     * @instance
     */
    SignedData.prototype.serializedData = $util.newBuffer([]);

    /**
     * SignedData signature.
     * @member {Uint8Array} signature
     * @memberof SignedData
     * @instance
     */
    SignedData.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new SignedData instance using the specified properties.
     * @function create
     * @memberof SignedData
     * @static
     * @param {ISignedData=} [properties] Properties to set
     * @returns {SignedData} SignedData instance
     */
    SignedData.create = function create(properties) {
        return new SignedData(properties);
    };

    /**
     * Encodes the specified SignedData message. Does not implicitly {@link SignedData.verify|verify} messages.
     * @function encode
     * @memberof SignedData
     * @static
     * @param {ISignedData} message SignedData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignedData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.senderPubkey);
        if (message.serializedData != null && message.hasOwnProperty("serializedData"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.serializedData);
        if (message.signature != null && message.hasOwnProperty("signature"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
        return writer;
    };

    /**
     * Encodes the specified SignedData message, length delimited. Does not implicitly {@link SignedData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SignedData
     * @static
     * @param {ISignedData} message SignedData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignedData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SignedData message from the specified reader or buffer.
     * @function decode
     * @memberof SignedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SignedData} SignedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignedData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SignedData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.senderPubkey = reader.bytes();
                break;
            case 2:
                message.serializedData = reader.bytes();
                break;
            case 3:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SignedData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SignedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SignedData} SignedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignedData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SignedData message.
     * @function verify
     * @memberof SignedData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SignedData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey"))
            if (!(message.senderPubkey && typeof message.senderPubkey.length === "number" || $util.isString(message.senderPubkey)))
                return "senderPubkey: buffer expected";
        if (message.serializedData != null && message.hasOwnProperty("serializedData"))
            if (!(message.serializedData && typeof message.serializedData.length === "number" || $util.isString(message.serializedData)))
                return "serializedData: buffer expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates a SignedData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SignedData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SignedData} SignedData
     */
    SignedData.fromObject = function fromObject(object) {
        if (object instanceof $root.SignedData)
            return object;
        var message = new $root.SignedData();
        if (object.senderPubkey != null)
            if (typeof object.senderPubkey === "string")
                $util.base64.decode(object.senderPubkey, message.senderPubkey = $util.newBuffer($util.base64.length(object.senderPubkey)), 0);
            else if (object.senderPubkey.length)
                message.senderPubkey = object.senderPubkey;
        if (object.serializedData != null)
            if (typeof object.serializedData === "string")
                $util.base64.decode(object.serializedData, message.serializedData = $util.newBuffer($util.base64.length(object.serializedData)), 0);
            else if (object.serializedData.length)
                message.serializedData = object.serializedData;
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from a SignedData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SignedData
     * @static
     * @param {SignedData} message SignedData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SignedData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.senderPubkey = options.bytes === String ? "" : [];
            object.serializedData = options.bytes === String ? "" : [];
            object.signature = options.bytes === String ? "" : [];
        }
        if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey"))
            object.senderPubkey = options.bytes === String ? $util.base64.encode(message.senderPubkey, 0, message.senderPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPubkey) : message.senderPubkey;
        if (message.serializedData != null && message.hasOwnProperty("serializedData"))
            object.serializedData = options.bytes === String ? $util.base64.encode(message.serializedData, 0, message.serializedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.serializedData) : message.serializedData;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        return object;
    };

    /**
     * Converts this SignedData to JSON.
     * @function toJSON
     * @memberof SignedData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SignedData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    SignedData.Command = (function() {

        /**
         * Properties of a Command.
         * @memberof SignedData
         * @interface ICommand
         * @property {string|null} [peerID] Command peerID
         * @property {Message.MessageType|null} [type] Command type
         * @property {google.protobuf.ITimestamp|null} [timestamp] Command timestamp
         */

        /**
         * Constructs a new Command.
         * @memberof SignedData
         * @classdesc Represents a Command.
         * @implements ICommand
         * @constructor
         * @param {SignedData.ICommand=} [properties] Properties to set
         */
        function Command(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Command peerID.
         * @member {string} peerID
         * @memberof SignedData.Command
         * @instance
         */
        Command.prototype.peerID = "";

        /**
         * Command type.
         * @member {Message.MessageType} type
         * @memberof SignedData.Command
         * @instance
         */
        Command.prototype.type = 0;

        /**
         * Command timestamp.
         * @member {google.protobuf.ITimestamp|null|undefined} timestamp
         * @memberof SignedData.Command
         * @instance
         */
        Command.prototype.timestamp = null;

        /**
         * Creates a new Command instance using the specified properties.
         * @function create
         * @memberof SignedData.Command
         * @static
         * @param {SignedData.ICommand=} [properties] Properties to set
         * @returns {SignedData.Command} Command instance
         */
        Command.create = function create(properties) {
            return new Command(properties);
        };

        /**
         * Encodes the specified Command message. Does not implicitly {@link SignedData.Command.verify|verify} messages.
         * @function encode
         * @memberof SignedData.Command
         * @static
         * @param {SignedData.ICommand} message Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Command.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peerID != null && message.hasOwnProperty("peerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerID);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Command message, length delimited. Does not implicitly {@link SignedData.Command.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SignedData.Command
         * @static
         * @param {SignedData.ICommand} message Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Command.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Command message from the specified reader or buffer.
         * @function decode
         * @memberof SignedData.Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SignedData.Command} Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Command.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SignedData.Command();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.peerID = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Command message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SignedData.Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SignedData.Command} Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Command.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Command message.
         * @function verify
         * @memberof SignedData.Command
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Command.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peerID != null && message.hasOwnProperty("peerID"))
                if (!$util.isString(message.peerID))
                    return "peerID: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 500:
                    break;
                }
            if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                if (error)
                    return "timestamp." + error;
            }
            return null;
        };

        /**
         * Creates a Command message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SignedData.Command
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SignedData.Command} Command
         */
        Command.fromObject = function fromObject(object) {
            if (object instanceof $root.SignedData.Command)
                return object;
            var message = new $root.SignedData.Command();
            if (object.peerID != null)
                message.peerID = String(object.peerID);
            switch (object.type) {
            case "PING":
            case 0:
                message.type = 0;
                break;
            case "CHAT":
            case 1:
                message.type = 1;
                break;
            case "FOLLOW":
            case 2:
                message.type = 2;
                break;
            case "UNFOLLOW":
            case 3:
                message.type = 3;
                break;
            case "ORDER":
            case 4:
                message.type = 4;
                break;
            case "ORDER_REJECT":
            case 5:
                message.type = 5;
                break;
            case "ORDER_CANCEL":
            case 6:
                message.type = 6;
                break;
            case "ORDER_CONFIRMATION":
            case 7:
                message.type = 7;
                break;
            case "ORDER_FULFILLMENT":
            case 8:
                message.type = 8;
                break;
            case "ORDER_COMPLETION":
            case 9:
                message.type = 9;
                break;
            case "DISPUTE_OPEN":
            case 10:
                message.type = 10;
                break;
            case "DISPUTE_UPDATE":
            case 11:
                message.type = 11;
                break;
            case "DISPUTE_CLOSE":
            case 12:
                message.type = 12;
                break;
            case "REFUND":
            case 13:
                message.type = 13;
                break;
            case "OFFLINE_ACK":
            case 14:
                message.type = 14;
                break;
            case "OFFLINE_RELAY":
            case 15:
                message.type = 15;
                break;
            case "MODERATOR_ADD":
            case 16:
                message.type = 16;
                break;
            case "MODERATOR_REMOVE":
            case 17:
                message.type = 17;
                break;
            case "STORE":
            case 18:
                message.type = 18;
                break;
            case "BLOCK":
            case 19:
                message.type = 19;
                break;
            case "ERROR":
            case 500:
                message.type = 500;
                break;
            }
            if (object.timestamp != null) {
                if (typeof object.timestamp !== "object")
                    throw TypeError(".SignedData.Command.timestamp: object expected");
                message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
            }
            return message;
        };

        /**
         * Creates a plain object from a Command message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SignedData.Command
         * @static
         * @param {SignedData.Command} message Command
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Command.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.peerID = "";
                object.type = options.enums === String ? "PING" : 0;
                object.timestamp = null;
            }
            if (message.peerID != null && message.hasOwnProperty("peerID"))
                object.peerID = message.peerID;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.Message.MessageType[message.type] : message.type;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
            return object;
        };

        /**
         * Converts this Command to JSON.
         * @function toJSON
         * @memberof SignedData.Command
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Command.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Command;
    })();

    return SignedData;
})();

$root.CidList = (function() {

    /**
     * Properties of a CidList.
     * @exports ICidList
     * @interface ICidList
     * @property {Array.<string>|null} [cids] CidList cids
     */

    /**
     * Constructs a new CidList.
     * @exports CidList
     * @classdesc Represents a CidList.
     * @implements ICidList
     * @constructor
     * @param {ICidList=} [properties] Properties to set
     */
    function CidList(properties) {
        this.cids = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CidList cids.
     * @member {Array.<string>} cids
     * @memberof CidList
     * @instance
     */
    CidList.prototype.cids = $util.emptyArray;

    /**
     * Creates a new CidList instance using the specified properties.
     * @function create
     * @memberof CidList
     * @static
     * @param {ICidList=} [properties] Properties to set
     * @returns {CidList} CidList instance
     */
    CidList.create = function create(properties) {
        return new CidList(properties);
    };

    /**
     * Encodes the specified CidList message. Does not implicitly {@link CidList.verify|verify} messages.
     * @function encode
     * @memberof CidList
     * @static
     * @param {ICidList} message CidList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CidList.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.cids != null && message.cids.length)
            for (var i = 0; i < message.cids.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cids[i]);
        return writer;
    };

    /**
     * Encodes the specified CidList message, length delimited. Does not implicitly {@link CidList.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CidList
     * @static
     * @param {ICidList} message CidList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CidList.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CidList message from the specified reader or buffer.
     * @function decode
     * @memberof CidList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CidList} CidList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CidList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CidList();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.cids && message.cids.length))
                    message.cids = [];
                message.cids.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CidList message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CidList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CidList} CidList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CidList.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CidList message.
     * @function verify
     * @memberof CidList
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CidList.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.cids != null && message.hasOwnProperty("cids")) {
            if (!Array.isArray(message.cids))
                return "cids: array expected";
            for (var i = 0; i < message.cids.length; ++i)
                if (!$util.isString(message.cids[i]))
                    return "cids: string[] expected";
        }
        return null;
    };

    /**
     * Creates a CidList message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CidList
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CidList} CidList
     */
    CidList.fromObject = function fromObject(object) {
        if (object instanceof $root.CidList)
            return object;
        var message = new $root.CidList();
        if (object.cids) {
            if (!Array.isArray(object.cids))
                throw TypeError(".CidList.cids: array expected");
            message.cids = [];
            for (var i = 0; i < object.cids.length; ++i)
                message.cids[i] = String(object.cids[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a CidList message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CidList
     * @static
     * @param {CidList} message CidList
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CidList.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.cids = [];
        if (message.cids && message.cids.length) {
            object.cids = [];
            for (var j = 0; j < message.cids.length; ++j)
                object.cids[j] = message.cids[j];
        }
        return object;
    };

    /**
     * Converts this CidList to JSON.
     * @function toJSON
     * @memberof CidList
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CidList.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CidList;
})();

$root.Block = (function() {

    /**
     * Properties of a Block.
     * @exports IBlock
     * @interface IBlock
     * @property {Uint8Array|null} [rawData] Block rawData
     * @property {string|null} [cid] Block cid
     */

    /**
     * Constructs a new Block.
     * @exports Block
     * @classdesc Represents a Block.
     * @implements IBlock
     * @constructor
     * @param {IBlock=} [properties] Properties to set
     */
    function Block(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Block rawData.
     * @member {Uint8Array} rawData
     * @memberof Block
     * @instance
     */
    Block.prototype.rawData = $util.newBuffer([]);

    /**
     * Block cid.
     * @member {string} cid
     * @memberof Block
     * @instance
     */
    Block.prototype.cid = "";

    /**
     * Creates a new Block instance using the specified properties.
     * @function create
     * @memberof Block
     * @static
     * @param {IBlock=} [properties] Properties to set
     * @returns {Block} Block instance
     */
    Block.create = function create(properties) {
        return new Block(properties);
    };

    /**
     * Encodes the specified Block message. Does not implicitly {@link Block.verify|verify} messages.
     * @function encode
     * @memberof Block
     * @static
     * @param {IBlock} message Block message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Block.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rawData != null && message.hasOwnProperty("rawData"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.rawData);
        if (message.cid != null && message.hasOwnProperty("cid"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.cid);
        return writer;
    };

    /**
     * Encodes the specified Block message, length delimited. Does not implicitly {@link Block.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Block
     * @static
     * @param {IBlock} message Block message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Block.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Block message from the specified reader or buffer.
     * @function decode
     * @memberof Block
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Block} Block
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Block.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Block();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rawData = reader.bytes();
                break;
            case 2:
                message.cid = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Block message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Block
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Block} Block
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Block.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Block message.
     * @function verify
     * @memberof Block
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Block.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.rawData != null && message.hasOwnProperty("rawData"))
            if (!(message.rawData && typeof message.rawData.length === "number" || $util.isString(message.rawData)))
                return "rawData: buffer expected";
        if (message.cid != null && message.hasOwnProperty("cid"))
            if (!$util.isString(message.cid))
                return "cid: string expected";
        return null;
    };

    /**
     * Creates a Block message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Block
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Block} Block
     */
    Block.fromObject = function fromObject(object) {
        if (object instanceof $root.Block)
            return object;
        var message = new $root.Block();
        if (object.rawData != null)
            if (typeof object.rawData === "string")
                $util.base64.decode(object.rawData, message.rawData = $util.newBuffer($util.base64.length(object.rawData)), 0);
            else if (object.rawData.length)
                message.rawData = object.rawData;
        if (object.cid != null)
            message.cid = String(object.cid);
        return message;
    };

    /**
     * Creates a plain object from a Block message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Block
     * @static
     * @param {Block} message Block
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Block.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.rawData = options.bytes === String ? "" : [];
            object.cid = "";
        }
        if (message.rawData != null && message.hasOwnProperty("rawData"))
            object.rawData = options.bytes === String ? $util.base64.encode(message.rawData, 0, message.rawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawData) : message.rawData;
        if (message.cid != null && message.hasOwnProperty("cid"))
            object.cid = message.cid;
        return object;
    };

    /**
     * Converts this Block to JSON.
     * @function toJSON
     * @memberof Block
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Block.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Block;
})();

$root.Error = (function() {

    /**
     * Properties of an Error.
     * @exports IError
     * @interface IError
     * @property {number|null} [code] Error code
     * @property {string|null} [errorMessage] Error errorMessage
     * @property {string|null} [orderID] Error orderID
     */

    /**
     * Constructs a new Error.
     * @exports Error
     * @classdesc Represents an Error.
     * @implements IError
     * @constructor
     * @param {IError=} [properties] Properties to set
     */
    function Error(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Error code.
     * @member {number} code
     * @memberof Error
     * @instance
     */
    Error.prototype.code = 0;

    /**
     * Error errorMessage.
     * @member {string} errorMessage
     * @memberof Error
     * @instance
     */
    Error.prototype.errorMessage = "";

    /**
     * Error orderID.
     * @member {string} orderID
     * @memberof Error
     * @instance
     */
    Error.prototype.orderID = "";

    /**
     * Creates a new Error instance using the specified properties.
     * @function create
     * @memberof Error
     * @static
     * @param {IError=} [properties] Properties to set
     * @returns {Error} Error instance
     */
    Error.create = function create(properties) {
        return new Error(properties);
    };

    /**
     * Encodes the specified Error message. Does not implicitly {@link Error.verify|verify} messages.
     * @function encode
     * @memberof Error
     * @static
     * @param {IError} message Error message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Error.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.code != null && message.hasOwnProperty("code"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.orderID);
        return writer;
    };

    /**
     * Encodes the specified Error message, length delimited. Does not implicitly {@link Error.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Error
     * @static
     * @param {IError} message Error message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Error.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Error message from the specified reader or buffer.
     * @function decode
     * @memberof Error
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Error} Error
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Error.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Error();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.code = reader.uint32();
                break;
            case 2:
                message.errorMessage = reader.string();
                break;
            case 3:
                message.orderID = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Error message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Error
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Error} Error
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Error.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Error message.
     * @function verify
     * @memberof Error
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Error.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.code != null && message.hasOwnProperty("code"))
            if (!$util.isInteger(message.code))
                return "code: integer expected";
        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
            if (!$util.isString(message.errorMessage))
                return "errorMessage: string expected";
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            if (!$util.isString(message.orderID))
                return "orderID: string expected";
        return null;
    };

    /**
     * Creates an Error message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Error
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Error} Error
     */
    Error.fromObject = function fromObject(object) {
        if (object instanceof $root.Error)
            return object;
        var message = new $root.Error();
        if (object.code != null)
            message.code = object.code >>> 0;
        if (object.errorMessage != null)
            message.errorMessage = String(object.errorMessage);
        if (object.orderID != null)
            message.orderID = String(object.orderID);
        return message;
    };

    /**
     * Creates a plain object from an Error message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Error
     * @static
     * @param {Error} message Error
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Error.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.code = 0;
            object.errorMessage = "";
            object.orderID = "";
        }
        if (message.code != null && message.hasOwnProperty("code"))
            object.code = message.code;
        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
            object.errorMessage = message.errorMessage;
        if (message.orderID != null && message.hasOwnProperty("orderID"))
            object.orderID = message.orderID;
        return object;
    };

    /**
     * Converts this Error to JSON.
     * @function toJSON
     * @memberof Error
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Error.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Error;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Timestamp;
        })();

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    object.value = options.bytes === String ? "" : [];
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

$root.Moderator = (function() {

    /**
     * Properties of a Moderator.
     * @exports IModerator
     * @interface IModerator
     * @property {string|null} [description] Moderator description
     * @property {string|null} [termsAndConditions] Moderator termsAndConditions
     * @property {Array.<string>|null} [languages] Moderator languages
     * @property {Array.<string>|null} [acceptedCurrencies] Moderator acceptedCurrencies
     * @property {Moderator.IFee|null} [fee] Moderator fee
     */

    /**
     * Constructs a new Moderator.
     * @exports Moderator
     * @classdesc Represents a Moderator.
     * @implements IModerator
     * @constructor
     * @param {IModerator=} [properties] Properties to set
     */
    function Moderator(properties) {
        this.languages = [];
        this.acceptedCurrencies = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Moderator description.
     * @member {string} description
     * @memberof Moderator
     * @instance
     */
    Moderator.prototype.description = "";

    /**
     * Moderator termsAndConditions.
     * @member {string} termsAndConditions
     * @memberof Moderator
     * @instance
     */
    Moderator.prototype.termsAndConditions = "";

    /**
     * Moderator languages.
     * @member {Array.<string>} languages
     * @memberof Moderator
     * @instance
     */
    Moderator.prototype.languages = $util.emptyArray;

    /**
     * Moderator acceptedCurrencies.
     * @member {Array.<string>} acceptedCurrencies
     * @memberof Moderator
     * @instance
     */
    Moderator.prototype.acceptedCurrencies = $util.emptyArray;

    /**
     * Moderator fee.
     * @member {Moderator.IFee|null|undefined} fee
     * @memberof Moderator
     * @instance
     */
    Moderator.prototype.fee = null;

    /**
     * Creates a new Moderator instance using the specified properties.
     * @function create
     * @memberof Moderator
     * @static
     * @param {IModerator=} [properties] Properties to set
     * @returns {Moderator} Moderator instance
     */
    Moderator.create = function create(properties) {
        return new Moderator(properties);
    };

    /**
     * Encodes the specified Moderator message. Does not implicitly {@link Moderator.verify|verify} messages.
     * @function encode
     * @memberof Moderator
     * @static
     * @param {IModerator} message Moderator message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Moderator.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.description != null && message.hasOwnProperty("description"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.termsAndConditions);
        if (message.languages != null && message.languages.length)
            for (var i = 0; i < message.languages.length; ++i)
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.languages[i]);
        if (message.acceptedCurrencies != null && message.acceptedCurrencies.length)
            for (var i = 0; i < message.acceptedCurrencies.length; ++i)
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.acceptedCurrencies[i]);
        if (message.fee != null && message.hasOwnProperty("fee"))
            $root.Moderator.Fee.encode(message.fee, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Moderator message, length delimited. Does not implicitly {@link Moderator.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Moderator
     * @static
     * @param {IModerator} message Moderator message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Moderator.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Moderator message from the specified reader or buffer.
     * @function decode
     * @memberof Moderator
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Moderator} Moderator
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Moderator.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Moderator();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.description = reader.string();
                break;
            case 2:
                message.termsAndConditions = reader.string();
                break;
            case 3:
                if (!(message.languages && message.languages.length))
                    message.languages = [];
                message.languages.push(reader.string());
                break;
            case 4:
                if (!(message.acceptedCurrencies && message.acceptedCurrencies.length))
                    message.acceptedCurrencies = [];
                message.acceptedCurrencies.push(reader.string());
                break;
            case 5:
                message.fee = $root.Moderator.Fee.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Moderator message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Moderator
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Moderator} Moderator
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Moderator.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Moderator message.
     * @function verify
     * @memberof Moderator
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Moderator.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
            if (!$util.isString(message.termsAndConditions))
                return "termsAndConditions: string expected";
        if (message.languages != null && message.hasOwnProperty("languages")) {
            if (!Array.isArray(message.languages))
                return "languages: array expected";
            for (var i = 0; i < message.languages.length; ++i)
                if (!$util.isString(message.languages[i]))
                    return "languages: string[] expected";
        }
        if (message.acceptedCurrencies != null && message.hasOwnProperty("acceptedCurrencies")) {
            if (!Array.isArray(message.acceptedCurrencies))
                return "acceptedCurrencies: array expected";
            for (var i = 0; i < message.acceptedCurrencies.length; ++i)
                if (!$util.isString(message.acceptedCurrencies[i]))
                    return "acceptedCurrencies: string[] expected";
        }
        if (message.fee != null && message.hasOwnProperty("fee")) {
            var error = $root.Moderator.Fee.verify(message.fee);
            if (error)
                return "fee." + error;
        }
        return null;
    };

    /**
     * Creates a Moderator message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Moderator
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Moderator} Moderator
     */
    Moderator.fromObject = function fromObject(object) {
        if (object instanceof $root.Moderator)
            return object;
        var message = new $root.Moderator();
        if (object.description != null)
            message.description = String(object.description);
        if (object.termsAndConditions != null)
            message.termsAndConditions = String(object.termsAndConditions);
        if (object.languages) {
            if (!Array.isArray(object.languages))
                throw TypeError(".Moderator.languages: array expected");
            message.languages = [];
            for (var i = 0; i < object.languages.length; ++i)
                message.languages[i] = String(object.languages[i]);
        }
        if (object.acceptedCurrencies) {
            if (!Array.isArray(object.acceptedCurrencies))
                throw TypeError(".Moderator.acceptedCurrencies: array expected");
            message.acceptedCurrencies = [];
            for (var i = 0; i < object.acceptedCurrencies.length; ++i)
                message.acceptedCurrencies[i] = String(object.acceptedCurrencies[i]);
        }
        if (object.fee != null) {
            if (typeof object.fee !== "object")
                throw TypeError(".Moderator.fee: object expected");
            message.fee = $root.Moderator.Fee.fromObject(object.fee);
        }
        return message;
    };

    /**
     * Creates a plain object from a Moderator message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Moderator
     * @static
     * @param {Moderator} message Moderator
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Moderator.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.languages = [];
            object.acceptedCurrencies = [];
        }
        if (options.defaults) {
            object.description = "";
            object.termsAndConditions = "";
            object.fee = null;
        }
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
            object.termsAndConditions = message.termsAndConditions;
        if (message.languages && message.languages.length) {
            object.languages = [];
            for (var j = 0; j < message.languages.length; ++j)
                object.languages[j] = message.languages[j];
        }
        if (message.acceptedCurrencies && message.acceptedCurrencies.length) {
            object.acceptedCurrencies = [];
            for (var j = 0; j < message.acceptedCurrencies.length; ++j)
                object.acceptedCurrencies[j] = message.acceptedCurrencies[j];
        }
        if (message.fee != null && message.hasOwnProperty("fee"))
            object.fee = $root.Moderator.Fee.toObject(message.fee, options);
        return object;
    };

    /**
     * Converts this Moderator to JSON.
     * @function toJSON
     * @memberof Moderator
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Moderator.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Moderator.Fee = (function() {

        /**
         * Properties of a Fee.
         * @memberof Moderator
         * @interface IFee
         * @property {Moderator.IPrice|null} [fixedFee] Fee fixedFee
         * @property {number|null} [percentage] Fee percentage
         * @property {Moderator.Fee.FeeType|null} [feeType] Fee feeType
         */

        /**
         * Constructs a new Fee.
         * @memberof Moderator
         * @classdesc Represents a Fee.
         * @implements IFee
         * @constructor
         * @param {Moderator.IFee=} [properties] Properties to set
         */
        function Fee(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fee fixedFee.
         * @member {Moderator.IPrice|null|undefined} fixedFee
         * @memberof Moderator.Fee
         * @instance
         */
        Fee.prototype.fixedFee = null;

        /**
         * Fee percentage.
         * @member {number} percentage
         * @memberof Moderator.Fee
         * @instance
         */
        Fee.prototype.percentage = 0;

        /**
         * Fee feeType.
         * @member {Moderator.Fee.FeeType} feeType
         * @memberof Moderator.Fee
         * @instance
         */
        Fee.prototype.feeType = 0;

        /**
         * Creates a new Fee instance using the specified properties.
         * @function create
         * @memberof Moderator.Fee
         * @static
         * @param {Moderator.IFee=} [properties] Properties to set
         * @returns {Moderator.Fee} Fee instance
         */
        Fee.create = function create(properties) {
            return new Fee(properties);
        };

        /**
         * Encodes the specified Fee message. Does not implicitly {@link Moderator.Fee.verify|verify} messages.
         * @function encode
         * @memberof Moderator.Fee
         * @static
         * @param {Moderator.IFee} message Fee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fee.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fixedFee != null && message.hasOwnProperty("fixedFee"))
                $root.Moderator.Price.encode(message.fixedFee, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.percentage != null && message.hasOwnProperty("percentage"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.percentage);
            if (message.feeType != null && message.hasOwnProperty("feeType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.feeType);
            return writer;
        };

        /**
         * Encodes the specified Fee message, length delimited. Does not implicitly {@link Moderator.Fee.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Moderator.Fee
         * @static
         * @param {Moderator.IFee} message Fee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fee.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Fee message from the specified reader or buffer.
         * @function decode
         * @memberof Moderator.Fee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Moderator.Fee} Fee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fee.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Moderator.Fee();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fixedFee = $root.Moderator.Price.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.percentage = reader.float();
                    break;
                case 3:
                    message.feeType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Fee message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Moderator.Fee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Moderator.Fee} Fee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fee.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Fee message.
         * @function verify
         * @memberof Moderator.Fee
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fee.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fixedFee != null && message.hasOwnProperty("fixedFee")) {
                var error = $root.Moderator.Price.verify(message.fixedFee);
                if (error)
                    return "fixedFee." + error;
            }
            if (message.percentage != null && message.hasOwnProperty("percentage"))
                if (typeof message.percentage !== "number")
                    return "percentage: number expected";
            if (message.feeType != null && message.hasOwnProperty("feeType"))
                switch (message.feeType) {
                default:
                    return "feeType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Fee message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Moderator.Fee
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Moderator.Fee} Fee
         */
        Fee.fromObject = function fromObject(object) {
            if (object instanceof $root.Moderator.Fee)
                return object;
            var message = new $root.Moderator.Fee();
            if (object.fixedFee != null) {
                if (typeof object.fixedFee !== "object")
                    throw TypeError(".Moderator.Fee.fixedFee: object expected");
                message.fixedFee = $root.Moderator.Price.fromObject(object.fixedFee);
            }
            if (object.percentage != null)
                message.percentage = Number(object.percentage);
            switch (object.feeType) {
            case "FIXED":
            case 0:
                message.feeType = 0;
                break;
            case "PERCENTAGE":
            case 1:
                message.feeType = 1;
                break;
            case "FIXED_PLUS_PERCENTAGE":
            case 2:
                message.feeType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Fee message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Moderator.Fee
         * @static
         * @param {Moderator.Fee} message Fee
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fee.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fixedFee = null;
                object.percentage = 0;
                object.feeType = options.enums === String ? "FIXED" : 0;
            }
            if (message.fixedFee != null && message.hasOwnProperty("fixedFee"))
                object.fixedFee = $root.Moderator.Price.toObject(message.fixedFee, options);
            if (message.percentage != null && message.hasOwnProperty("percentage"))
                object.percentage = options.json && !isFinite(message.percentage) ? String(message.percentage) : message.percentage;
            if (message.feeType != null && message.hasOwnProperty("feeType"))
                object.feeType = options.enums === String ? $root.Moderator.Fee.FeeType[message.feeType] : message.feeType;
            return object;
        };

        /**
         * Converts this Fee to JSON.
         * @function toJSON
         * @memberof Moderator.Fee
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fee.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * FeeType enum.
         * @name Moderator.Fee.FeeType
         * @enum {string}
         * @property {number} FIXED=0 FIXED value
         * @property {number} PERCENTAGE=1 PERCENTAGE value
         * @property {number} FIXED_PLUS_PERCENTAGE=2 FIXED_PLUS_PERCENTAGE value
         */
        Fee.FeeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FIXED"] = 0;
            values[valuesById[1] = "PERCENTAGE"] = 1;
            values[valuesById[2] = "FIXED_PLUS_PERCENTAGE"] = 2;
            return values;
        })();

        return Fee;
    })();

    Moderator.Price = (function() {

        /**
         * Properties of a Price.
         * @memberof Moderator
         * @interface IPrice
         * @property {string|null} [currencyCode] Price currencyCode
         * @property {number|Long|null} [amount] Price amount
         */

        /**
         * Constructs a new Price.
         * @memberof Moderator
         * @classdesc Represents a Price.
         * @implements IPrice
         * @constructor
         * @param {Moderator.IPrice=} [properties] Properties to set
         */
        function Price(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Price currencyCode.
         * @member {string} currencyCode
         * @memberof Moderator.Price
         * @instance
         */
        Price.prototype.currencyCode = "";

        /**
         * Price amount.
         * @member {number|Long} amount
         * @memberof Moderator.Price
         * @instance
         */
        Price.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Price instance using the specified properties.
         * @function create
         * @memberof Moderator.Price
         * @static
         * @param {Moderator.IPrice=} [properties] Properties to set
         * @returns {Moderator.Price} Price instance
         */
        Price.create = function create(properties) {
            return new Price(properties);
        };

        /**
         * Encodes the specified Price message. Does not implicitly {@link Moderator.Price.verify|verify} messages.
         * @function encode
         * @memberof Moderator.Price
         * @static
         * @param {Moderator.IPrice} message Price message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Price.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.currencyCode);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified Price message, length delimited. Does not implicitly {@link Moderator.Price.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Moderator.Price
         * @static
         * @param {Moderator.IPrice} message Price message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Price.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Price message from the specified reader or buffer.
         * @function decode
         * @memberof Moderator.Price
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Moderator.Price} Price
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Price.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Moderator.Price();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currencyCode = reader.string();
                    break;
                case 2:
                    message.amount = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Price message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Moderator.Price
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Moderator.Price} Price
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Price.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Price message.
         * @function verify
         * @memberof Moderator.Price
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Price.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                if (!$util.isString(message.currencyCode))
                    return "currencyCode: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a Price message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Moderator.Price
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Moderator.Price} Price
         */
        Price.fromObject = function fromObject(object) {
            if (object instanceof $root.Moderator.Price)
                return object;
            var message = new $root.Moderator.Price();
            if (object.currencyCode != null)
                message.currencyCode = String(object.currencyCode);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a Price message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Moderator.Price
         * @static
         * @param {Moderator.Price} message Price
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Price.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currencyCode = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                object.currencyCode = message.currencyCode;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
            return object;
        };

        /**
         * Converts this Price to JSON.
         * @function toJSON
         * @memberof Moderator.Price
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Price.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Price;
    })();

    return Moderator;
})();

$root.DisputeUpdate = (function() {

    /**
     * Properties of a DisputeUpdate.
     * @exports IDisputeUpdate
     * @interface IDisputeUpdate
     * @property {string|null} [orderId] DisputeUpdate orderId
     * @property {string|null} [payoutAddress] DisputeUpdate payoutAddress
     * @property {Array.<IOutpoint>|null} [outpoints] DisputeUpdate outpoints
     * @property {Uint8Array|null} [serializedContract] DisputeUpdate serializedContract
     */

    /**
     * Constructs a new DisputeUpdate.
     * @exports DisputeUpdate
     * @classdesc Represents a DisputeUpdate.
     * @implements IDisputeUpdate
     * @constructor
     * @param {IDisputeUpdate=} [properties] Properties to set
     */
    function DisputeUpdate(properties) {
        this.outpoints = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DisputeUpdate orderId.
     * @member {string} orderId
     * @memberof DisputeUpdate
     * @instance
     */
    DisputeUpdate.prototype.orderId = "";

    /**
     * DisputeUpdate payoutAddress.
     * @member {string} payoutAddress
     * @memberof DisputeUpdate
     * @instance
     */
    DisputeUpdate.prototype.payoutAddress = "";

    /**
     * DisputeUpdate outpoints.
     * @member {Array.<IOutpoint>} outpoints
     * @memberof DisputeUpdate
     * @instance
     */
    DisputeUpdate.prototype.outpoints = $util.emptyArray;

    /**
     * DisputeUpdate serializedContract.
     * @member {Uint8Array} serializedContract
     * @memberof DisputeUpdate
     * @instance
     */
    DisputeUpdate.prototype.serializedContract = $util.newBuffer([]);

    /**
     * Creates a new DisputeUpdate instance using the specified properties.
     * @function create
     * @memberof DisputeUpdate
     * @static
     * @param {IDisputeUpdate=} [properties] Properties to set
     * @returns {DisputeUpdate} DisputeUpdate instance
     */
    DisputeUpdate.create = function create(properties) {
        return new DisputeUpdate(properties);
    };

    /**
     * Encodes the specified DisputeUpdate message. Does not implicitly {@link DisputeUpdate.verify|verify} messages.
     * @function encode
     * @memberof DisputeUpdate
     * @static
     * @param {IDisputeUpdate} message DisputeUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DisputeUpdate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderId);
        if (message.payoutAddress != null && message.hasOwnProperty("payoutAddress"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.payoutAddress);
        if (message.outpoints != null && message.outpoints.length)
            for (var i = 0; i < message.outpoints.length; ++i)
                $root.Outpoint.encode(message.outpoints[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.serializedContract != null && message.hasOwnProperty("serializedContract"))
            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.serializedContract);
        return writer;
    };

    /**
     * Encodes the specified DisputeUpdate message, length delimited. Does not implicitly {@link DisputeUpdate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DisputeUpdate
     * @static
     * @param {IDisputeUpdate} message DisputeUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DisputeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DisputeUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof DisputeUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DisputeUpdate} DisputeUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DisputeUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisputeUpdate();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.orderId = reader.string();
                break;
            case 2:
                message.payoutAddress = reader.string();
                break;
            case 3:
                if (!(message.outpoints && message.outpoints.length))
                    message.outpoints = [];
                message.outpoints.push($root.Outpoint.decode(reader, reader.uint32()));
                break;
            case 4:
                message.serializedContract = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DisputeUpdate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DisputeUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DisputeUpdate} DisputeUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DisputeUpdate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DisputeUpdate message.
     * @function verify
     * @memberof DisputeUpdate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DisputeUpdate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            if (!$util.isString(message.orderId))
                return "orderId: string expected";
        if (message.payoutAddress != null && message.hasOwnProperty("payoutAddress"))
            if (!$util.isString(message.payoutAddress))
                return "payoutAddress: string expected";
        if (message.outpoints != null && message.hasOwnProperty("outpoints")) {
            if (!Array.isArray(message.outpoints))
                return "outpoints: array expected";
            for (var i = 0; i < message.outpoints.length; ++i) {
                var error = $root.Outpoint.verify(message.outpoints[i]);
                if (error)
                    return "outpoints." + error;
            }
        }
        if (message.serializedContract != null && message.hasOwnProperty("serializedContract"))
            if (!(message.serializedContract && typeof message.serializedContract.length === "number" || $util.isString(message.serializedContract)))
                return "serializedContract: buffer expected";
        return null;
    };

    /**
     * Creates a DisputeUpdate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DisputeUpdate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DisputeUpdate} DisputeUpdate
     */
    DisputeUpdate.fromObject = function fromObject(object) {
        if (object instanceof $root.DisputeUpdate)
            return object;
        var message = new $root.DisputeUpdate();
        if (object.orderId != null)
            message.orderId = String(object.orderId);
        if (object.payoutAddress != null)
            message.payoutAddress = String(object.payoutAddress);
        if (object.outpoints) {
            if (!Array.isArray(object.outpoints))
                throw TypeError(".DisputeUpdate.outpoints: array expected");
            message.outpoints = [];
            for (var i = 0; i < object.outpoints.length; ++i) {
                if (typeof object.outpoints[i] !== "object")
                    throw TypeError(".DisputeUpdate.outpoints: object expected");
                message.outpoints[i] = $root.Outpoint.fromObject(object.outpoints[i]);
            }
        }
        if (object.serializedContract != null)
            if (typeof object.serializedContract === "string")
                $util.base64.decode(object.serializedContract, message.serializedContract = $util.newBuffer($util.base64.length(object.serializedContract)), 0);
            else if (object.serializedContract.length)
                message.serializedContract = object.serializedContract;
        return message;
    };

    /**
     * Creates a plain object from a DisputeUpdate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DisputeUpdate
     * @static
     * @param {DisputeUpdate} message DisputeUpdate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DisputeUpdate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.outpoints = [];
        if (options.defaults) {
            object.orderId = "";
            object.payoutAddress = "";
            object.serializedContract = options.bytes === String ? "" : [];
        }
        if (message.orderId != null && message.hasOwnProperty("orderId"))
            object.orderId = message.orderId;
        if (message.payoutAddress != null && message.hasOwnProperty("payoutAddress"))
            object.payoutAddress = message.payoutAddress;
        if (message.outpoints && message.outpoints.length) {
            object.outpoints = [];
            for (var j = 0; j < message.outpoints.length; ++j)
                object.outpoints[j] = $root.Outpoint.toObject(message.outpoints[j], options);
        }
        if (message.serializedContract != null && message.hasOwnProperty("serializedContract"))
            object.serializedContract = options.bytes === String ? $util.base64.encode(message.serializedContract, 0, message.serializedContract.length) : options.bytes === Array ? Array.prototype.slice.call(message.serializedContract) : message.serializedContract;
        return object;
    };

    /**
     * Converts this DisputeUpdate to JSON.
     * @function toJSON
     * @memberof DisputeUpdate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DisputeUpdate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DisputeUpdate;
})();

/**
 * OrderState enum.
 * @exports OrderState
 * @enum {string}
 * @property {number} PENDING=0 PENDING value
 * @property {number} AWAITING_PAYMENT=1 AWAITING_PAYMENT value
 * @property {number} AWAITING_PICKUP=2 AWAITING_PICKUP value
 * @property {number} AWAITING_FULFILLMENT=3 AWAITING_FULFILLMENT value
 * @property {number} PARTIALLY_FULFILLED=4 PARTIALLY_FULFILLED value
 * @property {number} FULFILLED=5 FULFILLED value
 * @property {number} COMPLETED=6 COMPLETED value
 * @property {number} CANCELED=7 CANCELED value
 * @property {number} DECLINED=8 DECLINED value
 * @property {number} REFUNDED=9 REFUNDED value
 * @property {number} DISPUTED=10 DISPUTED value
 * @property {number} DECIDED=11 DECIDED value
 * @property {number} RESOLVED=12 RESOLVED value
 * @property {number} PAYMENT_FINALIZED=13 PAYMENT_FINALIZED value
 * @property {number} PROCESSING_ERROR=14 PROCESSING_ERROR value
 */
$root.OrderState = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "PENDING"] = 0;
    values[valuesById[1] = "AWAITING_PAYMENT"] = 1;
    values[valuesById[2] = "AWAITING_PICKUP"] = 2;
    values[valuesById[3] = "AWAITING_FULFILLMENT"] = 3;
    values[valuesById[4] = "PARTIALLY_FULFILLED"] = 4;
    values[valuesById[5] = "FULFILLED"] = 5;
    values[valuesById[6] = "COMPLETED"] = 6;
    values[valuesById[7] = "CANCELED"] = 7;
    values[valuesById[8] = "DECLINED"] = 8;
    values[valuesById[9] = "REFUNDED"] = 9;
    values[valuesById[10] = "DISPUTED"] = 10;
    values[valuesById[11] = "DECIDED"] = 11;
    values[valuesById[12] = "RESOLVED"] = 12;
    values[valuesById[13] = "PAYMENT_FINALIZED"] = 13;
    values[valuesById[14] = "PROCESSING_ERROR"] = 14;
    return values;
})();

$root.Post = (function() {

    /**
     * Properties of a Post.
     * @exports IPost
     * @interface IPost
     * @property {string|null} [slug] Post slug
     * @property {IID|null} [vendorID] Immutable human readabile clean url
     * @property {string|null} [title] PeerID of the content
     * @property {string|null} [longForm] Title of post
     * @property {Array.<IImage>|null} [images] Post content
     * @property {Array.<string>|null} [tags] List of post images
     * @property {google.protobuf.ITimestamp|null} [timestamp] List of text tags
     */

    /**
     * Constructs a new Post.
     * @exports Post
     * @classdesc Represents a Post.
     * @implements IPost
     * @constructor
     * @param {IPost=} [properties] Properties to set
     */
    function Post(properties) {
        this.images = [];
        this.tags = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Post slug.
     * @member {string} slug
     * @memberof Post
     * @instance
     */
    Post.prototype.slug = "";

    /**
     * Immutable human readabile clean url
     * @member {IID|null|undefined} vendorID
     * @memberof Post
     * @instance
     */
    Post.prototype.vendorID = null;

    /**
     * PeerID of the content
     * @member {string} title
     * @memberof Post
     * @instance
     */
    Post.prototype.title = "";

    /**
     * Title of post
     * @member {string} longForm
     * @memberof Post
     * @instance
     */
    Post.prototype.longForm = "";

    /**
     * Post content
     * @member {Array.<IImage>} images
     * @memberof Post
     * @instance
     */
    Post.prototype.images = $util.emptyArray;

    /**
     * List of post images
     * @member {Array.<string>} tags
     * @memberof Post
     * @instance
     */
    Post.prototype.tags = $util.emptyArray;

    /**
     * List of text tags
     * @member {google.protobuf.ITimestamp|null|undefined} timestamp
     * @memberof Post
     * @instance
     */
    Post.prototype.timestamp = null;

    /**
     * Creates a new Post instance using the specified properties.
     * @function create
     * @memberof Post
     * @static
     * @param {IPost=} [properties] Properties to set
     * @returns {Post} Post instance
     */
    Post.create = function create(properties) {
        return new Post(properties);
    };

    /**
     * Encodes the specified Post message. Does not implicitly {@link Post.verify|verify} messages.
     * @function encode
     * @memberof Post
     * @static
     * @param {IPost} message Post message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Post.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.slug != null && message.hasOwnProperty("slug"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.slug);
        if (message.vendorID != null && message.hasOwnProperty("vendorID"))
            $root.ID.encode(message.vendorID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.title != null && message.hasOwnProperty("title"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
        if (message.longForm != null && message.hasOwnProperty("longForm"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.longForm);
        if (message.images != null && message.images.length)
            for (var i = 0; i < message.images.length; ++i)
                $root.Image.encode(message.images[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.tags != null && message.tags.length)
            for (var i = 0; i < message.tags.length; ++i)
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Post message, length delimited. Does not implicitly {@link Post.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Post
     * @static
     * @param {IPost} message Post message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Post.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Post message from the specified reader or buffer.
     * @function decode
     * @memberof Post
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Post} Post
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Post.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Post();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.slug = reader.string();
                break;
            case 2:
                message.vendorID = $root.ID.decode(reader, reader.uint32());
                break;
            case 3:
                message.title = reader.string();
                break;
            case 4:
                message.longForm = reader.string();
                break;
            case 5:
                if (!(message.images && message.images.length))
                    message.images = [];
                message.images.push($root.Image.decode(reader, reader.uint32()));
                break;
            case 6:
                if (!(message.tags && message.tags.length))
                    message.tags = [];
                message.tags.push(reader.string());
                break;
            case 7:
                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Post message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Post
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Post} Post
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Post.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Post message.
     * @function verify
     * @memberof Post
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Post.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.slug != null && message.hasOwnProperty("slug"))
            if (!$util.isString(message.slug))
                return "slug: string expected";
        if (message.vendorID != null && message.hasOwnProperty("vendorID")) {
            var error = $root.ID.verify(message.vendorID);
            if (error)
                return "vendorID." + error;
        }
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.longForm != null && message.hasOwnProperty("longForm"))
            if (!$util.isString(message.longForm))
                return "longForm: string expected";
        if (message.images != null && message.hasOwnProperty("images")) {
            if (!Array.isArray(message.images))
                return "images: array expected";
            for (var i = 0; i < message.images.length; ++i) {
                var error = $root.Image.verify(message.images[i]);
                if (error)
                    return "images." + error;
            }
        }
        if (message.tags != null && message.hasOwnProperty("tags")) {
            if (!Array.isArray(message.tags))
                return "tags: array expected";
            for (var i = 0; i < message.tags.length; ++i)
                if (!$util.isString(message.tags[i]))
                    return "tags: string[] expected";
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
            if (error)
                return "timestamp." + error;
        }
        return null;
    };

    /**
     * Creates a Post message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Post
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Post} Post
     */
    Post.fromObject = function fromObject(object) {
        if (object instanceof $root.Post)
            return object;
        var message = new $root.Post();
        if (object.slug != null)
            message.slug = String(object.slug);
        if (object.vendorID != null) {
            if (typeof object.vendorID !== "object")
                throw TypeError(".Post.vendorID: object expected");
            message.vendorID = $root.ID.fromObject(object.vendorID);
        }
        if (object.title != null)
            message.title = String(object.title);
        if (object.longForm != null)
            message.longForm = String(object.longForm);
        if (object.images) {
            if (!Array.isArray(object.images))
                throw TypeError(".Post.images: array expected");
            message.images = [];
            for (var i = 0; i < object.images.length; ++i) {
                if (typeof object.images[i] !== "object")
                    throw TypeError(".Post.images: object expected");
                message.images[i] = $root.Image.fromObject(object.images[i]);
            }
        }
        if (object.tags) {
            if (!Array.isArray(object.tags))
                throw TypeError(".Post.tags: array expected");
            message.tags = [];
            for (var i = 0; i < object.tags.length; ++i)
                message.tags[i] = String(object.tags[i]);
        }
        if (object.timestamp != null) {
            if (typeof object.timestamp !== "object")
                throw TypeError(".Post.timestamp: object expected");
            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
        }
        return message;
    };

    /**
     * Creates a plain object from a Post message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Post
     * @static
     * @param {Post} message Post
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Post.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.images = [];
            object.tags = [];
        }
        if (options.defaults) {
            object.slug = "";
            object.vendorID = null;
            object.title = "";
            object.longForm = "";
            object.timestamp = null;
        }
        if (message.slug != null && message.hasOwnProperty("slug"))
            object.slug = message.slug;
        if (message.vendorID != null && message.hasOwnProperty("vendorID"))
            object.vendorID = $root.ID.toObject(message.vendorID, options);
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.longForm != null && message.hasOwnProperty("longForm"))
            object.longForm = message.longForm;
        if (message.images && message.images.length) {
            object.images = [];
            for (var j = 0; j < message.images.length; ++j)
                object.images[j] = $root.Image.toObject(message.images[j], options);
        }
        if (message.tags && message.tags.length) {
            object.tags = [];
            for (var j = 0; j < message.tags.length; ++j)
                object.tags[j] = message.tags[j];
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
        return object;
    };

    /**
     * Converts this Post to JSON.
     * @function toJSON
     * @memberof Post
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Post.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Post;
})();

$root.SignedPost = (function() {

    /**
     * Properties of a SignedPost.
     * @exports ISignedPost
     * @interface ISignedPost
     * @property {IPost|null} [post] SignedPost post
     * @property {string|null} [hash] SignedPost hash
     * @property {Uint8Array|null} [signature] SignedPost signature
     */

    /**
     * Constructs a new SignedPost.
     * @exports SignedPost
     * @classdesc Represents a SignedPost.
     * @implements ISignedPost
     * @constructor
     * @param {ISignedPost=} [properties] Properties to set
     */
    function SignedPost(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SignedPost post.
     * @member {IPost|null|undefined} post
     * @memberof SignedPost
     * @instance
     */
    SignedPost.prototype.post = null;

    /**
     * SignedPost hash.
     * @member {string} hash
     * @memberof SignedPost
     * @instance
     */
    SignedPost.prototype.hash = "";

    /**
     * SignedPost signature.
     * @member {Uint8Array} signature
     * @memberof SignedPost
     * @instance
     */
    SignedPost.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new SignedPost instance using the specified properties.
     * @function create
     * @memberof SignedPost
     * @static
     * @param {ISignedPost=} [properties] Properties to set
     * @returns {SignedPost} SignedPost instance
     */
    SignedPost.create = function create(properties) {
        return new SignedPost(properties);
    };

    /**
     * Encodes the specified SignedPost message. Does not implicitly {@link SignedPost.verify|verify} messages.
     * @function encode
     * @memberof SignedPost
     * @static
     * @param {ISignedPost} message SignedPost message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignedPost.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.post != null && message.hasOwnProperty("post"))
            $root.Post.encode(message.post, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.hash);
        if (message.signature != null && message.hasOwnProperty("signature"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
        return writer;
    };

    /**
     * Encodes the specified SignedPost message, length delimited. Does not implicitly {@link SignedPost.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SignedPost
     * @static
     * @param {ISignedPost} message SignedPost message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignedPost.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SignedPost message from the specified reader or buffer.
     * @function decode
     * @memberof SignedPost
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SignedPost} SignedPost
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignedPost.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SignedPost();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.post = $root.Post.decode(reader, reader.uint32());
                break;
            case 2:
                message.hash = reader.string();
                break;
            case 3:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SignedPost message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SignedPost
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SignedPost} SignedPost
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignedPost.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SignedPost message.
     * @function verify
     * @memberof SignedPost
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SignedPost.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.post != null && message.hasOwnProperty("post")) {
            var error = $root.Post.verify(message.post);
            if (error)
                return "post." + error;
        }
        if (message.hash != null && message.hasOwnProperty("hash"))
            if (!$util.isString(message.hash))
                return "hash: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates a SignedPost message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SignedPost
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SignedPost} SignedPost
     */
    SignedPost.fromObject = function fromObject(object) {
        if (object instanceof $root.SignedPost)
            return object;
        var message = new $root.SignedPost();
        if (object.post != null) {
            if (typeof object.post !== "object")
                throw TypeError(".SignedPost.post: object expected");
            message.post = $root.Post.fromObject(object.post);
        }
        if (object.hash != null)
            message.hash = String(object.hash);
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from a SignedPost message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SignedPost
     * @static
     * @param {SignedPost} message SignedPost
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SignedPost.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.post = null;
            object.hash = "";
            object.signature = options.bytes === String ? "" : [];
        }
        if (message.post != null && message.hasOwnProperty("post"))
            object.post = $root.Post.toObject(message.post, options);
        if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = message.hash;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        return object;
    };

    /**
     * Converts this SignedPost to JSON.
     * @function toJSON
     * @memberof SignedPost
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SignedPost.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SignedPost;
})();

$root.Profile = (function() {

    /**
     * Properties of a Profile.
     * @exports IProfile
     * @interface IProfile
     * @property {string|null} [peerID] Profile peerID
     * @property {string|null} [handle] The unique Base58 CIDv0 ipfs node identifer, (Qm...).
     * @property {string|null} [name] Distinct authoritative human-readable name (i.e. dnslink)
     * @property {string|null} [location] Display name of peer
     * @property {string|null} [about] Description of store location (100 character limit)
     * @property {string|null} [shortDescription] Long description with basic html markup allowed.
     * @property {boolean|null} [nsfw] Profile nsfw
     * @property {boolean|null} [vendor] Whether the node hosts mature or adult content.
     * @property {boolean|null} [moderator] Whether the node is operating as a vendor.
     * @property {IModerator|null} [moderatorInfo] Whether the node offers moderation as a service.
     * @property {Profile.IContact|null} [contactInfo] Profile contactInfo
     * @property {Profile.IColors|null} [colors] The contact info for the node.
     * @property {IImage|null} [avatarHashes] Profile avatarHashes
     * @property {IImage|null} [headerHashes] The node avatar image. (tiny: 60x60)
     * @property {Profile.IStats|null} [stats] Profile stats
     * @property {string|null} [bitcoinPubkey] Profile bitcoinPubkey
     * @property {google.protobuf.ITimestamp|null} [lastModified] Profile lastModified
     * @property {Array.<string>|null} [currencies] Profile currencies
     */

    /**
     * Constructs a new Profile.
     * @exports Profile
     * @classdesc A participant on the openbazaar network. Defined by a random secret (12 word seed), used to generate
     * both the root cryptocurrency address and ipfs public hash.
     * @implements IProfile
     * @constructor
     * @param {IProfile=} [properties] Properties to set
     */
    function Profile(properties) {
        this.currencies = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Profile peerID.
     * @member {string} peerID
     * @memberof Profile
     * @instance
     */
    Profile.prototype.peerID = "";

    /**
     * The unique Base58 CIDv0 ipfs node identifer, (Qm...).
     * @member {string} handle
     * @memberof Profile
     * @instance
     */
    Profile.prototype.handle = "";

    /**
     * Distinct authoritative human-readable name (i.e. dnslink)
     * @member {string} name
     * @memberof Profile
     * @instance
     */
    Profile.prototype.name = "";

    /**
     * Display name of peer
     * @member {string} location
     * @memberof Profile
     * @instance
     */
    Profile.prototype.location = "";

    /**
     * Description of store location (100 character limit)
     * @member {string} about
     * @memberof Profile
     * @instance
     */
    Profile.prototype.about = "";

    /**
     * Long description with basic html markup allowed.
     * @member {string} shortDescription
     * @memberof Profile
     * @instance
     */
    Profile.prototype.shortDescription = "";

    /**
     * Profile nsfw.
     * @member {boolean} nsfw
     * @memberof Profile
     * @instance
     */
    Profile.prototype.nsfw = false;

    /**
     * Whether the node hosts mature or adult content.
     * @member {boolean} vendor
     * @memberof Profile
     * @instance
     */
    Profile.prototype.vendor = false;

    /**
     * Whether the node is operating as a vendor.
     * @member {boolean} moderator
     * @memberof Profile
     * @instance
     */
    Profile.prototype.moderator = false;

    /**
     * Whether the node offers moderation as a service.
     * @member {IModerator|null|undefined} moderatorInfo
     * @memberof Profile
     * @instance
     */
    Profile.prototype.moderatorInfo = null;

    /**
     * Profile contactInfo.
     * @member {Profile.IContact|null|undefined} contactInfo
     * @memberof Profile
     * @instance
     */
    Profile.prototype.contactInfo = null;

    /**
     * The contact info for the node.
     * @member {Profile.IColors|null|undefined} colors
     * @memberof Profile
     * @instance
     */
    Profile.prototype.colors = null;

    /**
     * Profile avatarHashes.
     * @member {IImage|null|undefined} avatarHashes
     * @memberof Profile
     * @instance
     */
    Profile.prototype.avatarHashes = null;

    /**
     * The node avatar image. (tiny: 60x60)
     * @member {IImage|null|undefined} headerHashes
     * @memberof Profile
     * @instance
     */
    Profile.prototype.headerHashes = null;

    /**
     * Profile stats.
     * @member {Profile.IStats|null|undefined} stats
     * @memberof Profile
     * @instance
     */
    Profile.prototype.stats = null;

    /**
     * Profile bitcoinPubkey.
     * @member {string} bitcoinPubkey
     * @memberof Profile
     * @instance
     */
    Profile.prototype.bitcoinPubkey = "";

    /**
     * Profile lastModified.
     * @member {google.protobuf.ITimestamp|null|undefined} lastModified
     * @memberof Profile
     * @instance
     */
    Profile.prototype.lastModified = null;

    /**
     * Profile currencies.
     * @member {Array.<string>} currencies
     * @memberof Profile
     * @instance
     */
    Profile.prototype.currencies = $util.emptyArray;

    /**
     * Creates a new Profile instance using the specified properties.
     * @function create
     * @memberof Profile
     * @static
     * @param {IProfile=} [properties] Properties to set
     * @returns {Profile} Profile instance
     */
    Profile.create = function create(properties) {
        return new Profile(properties);
    };

    /**
     * Encodes the specified Profile message. Does not implicitly {@link Profile.verify|verify} messages.
     * @function encode
     * @memberof Profile
     * @static
     * @param {IProfile} message Profile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Profile.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.peerID != null && message.hasOwnProperty("peerID"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerID);
        if (message.handle != null && message.hasOwnProperty("handle"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.handle);
        if (message.name != null && message.hasOwnProperty("name"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
        if (message.location != null && message.hasOwnProperty("location"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.location);
        if (message.about != null && message.hasOwnProperty("about"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.about);
        if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.shortDescription);
        if (message.nsfw != null && message.hasOwnProperty("nsfw"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.nsfw);
        if (message.vendor != null && message.hasOwnProperty("vendor"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.vendor);
        if (message.moderator != null && message.hasOwnProperty("moderator"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.moderator);
        if (message.moderatorInfo != null && message.hasOwnProperty("moderatorInfo"))
            $root.Moderator.encode(message.moderatorInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.contactInfo != null && message.hasOwnProperty("contactInfo"))
            $root.Profile.Contact.encode(message.contactInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.colors != null && message.hasOwnProperty("colors"))
            $root.Profile.Colors.encode(message.colors, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.avatarHashes != null && message.hasOwnProperty("avatarHashes"))
            $root.Image.encode(message.avatarHashes, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.headerHashes != null && message.hasOwnProperty("headerHashes"))
            $root.Image.encode(message.headerHashes, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.stats != null && message.hasOwnProperty("stats"))
            $root.Profile.Stats.encode(message.stats, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.bitcoinPubkey != null && message.hasOwnProperty("bitcoinPubkey"))
            writer.uint32(/* id 16, wireType 2 =*/130).string(message.bitcoinPubkey);
        if (message.lastModified != null && message.hasOwnProperty("lastModified"))
            $root.google.protobuf.Timestamp.encode(message.lastModified, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        if (message.currencies != null && message.currencies.length)
            for (var i = 0; i < message.currencies.length; ++i)
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.currencies[i]);
        return writer;
    };

    /**
     * Encodes the specified Profile message, length delimited. Does not implicitly {@link Profile.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Profile
     * @static
     * @param {IProfile} message Profile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Profile.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Profile message from the specified reader or buffer.
     * @function decode
     * @memberof Profile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Profile} Profile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Profile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Profile();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.peerID = reader.string();
                break;
            case 2:
                message.handle = reader.string();
                break;
            case 3:
                message.name = reader.string();
                break;
            case 4:
                message.location = reader.string();
                break;
            case 5:
                message.about = reader.string();
                break;
            case 6:
                message.shortDescription = reader.string();
                break;
            case 7:
                message.nsfw = reader.bool();
                break;
            case 8:
                message.vendor = reader.bool();
                break;
            case 9:
                message.moderator = reader.bool();
                break;
            case 10:
                message.moderatorInfo = $root.Moderator.decode(reader, reader.uint32());
                break;
            case 11:
                message.contactInfo = $root.Profile.Contact.decode(reader, reader.uint32());
                break;
            case 12:
                message.colors = $root.Profile.Colors.decode(reader, reader.uint32());
                break;
            case 13:
                message.avatarHashes = $root.Image.decode(reader, reader.uint32());
                break;
            case 14:
                message.headerHashes = $root.Image.decode(reader, reader.uint32());
                break;
            case 15:
                message.stats = $root.Profile.Stats.decode(reader, reader.uint32());
                break;
            case 16:
                message.bitcoinPubkey = reader.string();
                break;
            case 17:
                message.lastModified = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 18:
                if (!(message.currencies && message.currencies.length))
                    message.currencies = [];
                message.currencies.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Profile message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Profile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Profile} Profile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Profile.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Profile message.
     * @function verify
     * @memberof Profile
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Profile.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.peerID != null && message.hasOwnProperty("peerID"))
            if (!$util.isString(message.peerID))
                return "peerID: string expected";
        if (message.handle != null && message.hasOwnProperty("handle"))
            if (!$util.isString(message.handle))
                return "handle: string expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.location != null && message.hasOwnProperty("location"))
            if (!$util.isString(message.location))
                return "location: string expected";
        if (message.about != null && message.hasOwnProperty("about"))
            if (!$util.isString(message.about))
                return "about: string expected";
        if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
            if (!$util.isString(message.shortDescription))
                return "shortDescription: string expected";
        if (message.nsfw != null && message.hasOwnProperty("nsfw"))
            if (typeof message.nsfw !== "boolean")
                return "nsfw: boolean expected";
        if (message.vendor != null && message.hasOwnProperty("vendor"))
            if (typeof message.vendor !== "boolean")
                return "vendor: boolean expected";
        if (message.moderator != null && message.hasOwnProperty("moderator"))
            if (typeof message.moderator !== "boolean")
                return "moderator: boolean expected";
        if (message.moderatorInfo != null && message.hasOwnProperty("moderatorInfo")) {
            var error = $root.Moderator.verify(message.moderatorInfo);
            if (error)
                return "moderatorInfo." + error;
        }
        if (message.contactInfo != null && message.hasOwnProperty("contactInfo")) {
            var error = $root.Profile.Contact.verify(message.contactInfo);
            if (error)
                return "contactInfo." + error;
        }
        if (message.colors != null && message.hasOwnProperty("colors")) {
            var error = $root.Profile.Colors.verify(message.colors);
            if (error)
                return "colors." + error;
        }
        if (message.avatarHashes != null && message.hasOwnProperty("avatarHashes")) {
            var error = $root.Image.verify(message.avatarHashes);
            if (error)
                return "avatarHashes." + error;
        }
        if (message.headerHashes != null && message.hasOwnProperty("headerHashes")) {
            var error = $root.Image.verify(message.headerHashes);
            if (error)
                return "headerHashes." + error;
        }
        if (message.stats != null && message.hasOwnProperty("stats")) {
            var error = $root.Profile.Stats.verify(message.stats);
            if (error)
                return "stats." + error;
        }
        if (message.bitcoinPubkey != null && message.hasOwnProperty("bitcoinPubkey"))
            if (!$util.isString(message.bitcoinPubkey))
                return "bitcoinPubkey: string expected";
        if (message.lastModified != null && message.hasOwnProperty("lastModified")) {
            var error = $root.google.protobuf.Timestamp.verify(message.lastModified);
            if (error)
                return "lastModified." + error;
        }
        if (message.currencies != null && message.hasOwnProperty("currencies")) {
            if (!Array.isArray(message.currencies))
                return "currencies: array expected";
            for (var i = 0; i < message.currencies.length; ++i)
                if (!$util.isString(message.currencies[i]))
                    return "currencies: string[] expected";
        }
        return null;
    };

    /**
     * Creates a Profile message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Profile
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Profile} Profile
     */
    Profile.fromObject = function fromObject(object) {
        if (object instanceof $root.Profile)
            return object;
        var message = new $root.Profile();
        if (object.peerID != null)
            message.peerID = String(object.peerID);
        if (object.handle != null)
            message.handle = String(object.handle);
        if (object.name != null)
            message.name = String(object.name);
        if (object.location != null)
            message.location = String(object.location);
        if (object.about != null)
            message.about = String(object.about);
        if (object.shortDescription != null)
            message.shortDescription = String(object.shortDescription);
        if (object.nsfw != null)
            message.nsfw = Boolean(object.nsfw);
        if (object.vendor != null)
            message.vendor = Boolean(object.vendor);
        if (object.moderator != null)
            message.moderator = Boolean(object.moderator);
        if (object.moderatorInfo != null) {
            if (typeof object.moderatorInfo !== "object")
                throw TypeError(".Profile.moderatorInfo: object expected");
            message.moderatorInfo = $root.Moderator.fromObject(object.moderatorInfo);
        }
        if (object.contactInfo != null) {
            if (typeof object.contactInfo !== "object")
                throw TypeError(".Profile.contactInfo: object expected");
            message.contactInfo = $root.Profile.Contact.fromObject(object.contactInfo);
        }
        if (object.colors != null) {
            if (typeof object.colors !== "object")
                throw TypeError(".Profile.colors: object expected");
            message.colors = $root.Profile.Colors.fromObject(object.colors);
        }
        if (object.avatarHashes != null) {
            if (typeof object.avatarHashes !== "object")
                throw TypeError(".Profile.avatarHashes: object expected");
            message.avatarHashes = $root.Image.fromObject(object.avatarHashes);
        }
        if (object.headerHashes != null) {
            if (typeof object.headerHashes !== "object")
                throw TypeError(".Profile.headerHashes: object expected");
            message.headerHashes = $root.Image.fromObject(object.headerHashes);
        }
        if (object.stats != null) {
            if (typeof object.stats !== "object")
                throw TypeError(".Profile.stats: object expected");
            message.stats = $root.Profile.Stats.fromObject(object.stats);
        }
        if (object.bitcoinPubkey != null)
            message.bitcoinPubkey = String(object.bitcoinPubkey);
        if (object.lastModified != null) {
            if (typeof object.lastModified !== "object")
                throw TypeError(".Profile.lastModified: object expected");
            message.lastModified = $root.google.protobuf.Timestamp.fromObject(object.lastModified);
        }
        if (object.currencies) {
            if (!Array.isArray(object.currencies))
                throw TypeError(".Profile.currencies: array expected");
            message.currencies = [];
            for (var i = 0; i < object.currencies.length; ++i)
                message.currencies[i] = String(object.currencies[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a Profile message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Profile
     * @static
     * @param {Profile} message Profile
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Profile.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.currencies = [];
        if (options.defaults) {
            object.peerID = "";
            object.handle = "";
            object.name = "";
            object.location = "";
            object.about = "";
            object.shortDescription = "";
            object.nsfw = false;
            object.vendor = false;
            object.moderator = false;
            object.moderatorInfo = null;
            object.contactInfo = null;
            object.colors = null;
            object.avatarHashes = null;
            object.headerHashes = null;
            object.stats = null;
            object.bitcoinPubkey = "";
            object.lastModified = null;
        }
        if (message.peerID != null && message.hasOwnProperty("peerID"))
            object.peerID = message.peerID;
        if (message.handle != null && message.hasOwnProperty("handle"))
            object.handle = message.handle;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.location != null && message.hasOwnProperty("location"))
            object.location = message.location;
        if (message.about != null && message.hasOwnProperty("about"))
            object.about = message.about;
        if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
            object.shortDescription = message.shortDescription;
        if (message.nsfw != null && message.hasOwnProperty("nsfw"))
            object.nsfw = message.nsfw;
        if (message.vendor != null && message.hasOwnProperty("vendor"))
            object.vendor = message.vendor;
        if (message.moderator != null && message.hasOwnProperty("moderator"))
            object.moderator = message.moderator;
        if (message.moderatorInfo != null && message.hasOwnProperty("moderatorInfo"))
            object.moderatorInfo = $root.Moderator.toObject(message.moderatorInfo, options);
        if (message.contactInfo != null && message.hasOwnProperty("contactInfo"))
            object.contactInfo = $root.Profile.Contact.toObject(message.contactInfo, options);
        if (message.colors != null && message.hasOwnProperty("colors"))
            object.colors = $root.Profile.Colors.toObject(message.colors, options);
        if (message.avatarHashes != null && message.hasOwnProperty("avatarHashes"))
            object.avatarHashes = $root.Image.toObject(message.avatarHashes, options);
        if (message.headerHashes != null && message.hasOwnProperty("headerHashes"))
            object.headerHashes = $root.Image.toObject(message.headerHashes, options);
        if (message.stats != null && message.hasOwnProperty("stats"))
            object.stats = $root.Profile.Stats.toObject(message.stats, options);
        if (message.bitcoinPubkey != null && message.hasOwnProperty("bitcoinPubkey"))
            object.bitcoinPubkey = message.bitcoinPubkey;
        if (message.lastModified != null && message.hasOwnProperty("lastModified"))
            object.lastModified = $root.google.protobuf.Timestamp.toObject(message.lastModified, options);
        if (message.currencies && message.currencies.length) {
            object.currencies = [];
            for (var j = 0; j < message.currencies.length; ++j)
                object.currencies[j] = message.currencies[j];
        }
        return object;
    };

    /**
     * Converts this Profile to JSON.
     * @function toJSON
     * @memberof Profile
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Profile.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Profile.Contact = (function() {

        /**
         * Properties of a Contact.
         * @memberof Profile
         * @interface IContact
         * @property {string|null} [website] Contact website
         * @property {string|null} [email] Website url
         * @property {string|null} [phoneNumber] Contact email address
         * @property {Array.<Profile.ISocialAccount>|null} [social] Contact phone number
         */

        /**
         * Constructs a new Contact.
         * @memberof Profile
         * @classdesc Contact information for the node.
         * @implements IContact
         * @constructor
         * @param {Profile.IContact=} [properties] Properties to set
         */
        function Contact(properties) {
            this.social = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Contact website.
         * @member {string} website
         * @memberof Profile.Contact
         * @instance
         */
        Contact.prototype.website = "";

        /**
         * Website url
         * @member {string} email
         * @memberof Profile.Contact
         * @instance
         */
        Contact.prototype.email = "";

        /**
         * Contact email address
         * @member {string} phoneNumber
         * @memberof Profile.Contact
         * @instance
         */
        Contact.prototype.phoneNumber = "";

        /**
         * Contact phone number
         * @member {Array.<Profile.ISocialAccount>} social
         * @memberof Profile.Contact
         * @instance
         */
        Contact.prototype.social = $util.emptyArray;

        /**
         * Creates a new Contact instance using the specified properties.
         * @function create
         * @memberof Profile.Contact
         * @static
         * @param {Profile.IContact=} [properties] Properties to set
         * @returns {Profile.Contact} Contact instance
         */
        Contact.create = function create(properties) {
            return new Contact(properties);
        };

        /**
         * Encodes the specified Contact message. Does not implicitly {@link Profile.Contact.verify|verify} messages.
         * @function encode
         * @memberof Profile.Contact
         * @static
         * @param {Profile.IContact} message Contact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contact.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.website != null && message.hasOwnProperty("website"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.website);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.phoneNumber);
            if (message.social != null && message.social.length)
                for (var i = 0; i < message.social.length; ++i)
                    $root.Profile.SocialAccount.encode(message.social[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Contact message, length delimited. Does not implicitly {@link Profile.Contact.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Profile.Contact
         * @static
         * @param {Profile.IContact} message Contact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contact.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Contact message from the specified reader or buffer.
         * @function decode
         * @memberof Profile.Contact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Profile.Contact} Contact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contact.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Profile.Contact();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.website = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.phoneNumber = reader.string();
                    break;
                case 4:
                    if (!(message.social && message.social.length))
                        message.social = [];
                    message.social.push($root.Profile.SocialAccount.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Contact message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Profile.Contact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Profile.Contact} Contact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contact.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Contact message.
         * @function verify
         * @memberof Profile.Contact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Contact.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.website != null && message.hasOwnProperty("website"))
                if (!$util.isString(message.website))
                    return "website: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                if (!$util.isString(message.phoneNumber))
                    return "phoneNumber: string expected";
            if (message.social != null && message.hasOwnProperty("social")) {
                if (!Array.isArray(message.social))
                    return "social: array expected";
                for (var i = 0; i < message.social.length; ++i) {
                    var error = $root.Profile.SocialAccount.verify(message.social[i]);
                    if (error)
                        return "social." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Contact message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Profile.Contact
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Profile.Contact} Contact
         */
        Contact.fromObject = function fromObject(object) {
            if (object instanceof $root.Profile.Contact)
                return object;
            var message = new $root.Profile.Contact();
            if (object.website != null)
                message.website = String(object.website);
            if (object.email != null)
                message.email = String(object.email);
            if (object.phoneNumber != null)
                message.phoneNumber = String(object.phoneNumber);
            if (object.social) {
                if (!Array.isArray(object.social))
                    throw TypeError(".Profile.Contact.social: array expected");
                message.social = [];
                for (var i = 0; i < object.social.length; ++i) {
                    if (typeof object.social[i] !== "object")
                        throw TypeError(".Profile.Contact.social: object expected");
                    message.social[i] = $root.Profile.SocialAccount.fromObject(object.social[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Contact message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Profile.Contact
         * @static
         * @param {Profile.Contact} message Contact
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Contact.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.social = [];
            if (options.defaults) {
                object.website = "";
                object.email = "";
                object.phoneNumber = "";
            }
            if (message.website != null && message.hasOwnProperty("website"))
                object.website = message.website;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                object.phoneNumber = message.phoneNumber;
            if (message.social && message.social.length) {
                object.social = [];
                for (var j = 0; j < message.social.length; ++j)
                    object.social[j] = $root.Profile.SocialAccount.toObject(message.social[j], options);
            }
            return object;
        };

        /**
         * Converts this Contact to JSON.
         * @function toJSON
         * @memberof Profile.Contact
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Contact.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Contact;
    })();

    Profile.SocialAccount = (function() {

        /**
         * Properties of a SocialAccount.
         * @memberof Profile
         * @interface ISocialAccount
         * @property {string|null} [type] SocialAccount type
         * @property {string|null} [username] Social media platform
         * @property {string|null} [proof] Handle on social media platform
         */

        /**
         * Constructs a new SocialAccount.
         * @memberof Profile
         * @classdesc Reference to an external account
         * @implements ISocialAccount
         * @constructor
         * @param {Profile.ISocialAccount=} [properties] Properties to set
         */
        function SocialAccount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SocialAccount type.
         * @member {string} type
         * @memberof Profile.SocialAccount
         * @instance
         */
        SocialAccount.prototype.type = "";

        /**
         * Social media platform
         * @member {string} username
         * @memberof Profile.SocialAccount
         * @instance
         */
        SocialAccount.prototype.username = "";

        /**
         * Handle on social media platform
         * @member {string} proof
         * @memberof Profile.SocialAccount
         * @instance
         */
        SocialAccount.prototype.proof = "";

        /**
         * Creates a new SocialAccount instance using the specified properties.
         * @function create
         * @memberof Profile.SocialAccount
         * @static
         * @param {Profile.ISocialAccount=} [properties] Properties to set
         * @returns {Profile.SocialAccount} SocialAccount instance
         */
        SocialAccount.create = function create(properties) {
            return new SocialAccount(properties);
        };

        /**
         * Encodes the specified SocialAccount message. Does not implicitly {@link Profile.SocialAccount.verify|verify} messages.
         * @function encode
         * @memberof Profile.SocialAccount
         * @static
         * @param {Profile.ISocialAccount} message SocialAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SocialAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.proof != null && message.hasOwnProperty("proof"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.proof);
            return writer;
        };

        /**
         * Encodes the specified SocialAccount message, length delimited. Does not implicitly {@link Profile.SocialAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Profile.SocialAccount
         * @static
         * @param {Profile.ISocialAccount} message SocialAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SocialAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SocialAccount message from the specified reader or buffer.
         * @function decode
         * @memberof Profile.SocialAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Profile.SocialAccount} SocialAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SocialAccount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Profile.SocialAccount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.proof = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SocialAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Profile.SocialAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Profile.SocialAccount} SocialAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SocialAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SocialAccount message.
         * @function verify
         * @memberof Profile.SocialAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SocialAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.proof != null && message.hasOwnProperty("proof"))
                if (!$util.isString(message.proof))
                    return "proof: string expected";
            return null;
        };

        /**
         * Creates a SocialAccount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Profile.SocialAccount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Profile.SocialAccount} SocialAccount
         */
        SocialAccount.fromObject = function fromObject(object) {
            if (object instanceof $root.Profile.SocialAccount)
                return object;
            var message = new $root.Profile.SocialAccount();
            if (object.type != null)
                message.type = String(object.type);
            if (object.username != null)
                message.username = String(object.username);
            if (object.proof != null)
                message.proof = String(object.proof);
            return message;
        };

        /**
         * Creates a plain object from a SocialAccount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Profile.SocialAccount
         * @static
         * @param {Profile.SocialAccount} message SocialAccount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SocialAccount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = "";
                object.username = "";
                object.proof = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.proof != null && message.hasOwnProperty("proof"))
                object.proof = message.proof;
            return object;
        };

        /**
         * Converts this SocialAccount to JSON.
         * @function toJSON
         * @memberof Profile.SocialAccount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SocialAccount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SocialAccount;
    })();

    Profile.Colors = (function() {

        /**
         * Properties of a Colors.
         * @memberof Profile
         * @interface IColors
         * @property {string|null} [primary] Colors primary
         * @property {string|null} [secondary] Twitter style profile theme color, default #FFFFFF
         * @property {string|null} [text] Alternate color, default #ECEEF2
         * @property {string|null} [highlight] Text color, default #252525
         * @property {string|null} [highlightText] Highlight color, default #2BAD23
         */

        /**
         * Constructs a new Colors.
         * @memberof Profile
         * @classdesc Profile theme colors, not implemented. Values given in html style hex code
         * @implements IColors
         * @constructor
         * @param {Profile.IColors=} [properties] Properties to set
         */
        function Colors(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Colors primary.
         * @member {string} primary
         * @memberof Profile.Colors
         * @instance
         */
        Colors.prototype.primary = "";

        /**
         * Twitter style profile theme color, default #FFFFFF
         * @member {string} secondary
         * @memberof Profile.Colors
         * @instance
         */
        Colors.prototype.secondary = "";

        /**
         * Alternate color, default #ECEEF2
         * @member {string} text
         * @memberof Profile.Colors
         * @instance
         */
        Colors.prototype.text = "";

        /**
         * Text color, default #252525
         * @member {string} highlight
         * @memberof Profile.Colors
         * @instance
         */
        Colors.prototype.highlight = "";

        /**
         * Highlight color, default #2BAD23
         * @member {string} highlightText
         * @memberof Profile.Colors
         * @instance
         */
        Colors.prototype.highlightText = "";

        /**
         * Creates a new Colors instance using the specified properties.
         * @function create
         * @memberof Profile.Colors
         * @static
         * @param {Profile.IColors=} [properties] Properties to set
         * @returns {Profile.Colors} Colors instance
         */
        Colors.create = function create(properties) {
            return new Colors(properties);
        };

        /**
         * Encodes the specified Colors message. Does not implicitly {@link Profile.Colors.verify|verify} messages.
         * @function encode
         * @memberof Profile.Colors
         * @static
         * @param {Profile.IColors} message Colors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Colors.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.primary != null && message.hasOwnProperty("primary"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.primary);
            if (message.secondary != null && message.hasOwnProperty("secondary"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.secondary);
            if (message.text != null && message.hasOwnProperty("text"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
            if (message.highlight != null && message.hasOwnProperty("highlight"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.highlight);
            if (message.highlightText != null && message.hasOwnProperty("highlightText"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.highlightText);
            return writer;
        };

        /**
         * Encodes the specified Colors message, length delimited. Does not implicitly {@link Profile.Colors.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Profile.Colors
         * @static
         * @param {Profile.IColors} message Colors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Colors.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Colors message from the specified reader or buffer.
         * @function decode
         * @memberof Profile.Colors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Profile.Colors} Colors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Colors.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Profile.Colors();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.primary = reader.string();
                    break;
                case 2:
                    message.secondary = reader.string();
                    break;
                case 3:
                    message.text = reader.string();
                    break;
                case 4:
                    message.highlight = reader.string();
                    break;
                case 5:
                    message.highlightText = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Colors message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Profile.Colors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Profile.Colors} Colors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Colors.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Colors message.
         * @function verify
         * @memberof Profile.Colors
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Colors.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.primary != null && message.hasOwnProperty("primary"))
                if (!$util.isString(message.primary))
                    return "primary: string expected";
            if (message.secondary != null && message.hasOwnProperty("secondary"))
                if (!$util.isString(message.secondary))
                    return "secondary: string expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.highlight != null && message.hasOwnProperty("highlight"))
                if (!$util.isString(message.highlight))
                    return "highlight: string expected";
            if (message.highlightText != null && message.hasOwnProperty("highlightText"))
                if (!$util.isString(message.highlightText))
                    return "highlightText: string expected";
            return null;
        };

        /**
         * Creates a Colors message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Profile.Colors
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Profile.Colors} Colors
         */
        Colors.fromObject = function fromObject(object) {
            if (object instanceof $root.Profile.Colors)
                return object;
            var message = new $root.Profile.Colors();
            if (object.primary != null)
                message.primary = String(object.primary);
            if (object.secondary != null)
                message.secondary = String(object.secondary);
            if (object.text != null)
                message.text = String(object.text);
            if (object.highlight != null)
                message.highlight = String(object.highlight);
            if (object.highlightText != null)
                message.highlightText = String(object.highlightText);
            return message;
        };

        /**
         * Creates a plain object from a Colors message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Profile.Colors
         * @static
         * @param {Profile.Colors} message Colors
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Colors.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.primary = "";
                object.secondary = "";
                object.text = "";
                object.highlight = "";
                object.highlightText = "";
            }
            if (message.primary != null && message.hasOwnProperty("primary"))
                object.primary = message.primary;
            if (message.secondary != null && message.hasOwnProperty("secondary"))
                object.secondary = message.secondary;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.highlight != null && message.hasOwnProperty("highlight"))
                object.highlight = message.highlight;
            if (message.highlightText != null && message.hasOwnProperty("highlightText"))
                object.highlightText = message.highlightText;
            return object;
        };

        /**
         * Converts this Colors to JSON.
         * @function toJSON
         * @memberof Profile.Colors
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Colors.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Colors;
    })();

    Profile.Stats = (function() {

        /**
         * Properties of a Stats.
         * @memberof Profile
         * @interface IStats
         * @property {number|null} [followerCount] Stats followerCount
         * @property {number|null} [followingCount] Follower count
         * @property {number|null} [listingCount] Following count
         * @property {number|null} [ratingCount] Total active listing count
         * @property {number|null} [postCount] Rating count
         * @property {number|null} [averageRating] Total number of posts
         */

        /**
         * Constructs a new Stats.
         * @memberof Profile
         * @classdesc Unverified stats maintained and provided by server for convenience.
         * @implements IStats
         * @constructor
         * @param {Profile.IStats=} [properties] Properties to set
         */
        function Stats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Stats followerCount.
         * @member {number} followerCount
         * @memberof Profile.Stats
         * @instance
         */
        Stats.prototype.followerCount = 0;

        /**
         * Follower count
         * @member {number} followingCount
         * @memberof Profile.Stats
         * @instance
         */
        Stats.prototype.followingCount = 0;

        /**
         * Following count
         * @member {number} listingCount
         * @memberof Profile.Stats
         * @instance
         */
        Stats.prototype.listingCount = 0;

        /**
         * Total active listing count
         * @member {number} ratingCount
         * @memberof Profile.Stats
         * @instance
         */
        Stats.prototype.ratingCount = 0;

        /**
         * Rating count
         * @member {number} postCount
         * @memberof Profile.Stats
         * @instance
         */
        Stats.prototype.postCount = 0;

        /**
         * Total number of posts
         * @member {number} averageRating
         * @memberof Profile.Stats
         * @instance
         */
        Stats.prototype.averageRating = 0;

        /**
         * Creates a new Stats instance using the specified properties.
         * @function create
         * @memberof Profile.Stats
         * @static
         * @param {Profile.IStats=} [properties] Properties to set
         * @returns {Profile.Stats} Stats instance
         */
        Stats.create = function create(properties) {
            return new Stats(properties);
        };

        /**
         * Encodes the specified Stats message. Does not implicitly {@link Profile.Stats.verify|verify} messages.
         * @function encode
         * @memberof Profile.Stats
         * @static
         * @param {Profile.IStats} message Stats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Stats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.followerCount != null && message.hasOwnProperty("followerCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.followerCount);
            if (message.followingCount != null && message.hasOwnProperty("followingCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.followingCount);
            if (message.listingCount != null && message.hasOwnProperty("listingCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.listingCount);
            if (message.ratingCount != null && message.hasOwnProperty("ratingCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.ratingCount);
            if (message.postCount != null && message.hasOwnProperty("postCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.postCount);
            if (message.averageRating != null && message.hasOwnProperty("averageRating"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.averageRating);
            return writer;
        };

        /**
         * Encodes the specified Stats message, length delimited. Does not implicitly {@link Profile.Stats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Profile.Stats
         * @static
         * @param {Profile.IStats} message Stats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Stats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Stats message from the specified reader or buffer.
         * @function decode
         * @memberof Profile.Stats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Profile.Stats} Stats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Stats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Profile.Stats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.followerCount = reader.uint32();
                    break;
                case 2:
                    message.followingCount = reader.uint32();
                    break;
                case 3:
                    message.listingCount = reader.uint32();
                    break;
                case 4:
                    message.ratingCount = reader.uint32();
                    break;
                case 5:
                    message.postCount = reader.uint32();
                    break;
                case 6:
                    message.averageRating = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Stats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Profile.Stats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Profile.Stats} Stats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Stats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Stats message.
         * @function verify
         * @memberof Profile.Stats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Stats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.followerCount != null && message.hasOwnProperty("followerCount"))
                if (!$util.isInteger(message.followerCount))
                    return "followerCount: integer expected";
            if (message.followingCount != null && message.hasOwnProperty("followingCount"))
                if (!$util.isInteger(message.followingCount))
                    return "followingCount: integer expected";
            if (message.listingCount != null && message.hasOwnProperty("listingCount"))
                if (!$util.isInteger(message.listingCount))
                    return "listingCount: integer expected";
            if (message.ratingCount != null && message.hasOwnProperty("ratingCount"))
                if (!$util.isInteger(message.ratingCount))
                    return "ratingCount: integer expected";
            if (message.postCount != null && message.hasOwnProperty("postCount"))
                if (!$util.isInteger(message.postCount))
                    return "postCount: integer expected";
            if (message.averageRating != null && message.hasOwnProperty("averageRating"))
                if (typeof message.averageRating !== "number")
                    return "averageRating: number expected";
            return null;
        };

        /**
         * Creates a Stats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Profile.Stats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Profile.Stats} Stats
         */
        Stats.fromObject = function fromObject(object) {
            if (object instanceof $root.Profile.Stats)
                return object;
            var message = new $root.Profile.Stats();
            if (object.followerCount != null)
                message.followerCount = object.followerCount >>> 0;
            if (object.followingCount != null)
                message.followingCount = object.followingCount >>> 0;
            if (object.listingCount != null)
                message.listingCount = object.listingCount >>> 0;
            if (object.ratingCount != null)
                message.ratingCount = object.ratingCount >>> 0;
            if (object.postCount != null)
                message.postCount = object.postCount >>> 0;
            if (object.averageRating != null)
                message.averageRating = Number(object.averageRating);
            return message;
        };

        /**
         * Creates a plain object from a Stats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Profile.Stats
         * @static
         * @param {Profile.Stats} message Stats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Stats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.followerCount = 0;
                object.followingCount = 0;
                object.listingCount = 0;
                object.ratingCount = 0;
                object.postCount = 0;
                object.averageRating = 0;
            }
            if (message.followerCount != null && message.hasOwnProperty("followerCount"))
                object.followerCount = message.followerCount;
            if (message.followingCount != null && message.hasOwnProperty("followingCount"))
                object.followingCount = message.followingCount;
            if (message.listingCount != null && message.hasOwnProperty("listingCount"))
                object.listingCount = message.listingCount;
            if (message.ratingCount != null && message.hasOwnProperty("ratingCount"))
                object.ratingCount = message.ratingCount;
            if (message.postCount != null && message.hasOwnProperty("postCount"))
                object.postCount = message.postCount;
            if (message.averageRating != null && message.hasOwnProperty("averageRating"))
                object.averageRating = options.json && !isFinite(message.averageRating) ? String(message.averageRating) : message.averageRating;
            return object;
        };

        /**
         * Converts this Stats to JSON.
         * @function toJSON
         * @memberof Profile.Stats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Stats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Stats;
    })();

    return Profile;
})();

$root.SearchResponse = (function() {

    /**
     * Properties of a SearchResponse.
     * @exports ISearchResponse
     * @interface ISearchResponse
     * @property {string|null} [name] SearchResponse name
     * @property {string|null} [logo] Display name of search provider
     * @property {Object.<string,string>|null} [links] URL of icon for search provider
     * @property {Object.<string,SearchResponse.ISearchProviderOption>|null} [options] URI endpoints
     * @property {Object.<string,SearchResponse.ISearchProviderSort>|null} [sortBy] Filtering options for search
     */

    /**
     * Constructs a new SearchResponse.
     * @exports SearchResponse
     * @classdesc Represents a SearchResponse.
     * @implements ISearchResponse
     * @constructor
     * @param {ISearchResponse=} [properties] Properties to set
     */
    function SearchResponse(properties) {
        this.links = {};
        this.options = {};
        this.sortBy = {};
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SearchResponse name.
     * @member {string} name
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.name = "";

    /**
     * Display name of search provider
     * @member {string} logo
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.logo = "";

    /**
     * URL of icon for search provider
     * @member {Object.<string,string>} links
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.links = $util.emptyObject;

    /**
     * URI endpoints
     * @member {Object.<string,SearchResponse.ISearchProviderOption>} options
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.options = $util.emptyObject;

    /**
     * Filtering options for search
     * @member {Object.<string,SearchResponse.ISearchProviderSort>} sortBy
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.sortBy = $util.emptyObject;

    /**
     * Creates a new SearchResponse instance using the specified properties.
     * @function create
     * @memberof SearchResponse
     * @static
     * @param {ISearchResponse=} [properties] Properties to set
     * @returns {SearchResponse} SearchResponse instance
     */
    SearchResponse.create = function create(properties) {
        return new SearchResponse(properties);
    };

    /**
     * Encodes the specified SearchResponse message. Does not implicitly {@link SearchResponse.verify|verify} messages.
     * @function encode
     * @memberof SearchResponse
     * @static
     * @param {ISearchResponse} message SearchResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && message.hasOwnProperty("name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.logo != null && message.hasOwnProperty("logo"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.logo);
        if (message.links != null && message.hasOwnProperty("links"))
            for (var keys = Object.keys(message.links), i = 0; i < keys.length; ++i)
                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.links[keys[i]]).ldelim();
        if (message.options != null && message.hasOwnProperty("options"))
            for (var keys = Object.keys(message.options), i = 0; i < keys.length; ++i) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                $root.SearchResponse.SearchProviderOption.encode(message.options[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
            }
        if (message.sortBy != null && message.hasOwnProperty("sortBy"))
            for (var keys = Object.keys(message.sortBy), i = 0; i < keys.length; ++i) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                $root.SearchResponse.SearchProviderSort.encode(message.sortBy[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
            }
        return writer;
    };

    /**
     * Encodes the specified SearchResponse message, length delimited. Does not implicitly {@link SearchResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SearchResponse
     * @static
     * @param {ISearchResponse} message SearchResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SearchResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SearchResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SearchResponse} SearchResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse(), key;
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.logo = reader.string();
                break;
            case 3:
                reader.skip().pos++;
                if (message.links === $util.emptyObject)
                    message.links = {};
                key = reader.string();
                reader.pos++;
                message.links[key] = reader.string();
                break;
            case 4:
                reader.skip().pos++;
                if (message.options === $util.emptyObject)
                    message.options = {};
                key = reader.string();
                reader.pos++;
                message.options[key] = $root.SearchResponse.SearchProviderOption.decode(reader, reader.uint32());
                break;
            case 5:
                reader.skip().pos++;
                if (message.sortBy === $util.emptyObject)
                    message.sortBy = {};
                key = reader.string();
                reader.pos++;
                message.sortBy[key] = $root.SearchResponse.SearchProviderSort.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SearchResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SearchResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SearchResponse} SearchResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SearchResponse message.
     * @function verify
     * @memberof SearchResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SearchResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.logo != null && message.hasOwnProperty("logo"))
            if (!$util.isString(message.logo))
                return "logo: string expected";
        if (message.links != null && message.hasOwnProperty("links")) {
            if (!$util.isObject(message.links))
                return "links: object expected";
            var key = Object.keys(message.links);
            for (var i = 0; i < key.length; ++i)
                if (!$util.isString(message.links[key[i]]))
                    return "links: string{k:string} expected";
        }
        if (message.options != null && message.hasOwnProperty("options")) {
            if (!$util.isObject(message.options))
                return "options: object expected";
            var key = Object.keys(message.options);
            for (var i = 0; i < key.length; ++i) {
                var error = $root.SearchResponse.SearchProviderOption.verify(message.options[key[i]]);
                if (error)
                    return "options." + error;
            }
        }
        if (message.sortBy != null && message.hasOwnProperty("sortBy")) {
            if (!$util.isObject(message.sortBy))
                return "sortBy: object expected";
            var key = Object.keys(message.sortBy);
            for (var i = 0; i < key.length; ++i) {
                var error = $root.SearchResponse.SearchProviderSort.verify(message.sortBy[key[i]]);
                if (error)
                    return "sortBy." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SearchResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SearchResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SearchResponse} SearchResponse
     */
    SearchResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SearchResponse)
            return object;
        var message = new $root.SearchResponse();
        if (object.name != null)
            message.name = String(object.name);
        if (object.logo != null)
            message.logo = String(object.logo);
        if (object.links) {
            if (typeof object.links !== "object")
                throw TypeError(".SearchResponse.links: object expected");
            message.links = {};
            for (var keys = Object.keys(object.links), i = 0; i < keys.length; ++i)
                message.links[keys[i]] = String(object.links[keys[i]]);
        }
        if (object.options) {
            if (typeof object.options !== "object")
                throw TypeError(".SearchResponse.options: object expected");
            message.options = {};
            for (var keys = Object.keys(object.options), i = 0; i < keys.length; ++i) {
                if (typeof object.options[keys[i]] !== "object")
                    throw TypeError(".SearchResponse.options: object expected");
                message.options[keys[i]] = $root.SearchResponse.SearchProviderOption.fromObject(object.options[keys[i]]);
            }
        }
        if (object.sortBy) {
            if (typeof object.sortBy !== "object")
                throw TypeError(".SearchResponse.sortBy: object expected");
            message.sortBy = {};
            for (var keys = Object.keys(object.sortBy), i = 0; i < keys.length; ++i) {
                if (typeof object.sortBy[keys[i]] !== "object")
                    throw TypeError(".SearchResponse.sortBy: object expected");
                message.sortBy[keys[i]] = $root.SearchResponse.SearchProviderSort.fromObject(object.sortBy[keys[i]]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a SearchResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SearchResponse
     * @static
     * @param {SearchResponse} message SearchResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SearchResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.objects || options.defaults) {
            object.links = {};
            object.options = {};
            object.sortBy = {};
        }
        if (options.defaults) {
            object.name = "";
            object.logo = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.logo != null && message.hasOwnProperty("logo"))
            object.logo = message.logo;
        var keys2;
        if (message.links && (keys2 = Object.keys(message.links)).length) {
            object.links = {};
            for (var j = 0; j < keys2.length; ++j)
                object.links[keys2[j]] = message.links[keys2[j]];
        }
        if (message.options && (keys2 = Object.keys(message.options)).length) {
            object.options = {};
            for (var j = 0; j < keys2.length; ++j)
                object.options[keys2[j]] = $root.SearchResponse.SearchProviderOption.toObject(message.options[keys2[j]], options);
        }
        if (message.sortBy && (keys2 = Object.keys(message.sortBy)).length) {
            object.sortBy = {};
            for (var j = 0; j < keys2.length; ++j)
                object.sortBy[keys2[j]] = $root.SearchResponse.SearchProviderSort.toObject(message.sortBy[keys2[j]], options);
        }
        return object;
    };

    /**
     * Converts this SearchResponse to JSON.
     * @function toJSON
     * @memberof SearchResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SearchResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    SearchResponse.SearchProviderOptionItem = (function() {

        /**
         * Properties of a SearchProviderOptionItem.
         * @memberof SearchResponse
         * @interface ISearchProviderOptionItem
         * @property {string|null} [label] SearchProviderOptionItem label
         * @property {google.protobuf.IAny|null} [value] SearchProviderOptionItem value
         * @property {boolean|null} [checked] SearchProviderOptionItem checked
         * @property {boolean|null} ["default"] SearchProviderOptionItem default
         */

        /**
         * Constructs a new SearchProviderOptionItem.
         * @memberof SearchResponse
         * @classdesc Represents a SearchProviderOptionItem.
         * @implements ISearchProviderOptionItem
         * @constructor
         * @param {SearchResponse.ISearchProviderOptionItem=} [properties] Properties to set
         */
        function SearchProviderOptionItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchProviderOptionItem label.
         * @member {string} label
         * @memberof SearchResponse.SearchProviderOptionItem
         * @instance
         */
        SearchProviderOptionItem.prototype.label = "";

        /**
         * SearchProviderOptionItem value.
         * @member {google.protobuf.IAny|null|undefined} value
         * @memberof SearchResponse.SearchProviderOptionItem
         * @instance
         */
        SearchProviderOptionItem.prototype.value = null;

        /**
         * SearchProviderOptionItem checked.
         * @member {boolean} checked
         * @memberof SearchResponse.SearchProviderOptionItem
         * @instance
         */
        SearchProviderOptionItem.prototype.checked = false;

        /**
         * SearchProviderOptionItem default.
         * @member {boolean} default
         * @memberof SearchResponse.SearchProviderOptionItem
         * @instance
         */
        SearchProviderOptionItem.prototype["default"] = false;

        /**
         * Creates a new SearchProviderOptionItem instance using the specified properties.
         * @function create
         * @memberof SearchResponse.SearchProviderOptionItem
         * @static
         * @param {SearchResponse.ISearchProviderOptionItem=} [properties] Properties to set
         * @returns {SearchResponse.SearchProviderOptionItem} SearchProviderOptionItem instance
         */
        SearchProviderOptionItem.create = function create(properties) {
            return new SearchProviderOptionItem(properties);
        };

        /**
         * Encodes the specified SearchProviderOptionItem message. Does not implicitly {@link SearchResponse.SearchProviderOptionItem.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.SearchProviderOptionItem
         * @static
         * @param {SearchResponse.ISearchProviderOptionItem} message SearchProviderOptionItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchProviderOptionItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.label != null && message.hasOwnProperty("label"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
            if (message.value != null && message.hasOwnProperty("value"))
                $root.google.protobuf.Any.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.checked != null && message.hasOwnProperty("checked"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.checked);
            if (message["default"] != null && message.hasOwnProperty("default"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message["default"]);
            return writer;
        };

        /**
         * Encodes the specified SearchProviderOptionItem message, length delimited. Does not implicitly {@link SearchResponse.SearchProviderOptionItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.SearchProviderOptionItem
         * @static
         * @param {SearchResponse.ISearchProviderOptionItem} message SearchProviderOptionItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchProviderOptionItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchProviderOptionItem message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.SearchProviderOptionItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.SearchProviderOptionItem} SearchProviderOptionItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchProviderOptionItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.SearchProviderOptionItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.label = reader.string();
                    break;
                case 2:
                    message.value = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.checked = reader.bool();
                    break;
                case 4:
                    message["default"] = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchProviderOptionItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.SearchProviderOptionItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.SearchProviderOptionItem} SearchProviderOptionItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchProviderOptionItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchProviderOptionItem message.
         * @function verify
         * @memberof SearchResponse.SearchProviderOptionItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchProviderOptionItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                var error = $root.google.protobuf.Any.verify(message.value);
                if (error)
                    return "value." + error;
            }
            if (message.checked != null && message.hasOwnProperty("checked"))
                if (typeof message.checked !== "boolean")
                    return "checked: boolean expected";
            if (message["default"] != null && message.hasOwnProperty("default"))
                if (typeof message["default"] !== "boolean")
                    return "default: boolean expected";
            return null;
        };

        /**
         * Creates a SearchProviderOptionItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.SearchProviderOptionItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.SearchProviderOptionItem} SearchProviderOptionItem
         */
        SearchProviderOptionItem.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.SearchProviderOptionItem)
                return object;
            var message = new $root.SearchResponse.SearchProviderOptionItem();
            if (object.label != null)
                message.label = String(object.label);
            if (object.value != null) {
                if (typeof object.value !== "object")
                    throw TypeError(".SearchResponse.SearchProviderOptionItem.value: object expected");
                message.value = $root.google.protobuf.Any.fromObject(object.value);
            }
            if (object.checked != null)
                message.checked = Boolean(object.checked);
            if (object["default"] != null)
                message["default"] = Boolean(object["default"]);
            return message;
        };

        /**
         * Creates a plain object from a SearchProviderOptionItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.SearchProviderOptionItem
         * @static
         * @param {SearchResponse.SearchProviderOptionItem} message SearchProviderOptionItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchProviderOptionItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.label = "";
                object.value = null;
                object.checked = false;
                object["default"] = false;
            }
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = $root.google.protobuf.Any.toObject(message.value, options);
            if (message.checked != null && message.hasOwnProperty("checked"))
                object.checked = message.checked;
            if (message["default"] != null && message.hasOwnProperty("default"))
                object["default"] = message["default"];
            return object;
        };

        /**
         * Converts this SearchProviderOptionItem to JSON.
         * @function toJSON
         * @memberof SearchResponse.SearchProviderOptionItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchProviderOptionItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchProviderOptionItem;
    })();

    SearchResponse.SearchProviderOption = (function() {

        /**
         * Properties of a SearchProviderOption.
         * @memberof SearchResponse
         * @interface ISearchProviderOption
         * @property {string|null} [label] SearchProviderOption label
         * @property {SearchResponse.SearchProviderOption.SearchOptionType|null} [type] SearchProviderOption type
         * @property {Object.<string,SearchResponse.ISearchProviderOptionItem>|null} [options] SearchProviderOption options
         */

        /**
         * Constructs a new SearchProviderOption.
         * @memberof SearchResponse
         * @classdesc Represents a SearchProviderOption.
         * @implements ISearchProviderOption
         * @constructor
         * @param {SearchResponse.ISearchProviderOption=} [properties] Properties to set
         */
        function SearchProviderOption(properties) {
            this.options = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchProviderOption label.
         * @member {string} label
         * @memberof SearchResponse.SearchProviderOption
         * @instance
         */
        SearchProviderOption.prototype.label = "";

        /**
         * SearchProviderOption type.
         * @member {SearchResponse.SearchProviderOption.SearchOptionType} type
         * @memberof SearchResponse.SearchProviderOption
         * @instance
         */
        SearchProviderOption.prototype.type = 0;

        /**
         * SearchProviderOption options.
         * @member {Object.<string,SearchResponse.ISearchProviderOptionItem>} options
         * @memberof SearchResponse.SearchProviderOption
         * @instance
         */
        SearchProviderOption.prototype.options = $util.emptyObject;

        /**
         * Creates a new SearchProviderOption instance using the specified properties.
         * @function create
         * @memberof SearchResponse.SearchProviderOption
         * @static
         * @param {SearchResponse.ISearchProviderOption=} [properties] Properties to set
         * @returns {SearchResponse.SearchProviderOption} SearchProviderOption instance
         */
        SearchProviderOption.create = function create(properties) {
            return new SearchProviderOption(properties);
        };

        /**
         * Encodes the specified SearchProviderOption message. Does not implicitly {@link SearchResponse.SearchProviderOption.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.SearchProviderOption
         * @static
         * @param {SearchResponse.ISearchProviderOption} message SearchProviderOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchProviderOption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.label != null && message.hasOwnProperty("label"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.options != null && message.hasOwnProperty("options"))
                for (var keys = Object.keys(message.options), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.SearchResponse.SearchProviderOptionItem.encode(message.options[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified SearchProviderOption message, length delimited. Does not implicitly {@link SearchResponse.SearchProviderOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.SearchProviderOption
         * @static
         * @param {SearchResponse.ISearchProviderOption} message SearchProviderOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchProviderOption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchProviderOption message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.SearchProviderOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.SearchProviderOption} SearchProviderOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchProviderOption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.SearchProviderOption(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.label = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    reader.skip().pos++;
                    if (message.options === $util.emptyObject)
                        message.options = {};
                    key = reader.string();
                    reader.pos++;
                    message.options[key] = $root.SearchResponse.SearchProviderOptionItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchProviderOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.SearchProviderOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.SearchProviderOption} SearchProviderOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchProviderOption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchProviderOption message.
         * @function verify
         * @memberof SearchResponse.SearchProviderOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchProviderOption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!$util.isObject(message.options))
                    return "options: object expected";
                var key = Object.keys(message.options);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.SearchResponse.SearchProviderOptionItem.verify(message.options[key[i]]);
                    if (error)
                        return "options." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SearchProviderOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.SearchProviderOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.SearchProviderOption} SearchProviderOption
         */
        SearchProviderOption.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.SearchProviderOption)
                return object;
            var message = new $root.SearchResponse.SearchProviderOption();
            if (object.label != null)
                message.label = String(object.label);
            switch (object.type) {
            case "RADIO":
            case 0:
                message.type = 0;
                break;
            case "CHECKBOX":
            case 1:
                message.type = 1;
                break;
            case "DROPDOWN":
            case 2:
                message.type = 2;
                break;
            }
            if (object.options) {
                if (typeof object.options !== "object")
                    throw TypeError(".SearchResponse.SearchProviderOption.options: object expected");
                message.options = {};
                for (var keys = Object.keys(object.options), i = 0; i < keys.length; ++i) {
                    if (typeof object.options[keys[i]] !== "object")
                        throw TypeError(".SearchResponse.SearchProviderOption.options: object expected");
                    message.options[keys[i]] = $root.SearchResponse.SearchProviderOptionItem.fromObject(object.options[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SearchProviderOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.SearchProviderOption
         * @static
         * @param {SearchResponse.SearchProviderOption} message SearchProviderOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchProviderOption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.options = {};
            if (options.defaults) {
                object.label = "";
                object.type = options.enums === String ? "RADIO" : 0;
            }
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.SearchResponse.SearchProviderOption.SearchOptionType[message.type] : message.type;
            var keys2;
            if (message.options && (keys2 = Object.keys(message.options)).length) {
                object.options = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.options[keys2[j]] = $root.SearchResponse.SearchProviderOptionItem.toObject(message.options[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this SearchProviderOption to JSON.
         * @function toJSON
         * @memberof SearchResponse.SearchProviderOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchProviderOption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * SearchOptionType enum.
         * @name SearchResponse.SearchProviderOption.SearchOptionType
         * @enum {string}
         * @property {number} RADIO=0 RADIO value
         * @property {number} CHECKBOX=1 CHECKBOX value
         * @property {number} DROPDOWN=2 DROPDOWN value
         */
        SearchProviderOption.SearchOptionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "RADIO"] = 0;
            values[valuesById[1] = "CHECKBOX"] = 1;
            values[valuesById[2] = "DROPDOWN"] = 2;
            return values;
        })();

        return SearchProviderOption;
    })();

    SearchResponse.SearchProviderSort = (function() {

        /**
         * Properties of a SearchProviderSort.
         * @memberof SearchResponse
         * @interface ISearchProviderSort
         * @property {string|null} [label] SearchProviderSort label
         * @property {boolean|null} [selected] SearchProviderSort selected
         * @property {boolean|null} ["default"] SearchProviderSort default
         */

        /**
         * Constructs a new SearchProviderSort.
         * @memberof SearchResponse
         * @classdesc Represents a SearchProviderSort.
         * @implements ISearchProviderSort
         * @constructor
         * @param {SearchResponse.ISearchProviderSort=} [properties] Properties to set
         */
        function SearchProviderSort(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchProviderSort label.
         * @member {string} label
         * @memberof SearchResponse.SearchProviderSort
         * @instance
         */
        SearchProviderSort.prototype.label = "";

        /**
         * SearchProviderSort selected.
         * @member {boolean} selected
         * @memberof SearchResponse.SearchProviderSort
         * @instance
         */
        SearchProviderSort.prototype.selected = false;

        /**
         * SearchProviderSort default.
         * @member {boolean} default
         * @memberof SearchResponse.SearchProviderSort
         * @instance
         */
        SearchProviderSort.prototype["default"] = false;

        /**
         * Creates a new SearchProviderSort instance using the specified properties.
         * @function create
         * @memberof SearchResponse.SearchProviderSort
         * @static
         * @param {SearchResponse.ISearchProviderSort=} [properties] Properties to set
         * @returns {SearchResponse.SearchProviderSort} SearchProviderSort instance
         */
        SearchProviderSort.create = function create(properties) {
            return new SearchProviderSort(properties);
        };

        /**
         * Encodes the specified SearchProviderSort message. Does not implicitly {@link SearchResponse.SearchProviderSort.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.SearchProviderSort
         * @static
         * @param {SearchResponse.ISearchProviderSort} message SearchProviderSort message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchProviderSort.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.label != null && message.hasOwnProperty("label"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
            if (message.selected != null && message.hasOwnProperty("selected"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.selected);
            if (message["default"] != null && message.hasOwnProperty("default"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message["default"]);
            return writer;
        };

        /**
         * Encodes the specified SearchProviderSort message, length delimited. Does not implicitly {@link SearchResponse.SearchProviderSort.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.SearchProviderSort
         * @static
         * @param {SearchResponse.ISearchProviderSort} message SearchProviderSort message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchProviderSort.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchProviderSort message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.SearchProviderSort
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.SearchProviderSort} SearchProviderSort
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchProviderSort.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.SearchProviderSort();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.label = reader.string();
                    break;
                case 2:
                    message.selected = reader.bool();
                    break;
                case 3:
                    message["default"] = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchProviderSort message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.SearchProviderSort
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.SearchProviderSort} SearchProviderSort
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchProviderSort.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchProviderSort message.
         * @function verify
         * @memberof SearchResponse.SearchProviderSort
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchProviderSort.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            if (message.selected != null && message.hasOwnProperty("selected"))
                if (typeof message.selected !== "boolean")
                    return "selected: boolean expected";
            if (message["default"] != null && message.hasOwnProperty("default"))
                if (typeof message["default"] !== "boolean")
                    return "default: boolean expected";
            return null;
        };

        /**
         * Creates a SearchProviderSort message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.SearchProviderSort
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.SearchProviderSort} SearchProviderSort
         */
        SearchProviderSort.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.SearchProviderSort)
                return object;
            var message = new $root.SearchResponse.SearchProviderSort();
            if (object.label != null)
                message.label = String(object.label);
            if (object.selected != null)
                message.selected = Boolean(object.selected);
            if (object["default"] != null)
                message["default"] = Boolean(object["default"]);
            return message;
        };

        /**
         * Creates a plain object from a SearchProviderSort message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.SearchProviderSort
         * @static
         * @param {SearchResponse.SearchProviderSort} message SearchProviderSort
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchProviderSort.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.label = "";
                object.selected = false;
                object["default"] = false;
            }
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            if (message.selected != null && message.hasOwnProperty("selected"))
                object.selected = message.selected;
            if (message["default"] != null && message.hasOwnProperty("default"))
                object["default"] = message["default"];
            return object;
        };

        /**
         * Converts this SearchProviderSort to JSON.
         * @function toJSON
         * @memberof SearchResponse.SearchProviderSort
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchProviderSort.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchProviderSort;
    })();

    /**
     * SearchResultType enum.
     * @name SearchResponse.SearchResultType
     * @enum {string}
     * @property {number} LISTING=0 LISTING value
     * @property {number} NODE=1 NODE value
     */
    SearchResponse.SearchResultType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LISTING"] = 0;
        values[valuesById[1] = "NODE"] = 1;
        return values;
    })();

    SearchResponse.Vendor = (function() {

        /**
         * Properties of a Vendor.
         * @memberof SearchResponse
         * @interface IVendor
         * @property {string|null} [peerID] Vendor peerID
         * @property {string|null} [name] Vendor name
         * @property {IImage|null} [avatarHashes] Vendor avatarHashes
         */

        /**
         * Constructs a new Vendor.
         * @memberof SearchResponse
         * @classdesc Represents a Vendor.
         * @implements IVendor
         * @constructor
         * @param {SearchResponse.IVendor=} [properties] Properties to set
         */
        function Vendor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vendor peerID.
         * @member {string} peerID
         * @memberof SearchResponse.Vendor
         * @instance
         */
        Vendor.prototype.peerID = "";

        /**
         * Vendor name.
         * @member {string} name
         * @memberof SearchResponse.Vendor
         * @instance
         */
        Vendor.prototype.name = "";

        /**
         * Vendor avatarHashes.
         * @member {IImage|null|undefined} avatarHashes
         * @memberof SearchResponse.Vendor
         * @instance
         */
        Vendor.prototype.avatarHashes = null;

        /**
         * Creates a new Vendor instance using the specified properties.
         * @function create
         * @memberof SearchResponse.Vendor
         * @static
         * @param {SearchResponse.IVendor=} [properties] Properties to set
         * @returns {SearchResponse.Vendor} Vendor instance
         */
        Vendor.create = function create(properties) {
            return new Vendor(properties);
        };

        /**
         * Encodes the specified Vendor message. Does not implicitly {@link SearchResponse.Vendor.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.Vendor
         * @static
         * @param {SearchResponse.IVendor} message Vendor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vendor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peerID != null && message.hasOwnProperty("peerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerID);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatarHashes != null && message.hasOwnProperty("avatarHashes"))
                $root.Image.encode(message.avatarHashes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Vendor message, length delimited. Does not implicitly {@link SearchResponse.Vendor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.Vendor
         * @static
         * @param {SearchResponse.IVendor} message Vendor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vendor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vendor message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.Vendor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.Vendor} Vendor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vendor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.Vendor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.peerID = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.avatarHashes = $root.Image.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vendor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.Vendor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.Vendor} Vendor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vendor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vendor message.
         * @function verify
         * @memberof SearchResponse.Vendor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vendor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peerID != null && message.hasOwnProperty("peerID"))
                if (!$util.isString(message.peerID))
                    return "peerID: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarHashes != null && message.hasOwnProperty("avatarHashes")) {
                var error = $root.Image.verify(message.avatarHashes);
                if (error)
                    return "avatarHashes." + error;
            }
            return null;
        };

        /**
         * Creates a Vendor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.Vendor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.Vendor} Vendor
         */
        Vendor.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.Vendor)
                return object;
            var message = new $root.SearchResponse.Vendor();
            if (object.peerID != null)
                message.peerID = String(object.peerID);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarHashes != null) {
                if (typeof object.avatarHashes !== "object")
                    throw TypeError(".SearchResponse.Vendor.avatarHashes: object expected");
                message.avatarHashes = $root.Image.fromObject(object.avatarHashes);
            }
            return message;
        };

        /**
         * Creates a plain object from a Vendor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.Vendor
         * @static
         * @param {SearchResponse.Vendor} message Vendor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vendor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.peerID = "";
                object.name = "";
                object.avatarHashes = null;
            }
            if (message.peerID != null && message.hasOwnProperty("peerID"))
                object.peerID = message.peerID;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarHashes != null && message.hasOwnProperty("avatarHashes"))
                object.avatarHashes = $root.Image.toObject(message.avatarHashes, options);
            return object;
        };

        /**
         * Converts this Vendor to JSON.
         * @function toJSON
         * @memberof SearchResponse.Vendor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vendor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Vendor;
    })();

    SearchResponse.Listing = (function() {

        /**
         * Properties of a Listing.
         * @memberof SearchResponse
         * @interface IListing
         * @property {string|null} [title] Listing title
         * @property {string|null} [slug] Listing slug
         * @property {string|null} [description] Listing description
         * @property {Array.<string>|null} [acceptedCurrencies] Listing acceptedCurrencies
         * @property {number|null} [averageRating] Listing averageRating
         * @property {number|null} [ratingCount] Listing ratingCount
         * @property {SearchResponse.ContractType|null} [contractType] Listing contractType
         * @property {boolean|null} [nsfw] Listing nsfw
         * @property {IImage|null} [thumbnail] Listing thumbnail
         * @property {SearchResponse.IPrice|null} [price] Listing price
         */

        /**
         * Constructs a new Listing.
         * @memberof SearchResponse
         * @classdesc Represents a Listing.
         * @implements IListing
         * @constructor
         * @param {SearchResponse.IListing=} [properties] Properties to set
         */
        function Listing(properties) {
            this.acceptedCurrencies = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Listing title.
         * @member {string} title
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.title = "";

        /**
         * Listing slug.
         * @member {string} slug
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.slug = "";

        /**
         * Listing description.
         * @member {string} description
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.description = "";

        /**
         * Listing acceptedCurrencies.
         * @member {Array.<string>} acceptedCurrencies
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.acceptedCurrencies = $util.emptyArray;

        /**
         * Listing averageRating.
         * @member {number} averageRating
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.averageRating = 0;

        /**
         * Listing ratingCount.
         * @member {number} ratingCount
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.ratingCount = 0;

        /**
         * Listing contractType.
         * @member {SearchResponse.ContractType} contractType
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.contractType = 0;

        /**
         * Listing nsfw.
         * @member {boolean} nsfw
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.nsfw = false;

        /**
         * Listing thumbnail.
         * @member {IImage|null|undefined} thumbnail
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.thumbnail = null;

        /**
         * Listing price.
         * @member {SearchResponse.IPrice|null|undefined} price
         * @memberof SearchResponse.Listing
         * @instance
         */
        Listing.prototype.price = null;

        /**
         * Creates a new Listing instance using the specified properties.
         * @function create
         * @memberof SearchResponse.Listing
         * @static
         * @param {SearchResponse.IListing=} [properties] Properties to set
         * @returns {SearchResponse.Listing} Listing instance
         */
        Listing.create = function create(properties) {
            return new Listing(properties);
        };

        /**
         * Encodes the specified Listing message. Does not implicitly {@link SearchResponse.Listing.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.Listing
         * @static
         * @param {SearchResponse.IListing} message Listing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Listing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.slug != null && message.hasOwnProperty("slug"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.slug);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
            if (message.acceptedCurrencies != null && message.acceptedCurrencies.length)
                for (var i = 0; i < message.acceptedCurrencies.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.acceptedCurrencies[i]);
            if (message.averageRating != null && message.hasOwnProperty("averageRating"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.averageRating);
            if (message.ratingCount != null && message.hasOwnProperty("ratingCount"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.ratingCount);
            if (message.contractType != null && message.hasOwnProperty("contractType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.contractType);
            if (message.nsfw != null && message.hasOwnProperty("nsfw"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.nsfw);
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                $root.Image.encode(message.thumbnail, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.price != null && message.hasOwnProperty("price"))
                $root.SearchResponse.Price.encode(message.price, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Listing message, length delimited. Does not implicitly {@link SearchResponse.Listing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.Listing
         * @static
         * @param {SearchResponse.IListing} message Listing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Listing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Listing message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.Listing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.Listing} Listing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Listing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.Listing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.slug = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    if (!(message.acceptedCurrencies && message.acceptedCurrencies.length))
                        message.acceptedCurrencies = [];
                    message.acceptedCurrencies.push(reader.string());
                    break;
                case 5:
                    message.averageRating = reader.uint32();
                    break;
                case 6:
                    message.ratingCount = reader.uint32();
                    break;
                case 7:
                    message.contractType = reader.int32();
                    break;
                case 8:
                    message.nsfw = reader.bool();
                    break;
                case 9:
                    message.thumbnail = $root.Image.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.price = $root.SearchResponse.Price.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Listing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.Listing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.Listing} Listing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Listing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Listing message.
         * @function verify
         * @memberof SearchResponse.Listing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Listing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.slug != null && message.hasOwnProperty("slug"))
                if (!$util.isString(message.slug))
                    return "slug: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.acceptedCurrencies != null && message.hasOwnProperty("acceptedCurrencies")) {
                if (!Array.isArray(message.acceptedCurrencies))
                    return "acceptedCurrencies: array expected";
                for (var i = 0; i < message.acceptedCurrencies.length; ++i)
                    if (!$util.isString(message.acceptedCurrencies[i]))
                        return "acceptedCurrencies: string[] expected";
            }
            if (message.averageRating != null && message.hasOwnProperty("averageRating"))
                if (!$util.isInteger(message.averageRating))
                    return "averageRating: integer expected";
            if (message.ratingCount != null && message.hasOwnProperty("ratingCount"))
                if (!$util.isInteger(message.ratingCount))
                    return "ratingCount: integer expected";
            if (message.contractType != null && message.hasOwnProperty("contractType"))
                switch (message.contractType) {
                default:
                    return "contractType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.nsfw != null && message.hasOwnProperty("nsfw"))
                if (typeof message.nsfw !== "boolean")
                    return "nsfw: boolean expected";
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail")) {
                var error = $root.Image.verify(message.thumbnail);
                if (error)
                    return "thumbnail." + error;
            }
            if (message.price != null && message.hasOwnProperty("price")) {
                var error = $root.SearchResponse.Price.verify(message.price);
                if (error)
                    return "price." + error;
            }
            return null;
        };

        /**
         * Creates a Listing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.Listing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.Listing} Listing
         */
        Listing.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.Listing)
                return object;
            var message = new $root.SearchResponse.Listing();
            if (object.title != null)
                message.title = String(object.title);
            if (object.slug != null)
                message.slug = String(object.slug);
            if (object.description != null)
                message.description = String(object.description);
            if (object.acceptedCurrencies) {
                if (!Array.isArray(object.acceptedCurrencies))
                    throw TypeError(".SearchResponse.Listing.acceptedCurrencies: array expected");
                message.acceptedCurrencies = [];
                for (var i = 0; i < object.acceptedCurrencies.length; ++i)
                    message.acceptedCurrencies[i] = String(object.acceptedCurrencies[i]);
            }
            if (object.averageRating != null)
                message.averageRating = object.averageRating >>> 0;
            if (object.ratingCount != null)
                message.ratingCount = object.ratingCount >>> 0;
            switch (object.contractType) {
            case "PHYSICAL_GOOD":
            case 0:
                message.contractType = 0;
                break;
            case "DIGITAL_GOOD":
            case 1:
                message.contractType = 1;
                break;
            case "SERVICE":
            case 2:
                message.contractType = 2;
                break;
            case "CROWD_FUND":
            case 3:
                message.contractType = 3;
                break;
            case "CRYPTOCURRENCY":
            case 4:
                message.contractType = 4;
                break;
            }
            if (object.nsfw != null)
                message.nsfw = Boolean(object.nsfw);
            if (object.thumbnail != null) {
                if (typeof object.thumbnail !== "object")
                    throw TypeError(".SearchResponse.Listing.thumbnail: object expected");
                message.thumbnail = $root.Image.fromObject(object.thumbnail);
            }
            if (object.price != null) {
                if (typeof object.price !== "object")
                    throw TypeError(".SearchResponse.Listing.price: object expected");
                message.price = $root.SearchResponse.Price.fromObject(object.price);
            }
            return message;
        };

        /**
         * Creates a plain object from a Listing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.Listing
         * @static
         * @param {SearchResponse.Listing} message Listing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Listing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.acceptedCurrencies = [];
            if (options.defaults) {
                object.title = "";
                object.slug = "";
                object.description = "";
                object.averageRating = 0;
                object.ratingCount = 0;
                object.contractType = options.enums === String ? "PHYSICAL_GOOD" : 0;
                object.nsfw = false;
                object.thumbnail = null;
                object.price = null;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.slug != null && message.hasOwnProperty("slug"))
                object.slug = message.slug;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.acceptedCurrencies && message.acceptedCurrencies.length) {
                object.acceptedCurrencies = [];
                for (var j = 0; j < message.acceptedCurrencies.length; ++j)
                    object.acceptedCurrencies[j] = message.acceptedCurrencies[j];
            }
            if (message.averageRating != null && message.hasOwnProperty("averageRating"))
                object.averageRating = message.averageRating;
            if (message.ratingCount != null && message.hasOwnProperty("ratingCount"))
                object.ratingCount = message.ratingCount;
            if (message.contractType != null && message.hasOwnProperty("contractType"))
                object.contractType = options.enums === String ? $root.SearchResponse.ContractType[message.contractType] : message.contractType;
            if (message.nsfw != null && message.hasOwnProperty("nsfw"))
                object.nsfw = message.nsfw;
            if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
                object.thumbnail = $root.Image.toObject(message.thumbnail, options);
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = $root.SearchResponse.Price.toObject(message.price, options);
            return object;
        };

        /**
         * Converts this Listing to JSON.
         * @function toJSON
         * @memberof SearchResponse.Listing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Listing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Listing;
    })();

    SearchResponse.Price = (function() {

        /**
         * Properties of a Price.
         * @memberof SearchResponse
         * @interface IPrice
         * @property {string|null} [currencyCode] Price currencyCode
         * @property {number|Long|null} [amount] Price amount
         */

        /**
         * Constructs a new Price.
         * @memberof SearchResponse
         * @classdesc Represents a Price.
         * @implements IPrice
         * @constructor
         * @param {SearchResponse.IPrice=} [properties] Properties to set
         */
        function Price(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Price currencyCode.
         * @member {string} currencyCode
         * @memberof SearchResponse.Price
         * @instance
         */
        Price.prototype.currencyCode = "";

        /**
         * Price amount.
         * @member {number|Long} amount
         * @memberof SearchResponse.Price
         * @instance
         */
        Price.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Price instance using the specified properties.
         * @function create
         * @memberof SearchResponse.Price
         * @static
         * @param {SearchResponse.IPrice=} [properties] Properties to set
         * @returns {SearchResponse.Price} Price instance
         */
        Price.create = function create(properties) {
            return new Price(properties);
        };

        /**
         * Encodes the specified Price message. Does not implicitly {@link SearchResponse.Price.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.Price
         * @static
         * @param {SearchResponse.IPrice} message Price message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Price.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.currencyCode);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified Price message, length delimited. Does not implicitly {@link SearchResponse.Price.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.Price
         * @static
         * @param {SearchResponse.IPrice} message Price message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Price.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Price message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.Price
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.Price} Price
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Price.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.Price();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currencyCode = reader.string();
                    break;
                case 2:
                    message.amount = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Price message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.Price
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.Price} Price
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Price.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Price message.
         * @function verify
         * @memberof SearchResponse.Price
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Price.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                if (!$util.isString(message.currencyCode))
                    return "currencyCode: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a Price message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.Price
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.Price} Price
         */
        Price.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.Price)
                return object;
            var message = new $root.SearchResponse.Price();
            if (object.currencyCode != null)
                message.currencyCode = String(object.currencyCode);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a Price message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.Price
         * @static
         * @param {SearchResponse.Price} message Price
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Price.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currencyCode = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                object.currencyCode = message.currencyCode;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
            return object;
        };

        /**
         * Converts this Price to JSON.
         * @function toJSON
         * @memberof SearchResponse.Price
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Price.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Price;
    })();

    /**
     * ContractType enum.
     * @name SearchResponse.ContractType
     * @enum {string}
     * @property {number} PHYSICAL_GOOD=0 PHYSICAL_GOOD value
     * @property {number} DIGITAL_GOOD=1 DIGITAL_GOOD value
     * @property {number} SERVICE=2 SERVICE value
     * @property {number} CROWD_FUND=3 CROWD_FUND value
     * @property {number} CRYPTOCURRENCY=4 CRYPTOCURRENCY value
     */
    SearchResponse.ContractType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PHYSICAL_GOOD"] = 0;
        values[valuesById[1] = "DIGITAL_GOOD"] = 1;
        values[valuesById[2] = "SERVICE"] = 2;
        values[valuesById[3] = "CROWD_FUND"] = 3;
        values[valuesById[4] = "CRYPTOCURRENCY"] = 4;
        return values;
    })();

    SearchResponse.VendorWrap = (function() {

        /**
         * Properties of a VendorWrap.
         * @memberof SearchResponse
         * @interface IVendorWrap
         * @property {SearchResponse.IVendor|null} [data] VendorWrap data
         */

        /**
         * Constructs a new VendorWrap.
         * @memberof SearchResponse
         * @classdesc Represents a VendorWrap.
         * @implements IVendorWrap
         * @constructor
         * @param {SearchResponse.IVendorWrap=} [properties] Properties to set
         */
        function VendorWrap(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VendorWrap data.
         * @member {SearchResponse.IVendor|null|undefined} data
         * @memberof SearchResponse.VendorWrap
         * @instance
         */
        VendorWrap.prototype.data = null;

        /**
         * Creates a new VendorWrap instance using the specified properties.
         * @function create
         * @memberof SearchResponse.VendorWrap
         * @static
         * @param {SearchResponse.IVendorWrap=} [properties] Properties to set
         * @returns {SearchResponse.VendorWrap} VendorWrap instance
         */
        VendorWrap.create = function create(properties) {
            return new VendorWrap(properties);
        };

        /**
         * Encodes the specified VendorWrap message. Does not implicitly {@link SearchResponse.VendorWrap.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.VendorWrap
         * @static
         * @param {SearchResponse.IVendorWrap} message VendorWrap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VendorWrap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                $root.SearchResponse.Vendor.encode(message.data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VendorWrap message, length delimited. Does not implicitly {@link SearchResponse.VendorWrap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.VendorWrap
         * @static
         * @param {SearchResponse.IVendorWrap} message VendorWrap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VendorWrap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VendorWrap message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.VendorWrap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.VendorWrap} VendorWrap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VendorWrap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.VendorWrap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = $root.SearchResponse.Vendor.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VendorWrap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.VendorWrap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.VendorWrap} VendorWrap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VendorWrap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VendorWrap message.
         * @function verify
         * @memberof SearchResponse.VendorWrap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VendorWrap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data")) {
                var error = $root.SearchResponse.Vendor.verify(message.data);
                if (error)
                    return "data." + error;
            }
            return null;
        };

        /**
         * Creates a VendorWrap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.VendorWrap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.VendorWrap} VendorWrap
         */
        VendorWrap.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.VendorWrap)
                return object;
            var message = new $root.SearchResponse.VendorWrap();
            if (object.data != null) {
                if (typeof object.data !== "object")
                    throw TypeError(".SearchResponse.VendorWrap.data: object expected");
                message.data = $root.SearchResponse.Vendor.fromObject(object.data);
            }
            return message;
        };

        /**
         * Creates a plain object from a VendorWrap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.VendorWrap
         * @static
         * @param {SearchResponse.VendorWrap} message VendorWrap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VendorWrap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.data = null;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = $root.SearchResponse.Vendor.toObject(message.data, options);
            return object;
        };

        /**
         * Converts this VendorWrap to JSON.
         * @function toJSON
         * @memberof SearchResponse.VendorWrap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VendorWrap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VendorWrap;
    })();

    SearchResponse.Relationship = (function() {

        /**
         * Properties of a Relationship.
         * @memberof SearchResponse
         * @interface IRelationship
         * @property {Array.<string>|null} [moderators] Relationship moderators
         * @property {SearchResponse.IVendorWrap|null} [vendor] Relationship vendor
         */

        /**
         * Constructs a new Relationship.
         * @memberof SearchResponse
         * @classdesc Represents a Relationship.
         * @implements IRelationship
         * @constructor
         * @param {SearchResponse.IRelationship=} [properties] Properties to set
         */
        function Relationship(properties) {
            this.moderators = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Relationship moderators.
         * @member {Array.<string>} moderators
         * @memberof SearchResponse.Relationship
         * @instance
         */
        Relationship.prototype.moderators = $util.emptyArray;

        /**
         * Relationship vendor.
         * @member {SearchResponse.IVendorWrap|null|undefined} vendor
         * @memberof SearchResponse.Relationship
         * @instance
         */
        Relationship.prototype.vendor = null;

        /**
         * Creates a new Relationship instance using the specified properties.
         * @function create
         * @memberof SearchResponse.Relationship
         * @static
         * @param {SearchResponse.IRelationship=} [properties] Properties to set
         * @returns {SearchResponse.Relationship} Relationship instance
         */
        Relationship.create = function create(properties) {
            return new Relationship(properties);
        };

        /**
         * Encodes the specified Relationship message. Does not implicitly {@link SearchResponse.Relationship.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.Relationship
         * @static
         * @param {SearchResponse.IRelationship} message Relationship message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Relationship.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.moderators != null && message.moderators.length)
                for (var i = 0; i < message.moderators.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.moderators[i]);
            if (message.vendor != null && message.hasOwnProperty("vendor"))
                $root.SearchResponse.VendorWrap.encode(message.vendor, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Relationship message, length delimited. Does not implicitly {@link SearchResponse.Relationship.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.Relationship
         * @static
         * @param {SearchResponse.IRelationship} message Relationship message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Relationship.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Relationship message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.Relationship
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.Relationship} Relationship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Relationship.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.Relationship();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.moderators && message.moderators.length))
                        message.moderators = [];
                    message.moderators.push(reader.string());
                    break;
                case 2:
                    message.vendor = $root.SearchResponse.VendorWrap.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Relationship message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.Relationship
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.Relationship} Relationship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Relationship.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Relationship message.
         * @function verify
         * @memberof SearchResponse.Relationship
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Relationship.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.moderators != null && message.hasOwnProperty("moderators")) {
                if (!Array.isArray(message.moderators))
                    return "moderators: array expected";
                for (var i = 0; i < message.moderators.length; ++i)
                    if (!$util.isString(message.moderators[i]))
                        return "moderators: string[] expected";
            }
            if (message.vendor != null && message.hasOwnProperty("vendor")) {
                var error = $root.SearchResponse.VendorWrap.verify(message.vendor);
                if (error)
                    return "vendor." + error;
            }
            return null;
        };

        /**
         * Creates a Relationship message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.Relationship
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.Relationship} Relationship
         */
        Relationship.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.Relationship)
                return object;
            var message = new $root.SearchResponse.Relationship();
            if (object.moderators) {
                if (!Array.isArray(object.moderators))
                    throw TypeError(".SearchResponse.Relationship.moderators: array expected");
                message.moderators = [];
                for (var i = 0; i < object.moderators.length; ++i)
                    message.moderators[i] = String(object.moderators[i]);
            }
            if (object.vendor != null) {
                if (typeof object.vendor !== "object")
                    throw TypeError(".SearchResponse.Relationship.vendor: object expected");
                message.vendor = $root.SearchResponse.VendorWrap.fromObject(object.vendor);
            }
            return message;
        };

        /**
         * Creates a plain object from a Relationship message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.Relationship
         * @static
         * @param {SearchResponse.Relationship} message Relationship
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Relationship.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.moderators = [];
            if (options.defaults)
                object.vendor = null;
            if (message.moderators && message.moderators.length) {
                object.moderators = [];
                for (var j = 0; j < message.moderators.length; ++j)
                    object.moderators[j] = message.moderators[j];
            }
            if (message.vendor != null && message.hasOwnProperty("vendor"))
                object.vendor = $root.SearchResponse.VendorWrap.toObject(message.vendor, options);
            return object;
        };

        /**
         * Converts this Relationship to JSON.
         * @function toJSON
         * @memberof SearchResponse.Relationship
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Relationship.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Relationship;
    })();

    SearchResponse.SearchResult = (function() {

        /**
         * Properties of a SearchResult.
         * @memberof SearchResponse
         * @interface ISearchResult
         * @property {string|null} [type] SearchResult type
         * @property {SearchResponse.IRelationship|null} [relationships] SearchResult relationships
         * @property {SearchResponse.IListing|null} [data] SearchResult data
         */

        /**
         * Constructs a new SearchResult.
         * @memberof SearchResponse
         * @classdesc Represents a SearchResult.
         * @implements ISearchResult
         * @constructor
         * @param {SearchResponse.ISearchResult=} [properties] Properties to set
         */
        function SearchResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchResult type.
         * @member {string} type
         * @memberof SearchResponse.SearchResult
         * @instance
         */
        SearchResult.prototype.type = "";

        /**
         * SearchResult relationships.
         * @member {SearchResponse.IRelationship|null|undefined} relationships
         * @memberof SearchResponse.SearchResult
         * @instance
         */
        SearchResult.prototype.relationships = null;

        /**
         * SearchResult data.
         * @member {SearchResponse.IListing|null|undefined} data
         * @memberof SearchResponse.SearchResult
         * @instance
         */
        SearchResult.prototype.data = null;

        /**
         * Creates a new SearchResult instance using the specified properties.
         * @function create
         * @memberof SearchResponse.SearchResult
         * @static
         * @param {SearchResponse.ISearchResult=} [properties] Properties to set
         * @returns {SearchResponse.SearchResult} SearchResult instance
         */
        SearchResult.create = function create(properties) {
            return new SearchResult(properties);
        };

        /**
         * Encodes the specified SearchResult message. Does not implicitly {@link SearchResponse.SearchResult.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.SearchResult
         * @static
         * @param {SearchResponse.ISearchResult} message SearchResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.relationships != null && message.hasOwnProperty("relationships"))
                $root.SearchResponse.Relationship.encode(message.relationships, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.data != null && message.hasOwnProperty("data"))
                $root.SearchResponse.Listing.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SearchResult message, length delimited. Does not implicitly {@link SearchResponse.SearchResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.SearchResult
         * @static
         * @param {SearchResponse.ISearchResult} message SearchResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchResult message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.SearchResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.SearchResult} SearchResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.SearchResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.relationships = $root.SearchResponse.Relationship.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.data = $root.SearchResponse.Listing.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.SearchResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.SearchResult} SearchResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchResult message.
         * @function verify
         * @memberof SearchResponse.SearchResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.relationships != null && message.hasOwnProperty("relationships")) {
                var error = $root.SearchResponse.Relationship.verify(message.relationships);
                if (error)
                    return "relationships." + error;
            }
            if (message.data != null && message.hasOwnProperty("data")) {
                var error = $root.SearchResponse.Listing.verify(message.data);
                if (error)
                    return "data." + error;
            }
            return null;
        };

        /**
         * Creates a SearchResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.SearchResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.SearchResult} SearchResult
         */
        SearchResult.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.SearchResult)
                return object;
            var message = new $root.SearchResponse.SearchResult();
            if (object.type != null)
                message.type = String(object.type);
            if (object.relationships != null) {
                if (typeof object.relationships !== "object")
                    throw TypeError(".SearchResponse.SearchResult.relationships: object expected");
                message.relationships = $root.SearchResponse.Relationship.fromObject(object.relationships);
            }
            if (object.data != null) {
                if (typeof object.data !== "object")
                    throw TypeError(".SearchResponse.SearchResult.data: object expected");
                message.data = $root.SearchResponse.Listing.fromObject(object.data);
            }
            return message;
        };

        /**
         * Creates a plain object from a SearchResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.SearchResult
         * @static
         * @param {SearchResponse.SearchResult} message SearchResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = "";
                object.relationships = null;
                object.data = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.relationships != null && message.hasOwnProperty("relationships"))
                object.relationships = $root.SearchResponse.Relationship.toObject(message.relationships, options);
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = $root.SearchResponse.Listing.toObject(message.data, options);
            return object;
        };

        /**
         * Converts this SearchResult to JSON.
         * @function toJSON
         * @memberof SearchResponse.SearchResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchResult;
    })();

    SearchResponse.SearchResults = (function() {

        /**
         * Properties of a SearchResults.
         * @memberof SearchResponse
         * @interface ISearchResults
         * @property {number|Long|null} [total] SearchResults total
         * @property {boolean|null} [morePages] SearchResults morePages
         * @property {Array.<SearchResponse.ISearchResult>|null} [results] SearchResults results
         */

        /**
         * Constructs a new SearchResults.
         * @memberof SearchResponse
         * @classdesc Represents a SearchResults.
         * @implements ISearchResults
         * @constructor
         * @param {SearchResponse.ISearchResults=} [properties] Properties to set
         */
        function SearchResults(properties) {
            this.results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchResults total.
         * @member {number|Long} total
         * @memberof SearchResponse.SearchResults
         * @instance
         */
        SearchResults.prototype.total = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SearchResults morePages.
         * @member {boolean} morePages
         * @memberof SearchResponse.SearchResults
         * @instance
         */
        SearchResults.prototype.morePages = false;

        /**
         * SearchResults results.
         * @member {Array.<SearchResponse.ISearchResult>} results
         * @memberof SearchResponse.SearchResults
         * @instance
         */
        SearchResults.prototype.results = $util.emptyArray;

        /**
         * Creates a new SearchResults instance using the specified properties.
         * @function create
         * @memberof SearchResponse.SearchResults
         * @static
         * @param {SearchResponse.ISearchResults=} [properties] Properties to set
         * @returns {SearchResponse.SearchResults} SearchResults instance
         */
        SearchResults.create = function create(properties) {
            return new SearchResults(properties);
        };

        /**
         * Encodes the specified SearchResults message. Does not implicitly {@link SearchResponse.SearchResults.verify|verify} messages.
         * @function encode
         * @memberof SearchResponse.SearchResults
         * @static
         * @param {SearchResponse.ISearchResults} message SearchResults message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResults.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.total != null && message.hasOwnProperty("total"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.total);
            if (message.morePages != null && message.hasOwnProperty("morePages"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.morePages);
            if (message.results != null && message.results.length)
                for (var i = 0; i < message.results.length; ++i)
                    $root.SearchResponse.SearchResult.encode(message.results[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SearchResults message, length delimited. Does not implicitly {@link SearchResponse.SearchResults.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchResponse.SearchResults
         * @static
         * @param {SearchResponse.ISearchResults} message SearchResults message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResults.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchResults message from the specified reader or buffer.
         * @function decode
         * @memberof SearchResponse.SearchResults
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchResponse.SearchResults} SearchResults
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResults.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse.SearchResults();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.total = reader.uint64();
                    break;
                case 2:
                    message.morePages = reader.bool();
                    break;
                case 4:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.SearchResponse.SearchResult.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchResults message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchResponse.SearchResults
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchResponse.SearchResults} SearchResults
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResults.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchResults message.
         * @function verify
         * @memberof SearchResponse.SearchResults
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchResults.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.total != null && message.hasOwnProperty("total"))
                if (!$util.isInteger(message.total) && !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high)))
                    return "total: integer|Long expected";
            if (message.morePages != null && message.hasOwnProperty("morePages"))
                if (typeof message.morePages !== "boolean")
                    return "morePages: boolean expected";
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (var i = 0; i < message.results.length; ++i) {
                    var error = $root.SearchResponse.SearchResult.verify(message.results[i]);
                    if (error)
                        return "results." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SearchResults message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchResponse.SearchResults
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchResponse.SearchResults} SearchResults
         */
        SearchResults.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchResponse.SearchResults)
                return object;
            var message = new $root.SearchResponse.SearchResults();
            if (object.total != null)
                if ($util.Long)
                    (message.total = $util.Long.fromValue(object.total)).unsigned = true;
                else if (typeof object.total === "string")
                    message.total = parseInt(object.total, 10);
                else if (typeof object.total === "number")
                    message.total = object.total;
                else if (typeof object.total === "object")
                    message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber(true);
            if (object.morePages != null)
                message.morePages = Boolean(object.morePages);
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".SearchResponse.SearchResults.results: array expected");
                message.results = [];
                for (var i = 0; i < object.results.length; ++i) {
                    if (typeof object.results[i] !== "object")
                        throw TypeError(".SearchResponse.SearchResults.results: object expected");
                    message.results[i] = $root.SearchResponse.SearchResult.fromObject(object.results[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SearchResults message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchResponse.SearchResults
         * @static
         * @param {SearchResponse.SearchResults} message SearchResults
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchResults.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.results = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.total = options.longs === String ? "0" : 0;
                object.morePages = false;
            }
            if (message.total != null && message.hasOwnProperty("total"))
                if (typeof message.total === "number")
                    object.total = options.longs === String ? String(message.total) : message.total;
                else
                    object.total = options.longs === String ? $util.Long.prototype.toString.call(message.total) : options.longs === Number ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber(true) : message.total;
            if (message.morePages != null && message.hasOwnProperty("morePages"))
                object.morePages = message.morePages;
            if (message.results && message.results.length) {
                object.results = [];
                for (var j = 0; j < message.results.length; ++j)
                    object.results[j] = $root.SearchResponse.SearchResult.toObject(message.results[j], options);
            }
            return object;
        };

        /**
         * Converts this SearchResults to JSON.
         * @function toJSON
         * @memberof SearchResponse.SearchResults
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchResults.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchResults;
    })();

    return SearchResponse;
})();

$root.ListingFlat = (function() {

    /**
     * Properties of a ListingFlat.
     * @exports IListingFlat
     * @interface IListingFlat
     * @property {string|null} [id] ListingFlat id
     * @property {string|null} [peerID] ListingFlat peerID
     * @property {string|null} [slug] ListingFlat slug
     * @property {string|null} [title] ListingFlat title
     * @property {string|null} [description] ListingFlat description
     * @property {boolean|null} [nsfw] ListingFlat nsfw
     * @property {ListingFlat.ContractType|null} [contractType] ListingFlat contractType
     * @property {string|null} [profileName] ListingFlat profileName
     * @property {string|null} [profileAvatar] ListingFlat profileAvatar
     * @property {string|null} [pricingCurrency] ListingFlat pricingCurrency
     * @property {Array.<string>|null} [acceptedCurrencies] ListingFlat acceptedCurrencies
     * @property {number|Long|null} [price] ListingFlat price
     * @property {number|null} [ratingCount] ListingFlat ratingCount
     * @property {number|null} [averageRating] ListingFlat averageRating
     * @property {string|null} [thumbnail] ListingFlat thumbnail
     */

    /**
     * Constructs a new ListingFlat.
     * @exports ListingFlat
     * @classdesc Represents a ListingFlat.
     * @implements IListingFlat
     * @constructor
     * @param {IListingFlat=} [properties] Properties to set
     */
    function ListingFlat(properties) {
        this.acceptedCurrencies = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ListingFlat id.
     * @member {string} id
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.id = "";

    /**
     * ListingFlat peerID.
     * @member {string} peerID
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.peerID = "";

    /**
     * ListingFlat slug.
     * @member {string} slug
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.slug = "";

    /**
     * ListingFlat title.
     * @member {string} title
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.title = "";

    /**
     * ListingFlat description.
     * @member {string} description
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.description = "";

    /**
     * ListingFlat nsfw.
     * @member {boolean} nsfw
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.nsfw = false;

    /**
     * ListingFlat contractType.
     * @member {ListingFlat.ContractType} contractType
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.contractType = 0;

    /**
     * ListingFlat profileName.
     * @member {string} profileName
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.profileName = "";

    /**
     * ListingFlat profileAvatar.
     * @member {string} profileAvatar
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.profileAvatar = "";

    /**
     * ListingFlat pricingCurrency.
     * @member {string} pricingCurrency
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.pricingCurrency = "";

    /**
     * ListingFlat acceptedCurrencies.
     * @member {Array.<string>} acceptedCurrencies
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.acceptedCurrencies = $util.emptyArray;

    /**
     * ListingFlat price.
     * @member {number|Long} price
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.price = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ListingFlat ratingCount.
     * @member {number} ratingCount
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.ratingCount = 0;

    /**
     * ListingFlat averageRating.
     * @member {number} averageRating
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.averageRating = 0;

    /**
     * ListingFlat thumbnail.
     * @member {string} thumbnail
     * @memberof ListingFlat
     * @instance
     */
    ListingFlat.prototype.thumbnail = "";

    /**
     * Creates a new ListingFlat instance using the specified properties.
     * @function create
     * @memberof ListingFlat
     * @static
     * @param {IListingFlat=} [properties] Properties to set
     * @returns {ListingFlat} ListingFlat instance
     */
    ListingFlat.create = function create(properties) {
        return new ListingFlat(properties);
    };

    /**
     * Encodes the specified ListingFlat message. Does not implicitly {@link ListingFlat.verify|verify} messages.
     * @function encode
     * @memberof ListingFlat
     * @static
     * @param {IListingFlat} message ListingFlat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListingFlat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
        if (message.peerID != null && message.hasOwnProperty("peerID"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.peerID);
        if (message.slug != null && message.hasOwnProperty("slug"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.slug);
        if (message.title != null && message.hasOwnProperty("title"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.title);
        if (message.description != null && message.hasOwnProperty("description"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
        if (message.nsfw != null && message.hasOwnProperty("nsfw"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.nsfw);
        if (message.contractType != null && message.hasOwnProperty("contractType"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.contractType);
        if (message.profileName != null && message.hasOwnProperty("profileName"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.profileName);
        if (message.profileAvatar != null && message.hasOwnProperty("profileAvatar"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.profileAvatar);
        if (message.pricingCurrency != null && message.hasOwnProperty("pricingCurrency"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.pricingCurrency);
        if (message.acceptedCurrencies != null && message.acceptedCurrencies.length)
            for (var i = 0; i < message.acceptedCurrencies.length; ++i)
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.acceptedCurrencies[i]);
        if (message.price != null && message.hasOwnProperty("price"))
            writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.price);
        if (message.ratingCount != null && message.hasOwnProperty("ratingCount"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.ratingCount);
        if (message.averageRating != null && message.hasOwnProperty("averageRating"))
            writer.uint32(/* id 14, wireType 5 =*/117).float(message.averageRating);
        if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
            writer.uint32(/* id 15, wireType 2 =*/122).string(message.thumbnail);
        return writer;
    };

    /**
     * Encodes the specified ListingFlat message, length delimited. Does not implicitly {@link ListingFlat.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListingFlat
     * @static
     * @param {IListingFlat} message ListingFlat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListingFlat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListingFlat message from the specified reader or buffer.
     * @function decode
     * @memberof ListingFlat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListingFlat} ListingFlat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListingFlat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListingFlat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.string();
                break;
            case 2:
                message.peerID = reader.string();
                break;
            case 3:
                message.slug = reader.string();
                break;
            case 4:
                message.title = reader.string();
                break;
            case 5:
                message.description = reader.string();
                break;
            case 6:
                message.nsfw = reader.bool();
                break;
            case 7:
                message.contractType = reader.int32();
                break;
            case 8:
                message.profileName = reader.string();
                break;
            case 9:
                message.profileAvatar = reader.string();
                break;
            case 10:
                message.pricingCurrency = reader.string();
                break;
            case 11:
                if (!(message.acceptedCurrencies && message.acceptedCurrencies.length))
                    message.acceptedCurrencies = [];
                message.acceptedCurrencies.push(reader.string());
                break;
            case 12:
                message.price = reader.uint64();
                break;
            case 13:
                message.ratingCount = reader.uint32();
                break;
            case 14:
                message.averageRating = reader.float();
                break;
            case 15:
                message.thumbnail = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListingFlat message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListingFlat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListingFlat} ListingFlat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListingFlat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListingFlat message.
     * @function verify
     * @memberof ListingFlat
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListingFlat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        if (message.peerID != null && message.hasOwnProperty("peerID"))
            if (!$util.isString(message.peerID))
                return "peerID: string expected";
        if (message.slug != null && message.hasOwnProperty("slug"))
            if (!$util.isString(message.slug))
                return "slug: string expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.nsfw != null && message.hasOwnProperty("nsfw"))
            if (typeof message.nsfw !== "boolean")
                return "nsfw: boolean expected";
        if (message.contractType != null && message.hasOwnProperty("contractType"))
            switch (message.contractType) {
            default:
                return "contractType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
        if (message.profileName != null && message.hasOwnProperty("profileName"))
            if (!$util.isString(message.profileName))
                return "profileName: string expected";
        if (message.profileAvatar != null && message.hasOwnProperty("profileAvatar"))
            if (!$util.isString(message.profileAvatar))
                return "profileAvatar: string expected";
        if (message.pricingCurrency != null && message.hasOwnProperty("pricingCurrency"))
            if (!$util.isString(message.pricingCurrency))
                return "pricingCurrency: string expected";
        if (message.acceptedCurrencies != null && message.hasOwnProperty("acceptedCurrencies")) {
            if (!Array.isArray(message.acceptedCurrencies))
                return "acceptedCurrencies: array expected";
            for (var i = 0; i < message.acceptedCurrencies.length; ++i)
                if (!$util.isString(message.acceptedCurrencies[i]))
                    return "acceptedCurrencies: string[] expected";
        }
        if (message.price != null && message.hasOwnProperty("price"))
            if (!$util.isInteger(message.price) && !(message.price && $util.isInteger(message.price.low) && $util.isInteger(message.price.high)))
                return "price: integer|Long expected";
        if (message.ratingCount != null && message.hasOwnProperty("ratingCount"))
            if (!$util.isInteger(message.ratingCount))
                return "ratingCount: integer expected";
        if (message.averageRating != null && message.hasOwnProperty("averageRating"))
            if (typeof message.averageRating !== "number")
                return "averageRating: number expected";
        if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
            if (!$util.isString(message.thumbnail))
                return "thumbnail: string expected";
        return null;
    };

    /**
     * Creates a ListingFlat message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListingFlat
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListingFlat} ListingFlat
     */
    ListingFlat.fromObject = function fromObject(object) {
        if (object instanceof $root.ListingFlat)
            return object;
        var message = new $root.ListingFlat();
        if (object.id != null)
            message.id = String(object.id);
        if (object.peerID != null)
            message.peerID = String(object.peerID);
        if (object.slug != null)
            message.slug = String(object.slug);
        if (object.title != null)
            message.title = String(object.title);
        if (object.description != null)
            message.description = String(object.description);
        if (object.nsfw != null)
            message.nsfw = Boolean(object.nsfw);
        switch (object.contractType) {
        case "PHYSICAL_GOOD":
        case 0:
            message.contractType = 0;
            break;
        case "DIGITAL_GOOD":
        case 1:
            message.contractType = 1;
            break;
        case "SERVICE":
        case 2:
            message.contractType = 2;
            break;
        case "CROWD_FUND":
        case 3:
            message.contractType = 3;
            break;
        case "CRYPTOCURRENCY":
        case 4:
            message.contractType = 4;
            break;
        }
        if (object.profileName != null)
            message.profileName = String(object.profileName);
        if (object.profileAvatar != null)
            message.profileAvatar = String(object.profileAvatar);
        if (object.pricingCurrency != null)
            message.pricingCurrency = String(object.pricingCurrency);
        if (object.acceptedCurrencies) {
            if (!Array.isArray(object.acceptedCurrencies))
                throw TypeError(".ListingFlat.acceptedCurrencies: array expected");
            message.acceptedCurrencies = [];
            for (var i = 0; i < object.acceptedCurrencies.length; ++i)
                message.acceptedCurrencies[i] = String(object.acceptedCurrencies[i]);
        }
        if (object.price != null)
            if ($util.Long)
                (message.price = $util.Long.fromValue(object.price)).unsigned = true;
            else if (typeof object.price === "string")
                message.price = parseInt(object.price, 10);
            else if (typeof object.price === "number")
                message.price = object.price;
            else if (typeof object.price === "object")
                message.price = new $util.LongBits(object.price.low >>> 0, object.price.high >>> 0).toNumber(true);
        if (object.ratingCount != null)
            message.ratingCount = object.ratingCount >>> 0;
        if (object.averageRating != null)
            message.averageRating = Number(object.averageRating);
        if (object.thumbnail != null)
            message.thumbnail = String(object.thumbnail);
        return message;
    };

    /**
     * Creates a plain object from a ListingFlat message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListingFlat
     * @static
     * @param {ListingFlat} message ListingFlat
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListingFlat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.acceptedCurrencies = [];
        if (options.defaults) {
            object.id = "";
            object.peerID = "";
            object.slug = "";
            object.title = "";
            object.description = "";
            object.nsfw = false;
            object.contractType = options.enums === String ? "PHYSICAL_GOOD" : 0;
            object.profileName = "";
            object.profileAvatar = "";
            object.pricingCurrency = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.price = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.price = options.longs === String ? "0" : 0;
            object.ratingCount = 0;
            object.averageRating = 0;
            object.thumbnail = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.peerID != null && message.hasOwnProperty("peerID"))
            object.peerID = message.peerID;
        if (message.slug != null && message.hasOwnProperty("slug"))
            object.slug = message.slug;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.nsfw != null && message.hasOwnProperty("nsfw"))
            object.nsfw = message.nsfw;
        if (message.contractType != null && message.hasOwnProperty("contractType"))
            object.contractType = options.enums === String ? $root.ListingFlat.ContractType[message.contractType] : message.contractType;
        if (message.profileName != null && message.hasOwnProperty("profileName"))
            object.profileName = message.profileName;
        if (message.profileAvatar != null && message.hasOwnProperty("profileAvatar"))
            object.profileAvatar = message.profileAvatar;
        if (message.pricingCurrency != null && message.hasOwnProperty("pricingCurrency"))
            object.pricingCurrency = message.pricingCurrency;
        if (message.acceptedCurrencies && message.acceptedCurrencies.length) {
            object.acceptedCurrencies = [];
            for (var j = 0; j < message.acceptedCurrencies.length; ++j)
                object.acceptedCurrencies[j] = message.acceptedCurrencies[j];
        }
        if (message.price != null && message.hasOwnProperty("price"))
            if (typeof message.price === "number")
                object.price = options.longs === String ? String(message.price) : message.price;
            else
                object.price = options.longs === String ? $util.Long.prototype.toString.call(message.price) : options.longs === Number ? new $util.LongBits(message.price.low >>> 0, message.price.high >>> 0).toNumber(true) : message.price;
        if (message.ratingCount != null && message.hasOwnProperty("ratingCount"))
            object.ratingCount = message.ratingCount;
        if (message.averageRating != null && message.hasOwnProperty("averageRating"))
            object.averageRating = options.json && !isFinite(message.averageRating) ? String(message.averageRating) : message.averageRating;
        if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
            object.thumbnail = message.thumbnail;
        return object;
    };

    /**
     * Converts this ListingFlat to JSON.
     * @function toJSON
     * @memberof ListingFlat
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListingFlat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * ContractType enum.
     * @name ListingFlat.ContractType
     * @enum {string}
     * @property {number} PHYSICAL_GOOD=0 PHYSICAL_GOOD value
     * @property {number} DIGITAL_GOOD=1 DIGITAL_GOOD value
     * @property {number} SERVICE=2 SERVICE value
     * @property {number} CROWD_FUND=3 CROWD_FUND value
     * @property {number} CRYPTOCURRENCY=4 CRYPTOCURRENCY value
     */
    ListingFlat.ContractType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PHYSICAL_GOOD"] = 0;
        values[valuesById[1] = "DIGITAL_GOOD"] = 1;
        values[valuesById[2] = "SERVICE"] = 2;
        values[valuesById[3] = "CROWD_FUND"] = 3;
        values[valuesById[4] = "CRYPTOCURRENCY"] = 4;
        return values;
    })();

    return ListingFlat;
})();

module.exports = $root;
